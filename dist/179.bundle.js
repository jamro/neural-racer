"use strict";(self.webpackChunkneural_racer=self.webpackChunkneural_racer||[]).push([[179],{279(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ RenderTarget)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(133);\n/* harmony import */ var _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(583);\n/* harmony import */ var _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5589);\n\n\n\n\n"use strict";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .L)("renderTarget");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === "number") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on("resize", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .g || descriptor.depthStencilTexture instanceof _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: "depth24plus-stencil8",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off("resize", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\n\n//# sourceMappingURL=RenderTarget.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUNnQjtBQUNwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQSxjQUFjLHNGQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtFQUFPLDhDQUE4QyxzRkFBYTtBQUN0SDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNGQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzPzk0ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9SZW5kZXJUYXJnZXQgPSBjbGFzcyBfUmVuZGVyVGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBbZGVzY3JpcHRvcl0gLSBPcHRpb25zIGZvciBjcmVhdGluZyBhIHJlbmRlciB0YXJnZXQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZXNjcmlwdG9yID0ge30pIHtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIHJlbmRlciB0YXJnZXQgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcInJlbmRlclRhcmdldFwiKTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB0ZXh0dXJlcyB0aGF0IGNhbiBiZSB3cml0dGVuIHRvIGJ5IHRoZSBHUFUgLSBtb3N0bHkgdGhpcyBoYXMgb25lIHRleHR1cmUgaW4gUGl4aSwgYnV0IHlvdSBjb3VsZFxuICAgICAqIHdyaXRlIHRvIG11bHRpcGxlIGlmIHJlcXVpcmVkISAoZWcgZGVmZXJyZWQgbGlnaHRpbmcpXG4gICAgICovXG4gICAgdGhpcy5jb2xvclRleHR1cmVzID0gW107XG4gICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICB0aGlzLmlzUm9vdCA9IGZhbHNlO1xuICAgIHRoaXMuX3NpemUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIC8qKiBpZiB0cnVlLCB0aGVuIHdoZW4gdGhlIHJlbmRlciB0YXJnZXQgaXMgZGVzdHJveWVkLCBpdCB3aWxsIGRlc3Ryb3kgYWxsIHRoZSB0ZXh0dXJlcyB0aGF0IHdlcmUgY3JlYXRlZCBmb3IgaXQuICovXG4gICAgdGhpcy5fbWFuYWdlZENvbG9yVGV4dHVyZXMgPSBmYWxzZTtcbiAgICBkZXNjcmlwdG9yID0geyAuLi5fUmVuZGVyVGFyZ2V0LmRlZmF1bHRPcHRpb25zLCAuLi5kZXNjcmlwdG9yIH07XG4gICAgdGhpcy5zdGVuY2lsID0gZGVzY3JpcHRvci5zdGVuY2lsO1xuICAgIHRoaXMuZGVwdGggPSBkZXNjcmlwdG9yLmRlcHRoO1xuICAgIHRoaXMuaXNSb290ID0gZGVzY3JpcHRvci5pc1Jvb3Q7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmNvbG9yVGV4dHVyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuX21hbmFnZWRDb2xvclRleHR1cmVzID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRvci5jb2xvclRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jb2xvclRleHR1cmVzLnB1c2goXG4gICAgICAgICAgbmV3IFRleHR1cmVTb3VyY2Uoe1xuICAgICAgICAgICAgd2lkdGg6IGRlc2NyaXB0b3Iud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlc2NyaXB0b3IuaGVpZ2h0LFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogZGVzY3JpcHRvci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBkZXNjcmlwdG9yLmFudGlhbGlhc1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sb3JUZXh0dXJlcyA9IFsuLi5kZXNjcmlwdG9yLmNvbG9yVGV4dHVyZXMubWFwKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLnNvdXJjZSldO1xuICAgICAgY29uc3QgY29sb3JTb3VyY2UgPSB0aGlzLmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgICB0aGlzLnJlc2l6ZShjb2xvclNvdXJjZS53aWR0aCwgY29sb3JTb3VyY2UuaGVpZ2h0LCBjb2xvclNvdXJjZS5fcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5vbihcInJlc2l6ZVwiLCB0aGlzLm9uU291cmNlUmVzaXplLCB0aGlzKTtcbiAgICBpZiAoZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxUZXh0dXJlIHx8IHRoaXMuc3RlbmNpbCkge1xuICAgICAgaWYgKGRlc2NyaXB0b3IuZGVwdGhTdGVuY2lsVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUgfHwgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUgPSBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbFRleHR1cmUuc291cmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbnN1cmVEZXB0aFN0ZW5jaWxUZXh0dXJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIGNvbnN0IF9zaXplID0gdGhpcy5fc2l6ZTtcbiAgICBfc2l6ZVswXSA9IHRoaXMucGl4ZWxXaWR0aDtcbiAgICBfc2l6ZVsxXSA9IHRoaXMucGl4ZWxIZWlnaHQ7XG4gICAgcmV0dXJuIF9zaXplO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmUuc291cmNlLndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5oZWlnaHQ7XG4gIH1cbiAgZ2V0IHBpeGVsV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5waXhlbFdpZHRoO1xuICB9XG4gIGdldCBwaXhlbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmUuc291cmNlLnBpeGVsSGVpZ2h0O1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yVGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gIH1cbiAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICB9XG4gIG9uU291cmNlUmVzaXplKHNvdXJjZSkge1xuICAgIHRoaXMucmVzaXplKHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCwgc291cmNlLl9yZXNvbHV0aW9uLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyB3aWxsIGVuc3VyZSBhIGRlcHRoU3RlbmNpbCB0ZXh0dXJlIGlzIGNyZWF0ZWQgZm9yIHRoaXMgcmVuZGVyIHRhcmdldC5cbiAgICogTW9zdCBsaWtlbHkgY2FsbGVkIGJ5IHRoZSBtYXNrIHN5c3RlbSB0byBtYWtlIHN1cmUgd2UgaGF2ZSBzdGVuY2lsIGJ1ZmZlciBhZGRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnN1cmVEZXB0aFN0ZW5jaWxUZXh0dXJlKCkge1xuICAgIGlmICghdGhpcy5kZXB0aFN0ZW5jaWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUgPSBuZXcgVGV4dHVyZVNvdXJjZSh7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICByZXNvbHV0aW9uOiB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgIGZvcm1hdDogXCJkZXB0aDI0cGx1cy1zdGVuY2lsOFwiLFxuICAgICAgICBhdXRvR2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgbWlwTGV2ZWxDb3VudDogMVxuICAgICAgICAvLyBzYW1wbGVDb3VudDogaGFuZGxlZCBieSB0aGUgcmVuZGVyIHRhcmdldCBzeXN0ZW0uLlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uLCBza2lwQ29sb3JUZXh0dXJlID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICB0aGlzLmNvbG9yVGV4dHVyZXMuZm9yRWFjaCgoY29sb3JUZXh0dXJlLCBpKSA9PiB7XG4gICAgICBpZiAoc2tpcENvbG9yVGV4dHVyZSAmJiBpID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb2xvclRleHR1cmUuc291cmNlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5kZXB0aFN0ZW5jaWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUuc291cmNlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbG9yVGV4dHVyZS5zb3VyY2Uub2ZmKFwicmVzaXplXCIsIHRoaXMub25Tb3VyY2VSZXNpemUsIHRoaXMpO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VkQ29sb3JUZXh0dXJlcykge1xuICAgICAgdGhpcy5jb2xvclRleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgdGhpcy5kZXB0aFN0ZW5jaWxUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmU7XG4gICAgfVxuICB9XG59O1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGEgcmVuZGVyIHRhcmdldCAqL1xuX1JlbmRlclRhcmdldC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqIHRoZSB3aWR0aCBvZiB0aGUgUmVuZGVyVGFyZ2V0ICovXG4gIHdpZHRoOiAwLFxuICAvKiogdGhlIGhlaWdodCBvZiB0aGUgUmVuZGVyVGFyZ2V0ICovXG4gIGhlaWdodDogMCxcbiAgLyoqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBSZW5kZXJUYXJnZXQgKi9cbiAgcmVzb2x1dGlvbjogMSxcbiAgLyoqIGFuIGFycmF5IG9mIHRleHR1cmVzLCBvciBhIG51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGNvbG9yIHRleHR1cmVzIHRoZXJlIHNob3VsZCBiZSAqL1xuICBjb2xvclRleHR1cmVzOiAxLFxuICAvKiogc2hvdWxkIHRoaXMgcmVuZGVyIHRhcmdldCBoYXZlIGEgc3RlbmNpbCBidWZmZXI/ICovXG4gIHN0ZW5jaWw6IGZhbHNlLFxuICAvKiogc2hvdWxkIHRoaXMgcmVuZGVyIHRhcmdldCBoYXZlIGEgZGVwdGggYnVmZmVyPyAqL1xuICBkZXB0aDogZmFsc2UsXG4gIC8qKiBzaG91bGQgdGhpcyByZW5kZXIgdGFyZ2V0IGJlIGFudGlhbGlhc2VkPyAqL1xuICBhbnRpYWxpYXM6IGZhbHNlLFxuICAvLyBzYXZlIG9uIHBlcmYgYnkgZGVmYXVsdCFcbiAgLyoqIGlzIHRoaXMgYSByb290IGVsZW1lbnQsIHRydWUgaWYgdGhpcyBpcyBnbCBjb250ZXh0IG93bmVycyByZW5kZXIgdGFyZ2V0ICovXG4gIGlzUm9vdDogZmFsc2Vcbn07XG5sZXQgUmVuZGVyVGFyZ2V0ID0gX1JlbmRlclRhcmdldDtcblxuZXhwb3J0IHsgUmVuZGVyVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUYXJnZXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///279\n\n}')},581(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   d: () => (/* binding */ BufferResource)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8875);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);\n\n\n\n"use strict";\nclass BufferResource extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = "bufferResource";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("resource");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on("change", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("resource");\n    this.emit("change", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit("change", this);\n    this.buffer = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=BufferResource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBQ1k7O0FBRXJEO0FBQ0EsNkJBQTZCLDhEQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcz8yYzMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBCdWZmZXIgUmVzb3VyY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBidWZmZXIgcmVzb3VyY2VcbiAgICogQHBhcmFtIG9wdGlvbnMuYnVmZmVyIC0gVGhlIHVuZGVybHlpbmcgYnVmZmVyIHRoYXQgdGhpcyByZXNvdXJjZSBpcyB1c2luZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSBidWZmZXIgdGhpcyByZXNvdXJjZSBpcyB1c2luZy5cbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgdXNlIHRoZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBidWZmZXIgdGhpcyByZXNvdXJjZSBpcyB1c2luZy5cbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgdXNlIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJ1ZmZlciwgb2Zmc2V0LCBzaXplIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGVtaXRzIHdoZW4gdGhlIHVuZGVybHlpbmcgYnVmZmVyIGhhcyBjaGFuZ2VkIHNoYXBlIChpLmUuIHJlc2l6ZWQpXG4gICAgICogbGV0dGluZyB0aGUgcmVuZGVyZXIga25vdyB0aGF0IGl0IG5lZWRzIHRvIGRpc2NhcmQgdGhlIG9sZCBidWZmZXIgb24gdGhlIEdQVSBhbmQgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKi9cbiAgICAvKiogYSB1bmlxdWUgaWQgZm9yIHRoaXMgdW5pZm9ybSBncm91cCB1c2VkIHRocm91Z2ggdGhlIHJlbmRlcmVyICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJidWZmZXJcIik7XG4gICAgLyoqXG4gICAgICogYSByZXNvdXJjZSB0eXBlLCB1c2VkIHRvIGlkZW50aWZ5IGhvdyB0byBoYW5kbGUgaXQgd2hlbiBpdHMgaW4gYSBiaW5kIGdyb3VwIC8gc2hhZGVyIHJlc291cmNlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJidWZmZXJSZXNvdXJjZVwiO1xuICAgIC8qKlxuICAgICAqIHVzZWQgaW50ZXJuYWxseSB0byBrbm93IGlmIGEgdW5pZm9ybSBncm91cCB3YXMgdXNlZCBpbiB0aGUgbGFzdCByZW5kZXIgcGFzc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIHRoZSByZXNvdXJjZSBpZCB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGJ1aWxkIGJpbmQgZ3JvdXAga2V5c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX3Jlc291cmNlSWQgPSB1aWQoXCJyZXNvdXJjZVwiKTtcbiAgICAvKipcbiAgICAgKiBBIGNoZWVreSBoaW50IHRvIHRoZSBHTCByZW5kZXJlciB0byBsZXQgaXQga25vdyB0aGlzIGlzIGEgQnVmZmVyUmVzb3VyY2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9idWZmZXJSZXNvdXJjZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogSGFzIHRoZSBCdWZmZXIgcmVzb3VyY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmJ1ZmZlci5vbihcImNoYW5nZVwiLCB0aGlzLm9uQnVmZmVyQ2hhbmdlLCB0aGlzKTtcbiAgfVxuICBvbkJ1ZmZlckNoYW5nZSgpIHtcbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHJlc291cmNlLiBNYWtlIHN1cmUgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGlzIG5vdCB1c2VkIGFueXdoZXJlIGVsc2VcbiAgICogaWYgeW91IHdhbnQgdG8gZGVzdHJveSBpdCBhcyB3ZWxsLCBvciBjb2RlIHdpbGwgZXhwbG9kZVxuICAgKiBAcGFyYW0gZGVzdHJveUJ1ZmZlciAtIFNob3VsZCB0aGUgdW5kZXJseWluZyBidWZmZXIgYmUgZGVzdHJveWVkIGFzIHdlbGw/XG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCdWZmZXIgPSBmYWxzZSkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAoZGVzdHJveUJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclJlc291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///581\n\n}')},1161(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  f: () => (/* binding */ SharedRenderPipes),\n  i: () => (/* binding */ SharedSystems)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(8507);\n;// ./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs\n\n\n"use strict";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "customRender"\n};\n\n\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9313);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs + 1 modules\nvar PoolGroup = __webpack_require__(8655);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(8422);\n;// ./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs\n\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\n\n//# sourceMappingURL=executeInstructions.mjs.map\n\n;// ./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.u();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      PoolGroup/* BigPool */.Z.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = PoolGroup/* BigPool */.Z.get(BatchableSprite/* BatchableSprite */.K));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295,\n        offset: { x: 0, y: 0 }\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "renderGroup"\n};\n\n\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(2437);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs\nvar TextureStyle = __webpack_require__(218);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9636);\n;// ./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs\n\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\n\n//# sourceMappingURL=clearList.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 13 modules\nvar Container = __webpack_require__(266);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs\nvar multiplyColors = __webpack_require__(753);\n;// ./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs\n\n\n\n\n"use strict";\nconst tempContainer = new Container/* Container */.mc();\nconst UPDATE_BLEND_COLOR_VISIBLE = Container/* UPDATE_VISIBLE */.fR | Container/* UPDATE_COLOR */.ig | Container/* UPDATE_BLEND */.u;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = (0,multiplyColors/* multiplyColors */.j)(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & Container/* UPDATE_COLOR */.ig) {\n    container.groupColor = (0,multiplyColors/* multiplyColors */.j)(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & Container/* UPDATE_BLEND */.u) {\n    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & Container/* UPDATE_VISIBLE */.fR) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\n\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n\n;// ./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs\n\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\n\n//# sourceMappingURL=validateRenderables.mjs.map\n\n;// ./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst RenderGroupSystem_tempMatrix = new Matrix/* Matrix */.u();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const originalLocalTransform = RenderGroupSystem_tempMatrix;\n    if (transform) {\n      originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.textureNeedsUpdate)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool/* TexturePool */.W.returnTexture(renderGroup.texture, true);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";\n        const texture = TexturePool/* TexturePool */.W.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        texture._source.style = new TextureStyle/* TextureStyle */.n({ scaleMode });\n        renderGroup.texture = texture;\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds/* Bounds */.c());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool/* TexturePool */.W.returnTexture(renderGroup.texture, true);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "renderGroup"\n};\n\n\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs\n\n\n\n"use strict";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite/* BatchableSprite */.K();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "sprite"\n};\n\n\n//# sourceMappingURL=SpritePipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/global/globalHooks.mjs\nvar globalHooks = __webpack_require__(7073);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(7547);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs + 5 modules\nvar DefaultBatcher = __webpack_require__(3721);\n;// ./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs\n\n\n\n\n"use strict";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.U.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher/* DefaultBatcher */.J({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === "startBatch") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "batch"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nExtensions/* extensions */.XO.handleByMap(Extensions/* ExtensionType */.Ag.Batcher, BatcherPipe._availableBatchers);\nExtensions/* extensions */.XO.add(DefaultBatcher/* DefaultBatcher */.J);\n\n\n//# sourceMappingURL=BatcherPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(9049);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs + 6 modules\nvar GlProgram = __webpack_require__(9113);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs + 6 modules\nvar GpuProgram = __webpack_require__(3012);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5811);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(1196);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/Filter.mjs\nvar Filter = __webpack_require__(6554);\n;// ./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs\nvar fragment = "in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n";\n\n\n//# sourceMappingURL=mask.frag.mjs.map\n\n;// ./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs\nvar vertex = "in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n";\n\n\n//# sourceMappingURL=mask.vert.mjs.map\n\n;// ./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs\nvar source = "struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n";\n\n\n//# sourceMappingURL=mask.wgsl.mjs.map\n\n;// ./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass MaskFilter extends Filter/* Filter */.d {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix/* TextureMatrix */.N(sprite.texture);\n    const filterUniforms = new UniformGroup/* UniformGroup */.k({\n      uFilterMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },\n      uAlpha: { value: 1, type: "f32" },\n      uInverse: { value: options.inverse ? 1 : 0, type: "f32" }\n    });\n    const gpuProgram = GpuProgram/* GpuProgram */.B.from({\n      vertex: {\n        source: source,\n        entryPoint: "mainVertex"\n      },\n      fragment: {\n        source: source,\n        entryPoint: "mainFragment"\n      }\n    });\n    const glProgram = GlProgram/* GlProgram */.M.from({\n      vertex: vertex,\n      fragment: fragment,\n      name: "mask-filter"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\n\n//# sourceMappingURL=MaskFilter.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(9443);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(6844);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 1 modules\nvar Texture = __webpack_require__(5589);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5099);\n;// ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.c();\nclass AlphaMaskEffect extends FilterEffect/* FilterEffect */.a {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite/* Sprite */.k(Texture/* Texture */.g.EMPTY),\n      inverse: false,\n      resolution: "inherit",\n      antialias: "inherit"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "pushMaskBegin",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "pushMaskEnd",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "popMaskEnd",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === "pushMaskBegin") {\n      const filterEffect = PoolGroup/* BigPool */.Z.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = (0,getGlobalBounds/* getGlobalBounds */.f)(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool/* TexturePool */.W.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === "pushMaskEnd") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === types/* RendererType */.W.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: "filter",\n        action: "pushFilter",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === "popMaskEnd") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool/* TexturePool */.W.returnTexture(maskData.filterTexture);\n      }\n      PoolGroup/* BigPool */.Z.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "alphaMask"\n};\n\n\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n\n;// ./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs\n\n\n"use strict";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: "colorMask",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: "colorMask",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "colorMask"\n};\n\n\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(1257);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(1957);\n;// ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs\n\n\n\n\n"use strict";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "pushMaskBegin",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "pushMaskEnd",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "popMaskBegin",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "popMaskEnd",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === "pushMaskBegin") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === "pushMaskEnd") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === "popMaskBegin") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, gl_const/* CLEAR */.u.STENCIL);\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === "popMaskEnd") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "stencilMask"\n};\n\n\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(2577);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(268);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs\n\n\n\n\n"use strict";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color/* Color */.Q(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    const incoming = Color/* Color */.Q.shared.setValue(value);\n    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {\n      (0,warn/* warn */.R)(\n        "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."\n      );\n    }\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "background",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\n\n//# sourceMappingURL=BackgroundSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs\nvar RenderGroup = __webpack_require__(3284);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs\n\n\n\n\n\n"use strict";\nconst BLEND_MODE_FILTERS = {};\nExtensions/* extensions */.XO.handle(Extensions/* ExtensionType */.Ag.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error("BlendMode extension must have a name property");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._blendModeStack = [];\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = "normal";\n    this._isAdvanced = false;\n  }\n  /**\n   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n   * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n   * @param blendMode - The blend mode to activate.\n   * @param instructionSet - The instruction set being built.\n   */\n  pushBlendMode(renderable, blendMode, instructionSet) {\n    this._blendModeStack.push(blendMode);\n    this.setBlendMode(renderable, blendMode, instructionSet);\n  }\n  /**\n   * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  popBlendMode(instructionSet) {\n    this._blendModeStack.pop();\n    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";\n    this.setBlendMode(null, blendMode, instructionSet);\n  }\n  /**\n   * Ensure a blend mode switch is added to the instruction set when the mode changes.\n   * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n   * rendered within a single filter pass.\n   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n   * @param blendMode - The target blend mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    const isRenderGroup = renderable instanceof RenderGroup/* RenderGroup */.m;\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced && renderable && !isRenderGroup) {\n        this._renderableList?.push(renderable);\n      }\n      return;\n    }\n    if (this._isAdvanced)\n      this._endAdvancedBlendMode(instructionSet);\n    this._activeBlendMode = blendMode;\n    if (!renderable)\n      return;\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced)\n      this._beginAdvancedBlendMode(renderable, instructionSet);\n  }\n  _beginAdvancedBlendMode(renderable, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      (0,warn/* warn */.R)(`Unable to assign BlendMode: \'${blendMode}\'. You may want to include: import \'pixi.js/advanced-blend-modes\'`);\n      return;\n    }\n    const filterEffect = this._ensureFilterEffect(blendMode);\n    const isRenderGroup = renderable instanceof RenderGroup/* RenderGroup */.m;\n    const instruction = {\n      renderPipeId: "filter",\n      action: "pushFilter",\n      filterEffect,\n      renderables: isRenderGroup ? null : [renderable],\n      container: isRenderGroup ? renderable.root : null,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _ensureFilterEffect(blendMode) {\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect/* FilterEffect */.a();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    return filterEffect;\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._isAdvanced = false;\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (!this._isAdvanced)\n      return;\n    this._endAdvancedBlendMode(instructionSet);\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "blendMode"\n};\n\n\n//# sourceMappingURL=BlendModePipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(1761);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs\n\n\n\n\n\n"use strict";\nconst imageTypes = {\n  png: "image/png",\n  jpg: "image/jpeg",\n  webp: "image/webp"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container/* Container */.mc || options instanceof Texture/* Texture */.g) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an IImage from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated IImage\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: \'webp\',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: \'#ff0000\',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from(\'myTexture.png\');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ImageLike} For the image interface\n   * @category rendering\n   */\n  async image(options) {\n    const image = adapter/* DOMAdapter */.e.get().createImage();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: \'webp\',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn\'t support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error("ICanvas.toBlob failed!"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: \'#ff0000\'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from(\'myTexture.png\');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture/* Texture */.g) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture/* Texture */.g ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container/* Container */.mc) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: \'#ff0000\'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture/* Texture */.g)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as \'image.png\'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: \'screenshot.png\'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: \'region.png\',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: \'hd-screenshot.png\',\n   *     resolution: 2,\n   *     clearColor: \'#ff0000\'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: \'smooth.png\',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement("a");\n    link.download = options.filename ?? "image.png";\n    link.href = canvas.toDataURL("image/png");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what\'s happening in the renderer.\n   * The image will be displayed in the browser\'s console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      "font-size: 1px;",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      "background-size: contain;"\n    ].join(" ");\n    console.log("%c ", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "extract"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = \'webp\';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: "png",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\n\n//# sourceMappingURL=ExtractSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(9252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(7269);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs\nvar RenderTexture = __webpack_require__(4167);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRect = new Rectangle/* Rectangle */.M();\nconst GenerateTextureSystem_tempBounds = new Bounds/* Bounds */.c();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill(\'red\')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: \'#ff0000\',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container/* Container */.mc) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color/* Color */.Q.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || (0,getLocalBounds/* getLocalBounds */.n)(container, GenerateTextureSystem_tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture/* RenderTexture */.Y.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix/* Matrix */.u.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "textureGenerator"\n};\n\n\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(5101);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(2760);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(3513);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix/* Matrix */.u(),\n      worldColor: 4294967295,\n      offset: new Point/* Point */.b()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup/* BindGroup */.T();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === types/* RendererType */.W.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup/* UniformGroup */.k({\n      uProjectionMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      uWorldTransformMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },\n      uResolution: { value: [0, 0], type: "vec2<f32>" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n    this._globalUniformDataStack.length = 0;\n    this._uniformsPool.length = 0;\n    this._activeUniforms.length = 0;\n    this._bindGroupPool.length = 0;\n    this._activeBindGroups.length = 0;\n    this._currentGlobalUniformData = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "globalUniforms"\n};\n\n\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(7309);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs\n\n\n\n"use strict";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker/* Ticker */.R.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker/* Ticker */.R.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "scheduler",\n  priority: 0\n};\n\n\n//# sourceMappingURL=SchedulerSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/const.mjs\nvar utils_const = __webpack_require__(2571);\n;// ./node_modules/pixi.js/lib/utils/sayHello.mjs\n\n\n\n"use strict";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (adapter/* DOMAdapter */.e.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${utils_const/* VERSION */.xv} (${type}) http://www.pixijs.com/\n\n`,\n      "background: #E72264; padding:5px 0;",\n      "background: #6CA2EA; padding:5px 0;",\n      "background: #B5D33D; padding:5px 0;",\n      "background: #FED23F; padding:5px 0;",\n      "color: #FFFFFF; background: #E72264; padding:5px 0;",\n      "color: #E72264; background: #FFFFFF; padding:5px 0;"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${utils_const/* VERSION */.xv} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\n\n//# sourceMappingURL=sayHello.mjs.map\n\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs\n\n\n\n\n"use strict";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === types/* RendererType */.W.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "hello",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\n\n//# sourceMappingURL=HelloSystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/utils/data/clean.mjs\n\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\n\n//# sourceMappingURL=clean.mjs.map\n\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs\n\n\n\n"use strict";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once("destroyed", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven\'t been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off("destroyed", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it\'s destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off("destroyed", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "renderableGC",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\n\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs\n\n\n"use strict";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "textureGC"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\n\n//# sourceMappingURL=TextureGCSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(4670);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs\nvar RenderTarget = __webpack_require__(279);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs\nvar getCanvasTexture = __webpack_require__(8725);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs\n\n\n\n\n\n\n\n"use strict";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @type {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      (0,deprecation/* deprecation */.t6)(deprecation/* v8_0_0 */.lj, "ViewSystem.view has been renamed to ViewSystem.canvas");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle/* Rectangle */.M(0, 0, options.width, options.height);\n    this.canvas = options.canvas || adapter/* DOMAdapter */.e.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = (0,getCanvasTexture/* getCanvasTexture */.c)(this.canvas, options);\n    this.renderTarget = new RenderTarget/* RenderTarget */.O({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or "false".\n   * @example\n   * viewSystem.destroy();\n   * viewSystem.destroy(true);\n   * viewSystem.destroy({ removeView: true });\n   */\n  destroy(options = false) {\n    const removeView = typeof options === "boolean" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n    this.texture.destroy();\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "view",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\n\n//# sourceMappingURL=ViewSystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  globalHooks/* RendererInitHook */.d,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\n\n//# sourceMappingURL=SharedSystems.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxVQUFVO0FBQ1osRUFBRSxpQkFBaUI7QUFDbkIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsYUFBYTtBQUNmLEVBQUUsbUNBQWdCO0FBQ2xCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0EsRUFBRSxhQUFhO0FBQ2YsRUFBRSxXQUFXO0FBQ2IsRUFBRSxVQUFVO0FBQ1osRUFBRSxlQUFlO0FBQ2pCLEVBQUUsYUFBYTtBQUNmLEVBQUUsZUFBZTtBQUNqQixFQUFFLGFBQWE7QUFDZixFQUFFLGdCQUFnQjtBQUNsQjs7QUFFNEM7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL0N1c3RvbVJlbmRlclBpcGUubWpzP2IyZWMiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9leGVjdXRlSW5zdHJ1Y3Rpb25zLm1qcz8yYTRjIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXBQaXBlLm1qcz8wMDE1Iiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2xlYXJMaXN0Lm1qcz85MjRiIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLm1qcz9lMmJmIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvdmFsaWRhdGVSZW5kZXJhYmxlcy5tanM/OGVmMiIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwU3lzdGVtLm1qcz8xOTM3Iiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUvU3ByaXRlUGlwZS5tanM/MGNhMCIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXJQaXBlLm1qcz82ZGY1Iiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL21hc2svbWFzay5mcmFnLm1qcz8zYTkxIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL21hc2svbWFzay52ZXJ0Lm1qcz9jMDhlIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL21hc2svbWFzay53Z3NsLm1qcz9hOWIzIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL21hc2svTWFza0ZpbHRlci5tanM/OWI3OSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svYWxwaGEvQWxwaGFNYXNrUGlwZS5tanM/ODhlMSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svY29sb3IvQ29sb3JNYXNrUGlwZS5tanM/N2FkOSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFza1BpcGUubWpzPzZmN2YiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5tanM/Y2UxMSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYmxlbmRNb2Rlcy9CbGVuZE1vZGVQaXBlLm1qcz81ZjY4Iiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9leHRyYWN0L0V4dHJhY3RTeXN0ZW0ubWpzPzk1ZjUiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2V4dHJhY3QvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcz8xZjhjIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9yZW5kZXJUYXJnZXQvR2xvYmFsVW5pZm9ybVN5c3RlbS5tanM/YzdkMSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvU2NoZWR1bGVyU3lzdGVtLm1qcz9lNWZiIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9zYXlIZWxsby5tanM/MjkyNSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhcnR1cC9IZWxsb1N5c3RlbS5tanM/YTEzNCIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvZGF0YS9jbGVhbi5tanM/NzhjZCIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9SZW5kZXJhYmxlR0NTeXN0ZW0ubWpzPzdlMzgiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZUdDU3lzdGVtLm1qcz84MDlkIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC92aWV3L1ZpZXdTeXN0ZW0ubWpzPzdmNTQiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9TaGFyZWRTeXN0ZW1zLm1qcz9jNTIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDdXN0b21SZW5kZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoKSB7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUoKSB7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGNvbnRhaW5lcik7XG4gIH1cbiAgZXhlY3V0ZShjb250YWluZXIpIHtcbiAgICBpZiAoIWNvbnRhaW5lci5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgY29udGFpbmVyLnJlbmRlcih0aGlzLl9yZW5kZXJlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkN1c3RvbVJlbmRlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImN1c3RvbVJlbmRlclwiXG59O1xuXG5leHBvcnQgeyBDdXN0b21SZW5kZXJQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXN0b21SZW5kZXJQaXBlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXhlY3V0ZUluc3RydWN0aW9ucyhyZW5kZXJHcm91cCwgcmVuZGVyZXIpIHtcbiAgY29uc3QgaW5zdHJ1Y3Rpb25TZXQgPSByZW5kZXJHcm91cC5pbnN0cnVjdGlvblNldDtcbiAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25TZXQuaW5zdHJ1Y3Rpb25zO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uU2V0Lmluc3RydWN0aW9uU2l6ZTsgaSsrKSB7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgcmVuZGVyZXJbaW5zdHJ1Y3Rpb24ucmVuZGVyUGlwZUlkXS5leGVjdXRlKGluc3RydWN0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgeyBleGVjdXRlSW5zdHJ1Y3Rpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRlSW5zdHJ1Y3Rpb25zLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi4vc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanMnO1xuaW1wb3J0IHsgZXhlY3V0ZUluc3RydWN0aW9ucyB9IGZyb20gJy4vdXRpbHMvZXhlY3V0ZUluc3RydWN0aW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBSZW5kZXJHcm91cFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgYWRkUmVuZGVyR3JvdXAocmVuZGVyR3JvdXAsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgaWYgKHJlbmRlckdyb3VwLmlzQ2FjaGVkQXNUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9hZGRSZW5kZXJhYmxlQ2FjaGVBc1RleHR1cmUocmVuZGVyR3JvdXAsIGluc3RydWN0aW9uU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkUmVuZGVyYWJsZURpcmVjdChyZW5kZXJHcm91cCwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKHJlbmRlckdyb3VwKSB7XG4gICAgaWYgKCFyZW5kZXJHcm91cC5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlbmRlckdyb3VwLmlzQ2FjaGVkQXNUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9leGVjdXRlQ2FjaGVBc1RleHR1cmUocmVuZGVyR3JvdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leGVjdXRlRGlyZWN0KHJlbmRlckdyb3VwKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgX2FkZFJlbmRlcmFibGVEaXJlY3QocmVuZGVyR3JvdXAsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGlmIChyZW5kZXJHcm91cC5fYmF0Y2hhYmxlUmVuZGVyR3JvdXApIHtcbiAgICAgIEJpZ1Bvb2wucmV0dXJuKHJlbmRlckdyb3VwLl9iYXRjaGFibGVSZW5kZXJHcm91cCk7XG4gICAgICByZW5kZXJHcm91cC5fYmF0Y2hhYmxlUmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIH1cbiAgICBpbnN0cnVjdGlvblNldC5hZGQocmVuZGVyR3JvdXApO1xuICB9XG4gIF9hZGRSZW5kZXJhYmxlQ2FjaGVBc1RleHR1cmUocmVuZGVyR3JvdXAsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgYmF0Y2hhYmxlUmVuZGVyR3JvdXAgPSByZW5kZXJHcm91cC5fYmF0Y2hhYmxlUmVuZGVyR3JvdXAgPz8gKHJlbmRlckdyb3VwLl9iYXRjaGFibGVSZW5kZXJHcm91cCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZVNwcml0ZSkpO1xuICAgIGJhdGNoYWJsZVJlbmRlckdyb3VwLnJlbmRlcmFibGUgPSByZW5kZXJHcm91cC5yb290O1xuICAgIGJhdGNoYWJsZVJlbmRlckdyb3VwLnRyYW5zZm9ybSA9IHJlbmRlckdyb3VwLnJvb3QucmVsYXRpdmVHcm91cFRyYW5zZm9ybTtcbiAgICBiYXRjaGFibGVSZW5kZXJHcm91cC50ZXh0dXJlID0gcmVuZGVyR3JvdXAudGV4dHVyZTtcbiAgICBiYXRjaGFibGVSZW5kZXJHcm91cC5ib3VuZHMgPSByZW5kZXJHcm91cC5fdGV4dHVyZUJvdW5kcztcbiAgICBpbnN0cnVjdGlvblNldC5hZGQocmVuZGVyR3JvdXApO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJsZW5kTW9kZS5wdXNoQmxlbmRNb2RlKHJlbmRlckdyb3VwLCByZW5kZXJHcm91cC5yb290Lmdyb3VwQmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVSZW5kZXJHcm91cCwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJsZW5kTW9kZS5wb3BCbGVuZE1vZGUoaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIF9leGVjdXRlQ2FjaGVBc1RleHR1cmUocmVuZGVyR3JvdXApIHtcbiAgICBpZiAocmVuZGVyR3JvdXAudGV4dHVyZU5lZWRzVXBkYXRlKSB7XG4gICAgICByZW5kZXJHcm91cC50ZXh0dXJlTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtTWF0cml4ID0gdGVtcE1hdHJpeC5pZGVudGl0eSgpLnRyYW5zbGF0ZShcbiAgICAgICAgLXJlbmRlckdyb3VwLl90ZXh0dXJlQm91bmRzLngsXG4gICAgICAgIC1yZW5kZXJHcm91cC5fdGV4dHVyZUJvdW5kcy55XG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnB1c2gocmVuZGVyR3JvdXAudGV4dHVyZSwgdHJ1ZSwgbnVsbCwgcmVuZGVyR3JvdXAudGV4dHVyZS5mcmFtZSk7XG4gICAgICB0aGlzLl9yZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5wdXNoKHtcbiAgICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXgsXG4gICAgICAgIHdvcmxkQ29sb3I6IDQyOTQ5NjcyOTUsXG4gICAgICAgIG9mZnNldDogeyB4OiAwLCB5OiAwIH1cbiAgICAgIH0pO1xuICAgICAgZXhlY3V0ZUluc3RydWN0aW9ucyhyZW5kZXJHcm91cCwgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclRhcmdldC5wb3AoKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnBvcCgpO1xuICAgIH1cbiAgICByZW5kZXJHcm91cC5fYmF0Y2hhYmxlUmVuZGVyR3JvdXAuX2JhdGNoZXIudXBkYXRlRWxlbWVudChyZW5kZXJHcm91cC5fYmF0Y2hhYmxlUmVuZGVyR3JvdXApO1xuICAgIHJlbmRlckdyb3VwLl9iYXRjaGFibGVSZW5kZXJHcm91cC5fYmF0Y2hlci5nZW9tZXRyeS5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICB9XG4gIF9leGVjdXRlRGlyZWN0KHJlbmRlckdyb3VwKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICB3b3JsZFRyYW5zZm9ybU1hdHJpeDogcmVuZGVyR3JvdXAuaW52ZXJzZVBhcmVudFRleHR1cmVUcmFuc2Zvcm0sXG4gICAgICB3b3JsZENvbG9yOiByZW5kZXJHcm91cC53b3JsZENvbG9yQWxwaGFcbiAgICB9KTtcbiAgICBleGVjdXRlSW5zdHJ1Y3Rpb25zKHJlbmRlckdyb3VwLCB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucG9wKCk7XG4gIH1cbn1cblJlbmRlckdyb3VwUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwicmVuZGVyR3JvdXBcIlxufTtcblxuZXhwb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJHcm91cFBpcGUubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjbGVhckxpc3QobGlzdCwgaW5kZXgpIHtcbiAgaW5kZXggfHwgKGluZGV4ID0gMCk7XG4gIGZvciAobGV0IGogPSBpbmRleDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAobGlzdFtqXSkge1xuICAgICAgbGlzdFtqXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBjbGVhckxpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsZWFyTGlzdC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb250YWluZXIsIFVQREFURV9WSVNJQkxFLCBVUERBVEVfQ09MT1IsIFVQREFURV9CTEVORCB9IGZyb20gJy4uL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgY2xlYXJMaXN0IH0gZnJvbSAnLi9jbGVhckxpc3QubWpzJztcbmltcG9ydCB7IG11bHRpcGx5Q29sb3JzIH0gZnJvbSAnLi9tdWx0aXBseUNvbG9ycy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBDb250YWluZXIgPSBuZXcgQ29udGFpbmVyKCk7XG5jb25zdCBVUERBVEVfQkxFTkRfQ09MT1JfVklTSUJMRSA9IFVQREFURV9WSVNJQkxFIHwgVVBEQVRFX0NPTE9SIHwgVVBEQVRFX0JMRU5EO1xuZnVuY3Rpb24gdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zKHJlbmRlckdyb3VwLCB1cGRhdGVDaGlsZFJlbmRlckdyb3VwcyA9IGZhbHNlKSB7XG4gIHVwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3JtKHJlbmRlckdyb3VwKTtcbiAgY29uc3QgY2hpbGRyZW5Ub1VwZGF0ZSA9IHJlbmRlckdyb3VwLmNoaWxkcmVuVG9VcGRhdGU7XG4gIGNvbnN0IHVwZGF0ZVRpY2sgPSByZW5kZXJHcm91cC51cGRhdGVUaWNrKys7XG4gIGZvciAoY29uc3QgaiBpbiBjaGlsZHJlblRvVXBkYXRlKSB7XG4gICAgY29uc3QgcmVuZGVyR3JvdXBEZXB0aCA9IE51bWJlcihqKTtcbiAgICBjb25zdCBjaGlsZHJlbkF0RGVwdGggPSBjaGlsZHJlblRvVXBkYXRlW2pdO1xuICAgIGNvbnN0IGxpc3QgPSBjaGlsZHJlbkF0RGVwdGgubGlzdDtcbiAgICBjb25zdCBpbmRleCA9IGNoaWxkcmVuQXREZXB0aC5pbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbGlzdFtpXTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnRSZW5kZXJHcm91cCA9PT0gcmVuZGVyR3JvdXAgJiYgY2hpbGQucmVsYXRpdmVSZW5kZXJHcm91cERlcHRoID09PSByZW5kZXJHcm91cERlcHRoKSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zZm9ybUFuZENoaWxkcmVuKGNoaWxkLCB1cGRhdGVUaWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJMaXN0KGxpc3QsIGluZGV4KTtcbiAgICBjaGlsZHJlbkF0RGVwdGguaW5kZXggPSAwO1xuICB9XG4gIGlmICh1cGRhdGVDaGlsZFJlbmRlckdyb3Vwcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyR3JvdXAucmVuZGVyR3JvdXBDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zKHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW5baV0sIHVwZGF0ZUNoaWxkUmVuZGVyR3JvdXBzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3JtKHJlbmRlckdyb3VwKSB7XG4gIGNvbnN0IHJvb3QgPSByZW5kZXJHcm91cC5yb290O1xuICBsZXQgd29ybGRBbHBoYTtcbiAgaWYgKHJlbmRlckdyb3VwLnJlbmRlckdyb3VwUGFyZW50KSB7XG4gICAgY29uc3QgcmVuZGVyR3JvdXBQYXJlbnQgPSByZW5kZXJHcm91cC5yZW5kZXJHcm91cFBhcmVudDtcbiAgICByZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybS5hcHBlbmRGcm9tKFxuICAgICAgcm9vdC5yZWxhdGl2ZUdyb3VwVHJhbnNmb3JtLFxuICAgICAgcmVuZGVyR3JvdXBQYXJlbnQud29ybGRUcmFuc2Zvcm1cbiAgICApO1xuICAgIHJlbmRlckdyb3VwLndvcmxkQ29sb3IgPSBtdWx0aXBseUNvbG9ycyhcbiAgICAgIHJvb3QuZ3JvdXBDb2xvcixcbiAgICAgIHJlbmRlckdyb3VwUGFyZW50LndvcmxkQ29sb3JcbiAgICApO1xuICAgIHdvcmxkQWxwaGEgPSByb290Lmdyb3VwQWxwaGEgKiByZW5kZXJHcm91cFBhcmVudC53b3JsZEFscGhhO1xuICB9IGVsc2Uge1xuICAgIHJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtLmNvcHlGcm9tKHJvb3QubG9jYWxUcmFuc2Zvcm0pO1xuICAgIHJlbmRlckdyb3VwLndvcmxkQ29sb3IgPSByb290LmxvY2FsQ29sb3I7XG4gICAgd29ybGRBbHBoYSA9IHJvb3QubG9jYWxBbHBoYTtcbiAgfVxuICB3b3JsZEFscGhhID0gd29ybGRBbHBoYSA8IDAgPyAwIDogd29ybGRBbHBoYSA+IDEgPyAxIDogd29ybGRBbHBoYTtcbiAgcmVuZGVyR3JvdXAud29ybGRBbHBoYSA9IHdvcmxkQWxwaGE7XG4gIHJlbmRlckdyb3VwLndvcmxkQ29sb3JBbHBoYSA9IHJlbmRlckdyb3VwLndvcmxkQ29sb3IgKyAoKHdvcmxkQWxwaGEgKiAyNTUgfCAwKSA8PCAyNCk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbihjb250YWluZXIsIHVwZGF0ZVRpY2ssIHVwZGF0ZUZsYWdzKSB7XG4gIGlmICh1cGRhdGVUaWNrID09PSBjb250YWluZXIudXBkYXRlVGljaylcbiAgICByZXR1cm47XG4gIGNvbnRhaW5lci51cGRhdGVUaWNrID0gdXBkYXRlVGljaztcbiAgY29udGFpbmVyLmRpZENoYW5nZSA9IGZhbHNlO1xuICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IGNvbnRhaW5lci5sb2NhbFRyYW5zZm9ybTtcbiAgY29udGFpbmVyLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIXBhcmVudC5yZW5kZXJHcm91cCkge1xuICAgIHVwZGF0ZUZsYWdzIHw9IGNvbnRhaW5lci5fdXBkYXRlRmxhZ3M7XG4gICAgY29udGFpbmVyLnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uYXBwZW5kRnJvbShcbiAgICAgIGxvY2FsVHJhbnNmb3JtLFxuICAgICAgcGFyZW50LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm1cbiAgICApO1xuICAgIGlmICh1cGRhdGVGbGFncyAmIFVQREFURV9CTEVORF9DT0xPUl9WSVNJQkxFKSB7XG4gICAgICB1cGRhdGVDb2xvckJsZW5kVmlzaWJpbGl0eShjb250YWluZXIsIHBhcmVudCwgdXBkYXRlRmxhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVGbGFncyA9IGNvbnRhaW5lci5fdXBkYXRlRmxhZ3M7XG4gICAgY29udGFpbmVyLnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uY29weUZyb20obG9jYWxUcmFuc2Zvcm0pO1xuICAgIGlmICh1cGRhdGVGbGFncyAmIFVQREFURV9CTEVORF9DT0xPUl9WSVNJQkxFKSB7XG4gICAgICB1cGRhdGVDb2xvckJsZW5kVmlzaWJpbGl0eShjb250YWluZXIsIHRlbXBDb250YWluZXIsIHVwZGF0ZUZsYWdzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFjb250YWluZXIucmVuZGVyR3JvdXApIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlVHJhbnNmb3JtQW5kQ2hpbGRyZW4oY2hpbGRyZW5baV0sIHVwZGF0ZVRpY2ssIHVwZGF0ZUZsYWdzKTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyR3JvdXAgPSBjb250YWluZXIucGFyZW50UmVuZGVyR3JvdXA7XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IGNvbnRhaW5lcjtcbiAgICBpZiAocmVuZGVyYWJsZS5yZW5kZXJQaXBlSWQgJiYgIXJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSkge1xuICAgICAgcmVuZGVyR3JvdXAudXBkYXRlUmVuZGVyYWJsZShyZW5kZXJhYmxlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9yQmxlbmRWaXNpYmlsaXR5KGNvbnRhaW5lciwgcGFyZW50LCB1cGRhdGVGbGFncykge1xuICBpZiAodXBkYXRlRmxhZ3MgJiBVUERBVEVfQ09MT1IpIHtcbiAgICBjb250YWluZXIuZ3JvdXBDb2xvciA9IG11bHRpcGx5Q29sb3JzKFxuICAgICAgY29udGFpbmVyLmxvY2FsQ29sb3IsXG4gICAgICBwYXJlbnQuZ3JvdXBDb2xvclxuICAgICk7XG4gICAgbGV0IGdyb3VwQWxwaGEgPSBjb250YWluZXIubG9jYWxBbHBoYSAqIHBhcmVudC5ncm91cEFscGhhO1xuICAgIGdyb3VwQWxwaGEgPSBncm91cEFscGhhIDwgMCA/IDAgOiBncm91cEFscGhhID4gMSA/IDEgOiBncm91cEFscGhhO1xuICAgIGNvbnRhaW5lci5ncm91cEFscGhhID0gZ3JvdXBBbHBoYTtcbiAgICBjb250YWluZXIuZ3JvdXBDb2xvckFscGhhID0gY29udGFpbmVyLmdyb3VwQ29sb3IgKyAoKGdyb3VwQWxwaGEgKiAyNTUgfCAwKSA8PCAyNCk7XG4gIH1cbiAgaWYgKHVwZGF0ZUZsYWdzICYgVVBEQVRFX0JMRU5EKSB7XG4gICAgY29udGFpbmVyLmdyb3VwQmxlbmRNb2RlID0gY29udGFpbmVyLmxvY2FsQmxlbmRNb2RlID09PSBcImluaGVyaXRcIiA/IHBhcmVudC5ncm91cEJsZW5kTW9kZSA6IGNvbnRhaW5lci5sb2NhbEJsZW5kTW9kZTtcbiAgfVxuICBpZiAodXBkYXRlRmxhZ3MgJiBVUERBVEVfVklTSUJMRSkge1xuICAgIGNvbnRhaW5lci5nbG9iYWxEaXNwbGF5U3RhdHVzID0gY29udGFpbmVyLmxvY2FsRGlzcGxheVN0YXR1cyAmIHBhcmVudC5nbG9iYWxEaXNwbGF5U3RhdHVzO1xuICB9XG4gIGNvbnRhaW5lci5fdXBkYXRlRmxhZ3MgPSAwO1xufVxuXG5leHBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybSwgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLCB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJhYmxlcyhyZW5kZXJHcm91cCwgcmVuZGVyUGlwZXMpIHtcbiAgY29uc3QgeyBsaXN0IH0gPSByZW5kZXJHcm91cC5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGU7XG4gIGxldCByZWJ1aWxkUmVxdWlyZWQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJHcm91cC5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUuaW5kZXg7IGkrKykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGxpc3RbaV07XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IGNvbnRhaW5lcjtcbiAgICBjb25zdCBwaXBlID0gcmVuZGVyUGlwZXNbcmVuZGVyYWJsZS5yZW5kZXJQaXBlSWRdO1xuICAgIHJlYnVpbGRSZXF1aXJlZCA9IHBpcGUudmFsaWRhdGVSZW5kZXJhYmxlKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYnVpbGRSZXF1aXJlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHJlYnVpbGRSZXF1aXJlZDtcbiAgcmV0dXJuIHJlYnVpbGRSZXF1aXJlZDtcbn1cblxuZXhwb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGVSZW5kZXJhYmxlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFRleHR1cmVTdHlsZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVN0eWxlLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuL2JvdW5kcy9Cb3VuZHMubWpzJztcbmltcG9ydCB7IGNsZWFyTGlzdCB9IGZyb20gJy4vdXRpbHMvY2xlYXJMaXN0Lm1qcyc7XG5pbXBvcnQgeyBleGVjdXRlSW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi91dGlscy9leGVjdXRlSW5zdHJ1Y3Rpb25zLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybXMgfSBmcm9tICcuL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9IGZyb20gJy4vdXRpbHMvdmFsaWRhdGVSZW5kZXJhYmxlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBSZW5kZXJHcm91cFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICByZW5kZXIoeyBjb250YWluZXIsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudDtcbiAgICBjb25zdCByZW5kZXJHcm91cFBhcmVudCA9IGNvbnRhaW5lci5yZW5kZXJHcm91cC5yZW5kZXJHcm91cFBhcmVudDtcbiAgICBjb250YWluZXIucGFyZW50ID0gbnVsbDtcbiAgICBjb250YWluZXIucmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQgPSBudWxsO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3Qgb3JpZ2luYWxMb2NhbFRyYW5zZm9ybSA9IHRlbXBNYXRyaXg7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgb3JpZ2luYWxMb2NhbFRyYW5zZm9ybS5jb3B5RnJvbShjb250YWluZXIucmVuZGVyR3JvdXAubG9jYWxUcmFuc2Zvcm0pO1xuICAgICAgY29udGFpbmVyLnJlbmRlckdyb3VwLmxvY2FsVHJhbnNmb3JtLmNvcHlGcm9tKHRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclBpcGVzID0gcmVuZGVyZXIucmVuZGVyUGlwZXM7XG4gICAgdGhpcy5fdXBkYXRlQ2FjaGVkUmVuZGVyR3JvdXBzKGNvbnRhaW5lci5yZW5kZXJHcm91cCwgbnVsbCk7XG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyR3JvdXBzKGNvbnRhaW5lci5yZW5kZXJHcm91cCk7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuc3RhcnQoe1xuICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXg6IHRyYW5zZm9ybSA/IGNvbnRhaW5lci5yZW5kZXJHcm91cC5sb2NhbFRyYW5zZm9ybSA6IGNvbnRhaW5lci5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSxcbiAgICAgIHdvcmxkQ29sb3I6IGNvbnRhaW5lci5yZW5kZXJHcm91cC53b3JsZENvbG9yQWxwaGFcbiAgICB9KTtcbiAgICBleGVjdXRlSW5zdHJ1Y3Rpb25zKGNvbnRhaW5lci5yZW5kZXJHcm91cCwgcmVuZGVyUGlwZXMpO1xuICAgIGlmIChyZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2gpIHtcbiAgICAgIHJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaC5yZW5kZXJFbmQoKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgY29udGFpbmVyLnJlbmRlckdyb3VwLmxvY2FsVHJhbnNmb3JtLmNvcHlGcm9tKG9yaWdpbmFsTG9jYWxUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBjb250YWluZXIucGFyZW50ID0gcGFyZW50O1xuICAgIGNvbnRhaW5lci5yZW5kZXJHcm91cC5yZW5kZXJHcm91cFBhcmVudCA9IHJlbmRlckdyb3VwUGFyZW50O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIF91cGRhdGVDYWNoZWRSZW5kZXJHcm91cHMocmVuZGVyR3JvdXAsIGNsb3Nlc3RDYWNoZUFzVGV4dHVyZSkge1xuICAgIHJlbmRlckdyb3VwLl9wYXJlbnRDYWNoZUFzVGV4dHVyZVJlbmRlckdyb3VwID0gY2xvc2VzdENhY2hlQXNUZXh0dXJlO1xuICAgIGlmIChyZW5kZXJHcm91cC5pc0NhY2hlZEFzVGV4dHVyZSkge1xuICAgICAgaWYgKCFyZW5kZXJHcm91cC50ZXh0dXJlTmVlZHNVcGRhdGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNsb3Nlc3RDYWNoZUFzVGV4dHVyZSA9IHJlbmRlckdyb3VwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVuZGVyR3JvdXAucmVuZGVyR3JvdXBDaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVkUmVuZGVyR3JvdXBzKHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW5baV0sIGNsb3Nlc3RDYWNoZUFzVGV4dHVyZSk7XG4gICAgfVxuICAgIHJlbmRlckdyb3VwLmludmFsaWRhdGVNYXRyaWNlcygpO1xuICAgIGlmIChyZW5kZXJHcm91cC5pc0NhY2hlZEFzVGV4dHVyZSkge1xuICAgICAgaWYgKHJlbmRlckdyb3VwLnRleHR1cmVOZWVkc1VwZGF0ZSkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSByZW5kZXJHcm91cC5yb290LmdldExvY2FsQm91bmRzKCk7XG4gICAgICAgIGJvdW5kcy5jZWlsKCk7XG4gICAgICAgIGNvbnN0IGxhc3RUZXh0dXJlID0gcmVuZGVyR3JvdXAudGV4dHVyZTtcbiAgICAgICAgaWYgKHJlbmRlckdyb3VwLnRleHR1cmUpIHtcbiAgICAgICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlckdyb3VwLnRleHR1cmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSByZW5kZXJHcm91cC50ZXh0dXJlT3B0aW9ucy5yZXNvbHV0aW9uIHx8IHJlbmRlcmVyLnZpZXcucmVzb2x1dGlvbjtcbiAgICAgICAgY29uc3QgYW50aWFsaWFzID0gcmVuZGVyR3JvdXAudGV4dHVyZU9wdGlvbnMuYW50aWFsaWFzID8/IHJlbmRlcmVyLnZpZXcuYW50aWFsaWFzO1xuICAgICAgICBjb25zdCBzY2FsZU1vZGUgPSByZW5kZXJHcm91cC50ZXh0dXJlT3B0aW9ucy5zY2FsZU1vZGUgPz8gXCJsaW5lYXJcIjtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgYW50aWFsaWFzXG4gICAgICAgICk7XG4gICAgICAgIHRleHR1cmUuX3NvdXJjZS5zdHlsZSA9IG5ldyBUZXh0dXJlU3R5bGUoeyBzY2FsZU1vZGUgfSk7XG4gICAgICAgIHJlbmRlckdyb3VwLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICByZW5kZXJHcm91cC5fdGV4dHVyZUJvdW5kcyB8fCAocmVuZGVyR3JvdXAuX3RleHR1cmVCb3VuZHMgPSBuZXcgQm91bmRzKCkpO1xuICAgICAgICByZW5kZXJHcm91cC5fdGV4dHVyZUJvdW5kcy5jb3B5RnJvbShib3VuZHMpO1xuICAgICAgICBpZiAobGFzdFRleHR1cmUgIT09IHJlbmRlckdyb3VwLnRleHR1cmUpIHtcbiAgICAgICAgICBpZiAocmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQpIHtcbiAgICAgICAgICAgIHJlbmRlckdyb3VwLnJlbmRlckdyb3VwUGFyZW50LnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZW5kZXJHcm91cC50ZXh0dXJlKSB7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlckdyb3VwLnRleHR1cmUsIHRydWUpO1xuICAgICAgcmVuZGVyR3JvdXAudGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIF91cGRhdGVSZW5kZXJHcm91cHMocmVuZGVyR3JvdXApIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlclBpcGVzID0gcmVuZGVyZXIucmVuZGVyUGlwZXM7XG4gICAgcmVuZGVyR3JvdXAucnVuT25SZW5kZXIocmVuZGVyZXIpO1xuICAgIHJlbmRlckdyb3VwLmluc3RydWN0aW9uU2V0LnJlbmRlclBpcGVzID0gcmVuZGVyUGlwZXM7XG4gICAgaWYgKCFyZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UpIHtcbiAgICAgIHZhbGlkYXRlUmVuZGVyYWJsZXMocmVuZGVyR3JvdXAsIHJlbmRlclBpcGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJMaXN0KHJlbmRlckdyb3VwLmNoaWxkcmVuUmVuZGVyYWJsZXNUb1VwZGF0ZS5saXN0LCAwKTtcbiAgICB9XG4gICAgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zKHJlbmRlckdyb3VwKTtcbiAgICBpZiAocmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlKSB7XG4gICAgICByZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2J1aWxkSW5zdHJ1Y3Rpb25zKHJlbmRlckdyb3VwLCByZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmFibGVzKHJlbmRlckdyb3VwKTtcbiAgICB9XG4gICAgcmVuZGVyR3JvdXAuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlLmluZGV4ID0gMDtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC51cGxvYWQocmVuZGVyR3JvdXAuaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGlmIChyZW5kZXJHcm91cC5pc0NhY2hlZEFzVGV4dHVyZSAmJiAhcmVuZGVyR3JvdXAudGV4dHVyZU5lZWRzVXBkYXRlKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyR3JvdXAucmVuZGVyR3JvdXBDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fdXBkYXRlUmVuZGVyR3JvdXBzKHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlUmVuZGVyYWJsZXMocmVuZGVyR3JvdXApIHtcbiAgICBjb25zdCB7IGxpc3QsIGluZGV4IH0gPSByZW5kZXJHcm91cC5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBsaXN0W2ldO1xuICAgICAgaWYgKGNvbnRhaW5lci5kaWRWaWV3VXBkYXRlKSB7XG4gICAgICAgIHJlbmRlckdyb3VwLnVwZGF0ZVJlbmRlcmFibGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJMaXN0KGxpc3QsIGluZGV4KTtcbiAgfVxuICBfYnVpbGRJbnN0cnVjdGlvbnMocmVuZGVyR3JvdXAsIHJlbmRlcmVyT3JQaXBlcykge1xuICAgIGNvbnN0IHJvb3QgPSByZW5kZXJHcm91cC5yb290O1xuICAgIGNvbnN0IGluc3RydWN0aW9uU2V0ID0gcmVuZGVyR3JvdXAuaW5zdHJ1Y3Rpb25TZXQ7XG4gICAgaW5zdHJ1Y3Rpb25TZXQucmVzZXQoKTtcbiAgICBjb25zdCByZW5kZXJlciA9IHJlbmRlcmVyT3JQaXBlcy5yZW5kZXJQaXBlcyA/IHJlbmRlcmVyT3JQaXBlcyA6IHJlbmRlcmVyT3JQaXBlcy5iYXRjaC5yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJQaXBlcyA9IHJlbmRlcmVyLnJlbmRlclBpcGVzO1xuICAgIHJlbmRlclBpcGVzLmJhdGNoLmJ1aWxkU3RhcnQoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIHJlbmRlclBpcGVzLmJsZW5kTW9kZS5idWlsZFN0YXJ0KCk7XG4gICAgcmVuZGVyUGlwZXMuY29sb3JNYXNrLmJ1aWxkU3RhcnQoKTtcbiAgICBpZiAocm9vdC5zb3J0YWJsZUNoaWxkcmVuKSB7XG4gICAgICByb290LnNvcnRDaGlsZHJlbigpO1xuICAgIH1cbiAgICByb290LmNvbGxlY3RSZW5kZXJhYmxlc1dpdGhFZmZlY3RzKGluc3RydWN0aW9uU2V0LCByZW5kZXJlciwgbnVsbCk7XG4gICAgcmVuZGVyUGlwZXMuYmF0Y2guYnVpbGRFbmQoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIHJlbmRlclBpcGVzLmJsZW5kTW9kZS5idWlsZEVuZChpbnN0cnVjdGlvblNldCk7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZW5kZXJHcm91cFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwicmVuZGVyR3JvdXBcIlxufTtcblxuZXhwb3J0IHsgUmVuZGVyR3JvdXBTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlckdyb3VwU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZVNwcml0ZSB9IGZyb20gJy4vQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgU3ByaXRlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKHNwcml0ZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLmRpZFZpZXdVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goZ3B1U3ByaXRlLCBpbnN0cnVjdGlvblNldCk7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShzcHJpdGUpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLmRpZFZpZXdVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIGdwdVNwcml0ZS5fYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdVNwcml0ZSk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dldEdwdVNwcml0ZShzcHJpdGUpO1xuICAgIHJldHVybiAhZ3B1U3ByaXRlLl9iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShcbiAgICAgIGdwdVNwcml0ZSxcbiAgICAgIHNwcml0ZS5fdGV4dHVyZVxuICAgICk7XG4gIH1cbiAgX3VwZGF0ZUJhdGNoYWJsZVNwcml0ZShzcHJpdGUsIGJhdGNoYWJsZVNwcml0ZSkge1xuICAgIGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSBzcHJpdGUudmlzdWFsQm91bmRzO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVTcHJpdGUoc3ByaXRlKSB7XG4gICAgcmV0dXJuIHNwcml0ZS5fZ3B1RGF0YVt0aGlzLl9yZW5kZXJlci51aWRdIHx8IHRoaXMuX2luaXRHUFVTcHJpdGUoc3ByaXRlKTtcbiAgfVxuICBfaW5pdEdQVVNwcml0ZShzcHJpdGUpIHtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBuZXcgQmF0Y2hhYmxlU3ByaXRlKCk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGUgPSBzcHJpdGU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRyYW5zZm9ybSA9IHNwcml0ZS5ncm91cFRyYW5zZm9ybTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICBiYXRjaGFibGVTcHJpdGUuYm91bmRzID0gc3ByaXRlLnZpc3VhbEJvdW5kcztcbiAgICBiYXRjaGFibGVTcHJpdGUucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBzcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgIHNwcml0ZS5fZ3B1RGF0YVt0aGlzLl9yZW5kZXJlci51aWRdID0gYmF0Y2hhYmxlU3ByaXRlO1xuICAgIHJldHVybiBiYXRjaGFibGVTcHJpdGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5TcHJpdGVQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJzcHJpdGVcIlxufTtcblxuZXhwb3J0IHsgU3ByaXRlUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IERlZmF1bHRCYXRjaGVyIH0gZnJvbSAnLi9EZWZhdWx0QmF0Y2hlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9CYXRjaGVyUGlwZSA9IGNsYXNzIF9CYXRjaGVyUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBhZGFwdG9yKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLmZvcjJkKCk7XG4gICAgdGhpcy5fYmF0Y2hlcnNCeUluc3RydWN0aW9uU2V0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqIEEgcmVjb3JkIG9mIGFsbCBhY3RpdmUgYmF0Y2hlcnMsIGtleWVkIGJ5IHRoZWlyIG5hbWVzICovXG4gICAgdGhpcy5fYWN0aXZlQmF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9hZGFwdG9yID0gYWRhcHRvcjtcbiAgICB0aGlzLl9hZGFwdG9yLmluaXQ/Lih0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0QmF0Y2hlcihuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLl9hdmFpbGFibGVCYXRjaGVyc1tuYW1lXSgpO1xuICB9XG4gIGJ1aWxkU3RhcnQoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBsZXQgYmF0Y2hlcnMgPSB0aGlzLl9iYXRjaGVyc0J5SW5zdHJ1Y3Rpb25TZXRbaW5zdHJ1Y3Rpb25TZXQudWlkXTtcbiAgICBpZiAoIWJhdGNoZXJzKSB7XG4gICAgICBiYXRjaGVycyA9IHRoaXMuX2JhdGNoZXJzQnlJbnN0cnVjdGlvblNldFtpbnN0cnVjdGlvblNldC51aWRdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBiYXRjaGVycy5kZWZhdWx0IHx8IChiYXRjaGVycy5kZWZhdWx0ID0gbmV3IERlZmF1bHRCYXRjaGVyKHtcbiAgICAgICAgbWF4VGV4dHVyZXM6IHRoaXMucmVuZGVyZXIubGltaXRzLm1heEJhdGNoYWJsZVRleHR1cmVzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXMgPSBiYXRjaGVycztcbiAgICB0aGlzLl9hY3RpdmVCYXRjaCA9IHRoaXMuX2FjdGl2ZUJhdGNoZXMuZGVmYXVsdDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fYWN0aXZlQmF0Y2hlcykge1xuICAgICAgdGhpcy5fYWN0aXZlQmF0Y2hlc1tpXS5iZWdpbigpO1xuICAgIH1cbiAgfVxuICBhZGRUb0JhdGNoKGJhdGNoYWJsZU9iamVjdCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlQmF0Y2gubmFtZSAhPT0gYmF0Y2hhYmxlT2JqZWN0LmJhdGNoZXJOYW1lKSB7XG4gICAgICB0aGlzLl9hY3RpdmVCYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgICBsZXQgYmF0Y2ggPSB0aGlzLl9hY3RpdmVCYXRjaGVzW2JhdGNoYWJsZU9iamVjdC5iYXRjaGVyTmFtZV07XG4gICAgICBpZiAoIWJhdGNoKSB7XG4gICAgICAgIGJhdGNoID0gdGhpcy5fYWN0aXZlQmF0Y2hlc1tiYXRjaGFibGVPYmplY3QuYmF0Y2hlck5hbWVdID0gX0JhdGNoZXJQaXBlLmdldEJhdGNoZXIoYmF0Y2hhYmxlT2JqZWN0LmJhdGNoZXJOYW1lKTtcbiAgICAgICAgYmF0Y2guYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZUJhdGNoID0gYmF0Y2g7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoLmFkZChiYXRjaGFibGVPYmplY3QpO1xuICB9XG4gIGJyZWFrKGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fYWN0aXZlQmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIGJ1aWxkRW5kKGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fYWN0aXZlQmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9hY3RpdmVCYXRjaGVzO1xuICAgIGZvciAoY29uc3QgaSBpbiBiYXRjaGVzKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGJhdGNoLmdlb21ldHJ5O1xuICAgICAgZ2VvbWV0cnkuaW5kZXhCdWZmZXIuc2V0RGF0YVdpdGhTaXplKGJhdGNoLmluZGV4QnVmZmVyLCBiYXRjaC5pbmRleFNpemUsIHRydWUpO1xuICAgICAgZ2VvbWV0cnkuYnVmZmVyc1swXS5zZXREYXRhV2l0aFNpemUoYmF0Y2guYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3LCBiYXRjaC5hdHRyaWJ1dGVTaXplLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHVwbG9hZChpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoZXJzID0gdGhpcy5fYmF0Y2hlcnNCeUluc3RydWN0aW9uU2V0W2luc3RydWN0aW9uU2V0LnVpZF07XG4gICAgZm9yIChjb25zdCBpIGluIGJhdGNoZXJzKSB7XG4gICAgICBjb25zdCBiYXRjaGVyID0gYmF0Y2hlcnNbaV07XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGJhdGNoZXIuZ2VvbWV0cnk7XG4gICAgICBpZiAoYmF0Y2hlci5kaXJ0eSkge1xuICAgICAgICBiYXRjaGVyLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGdlb21ldHJ5LmJ1ZmZlcnNbMF0udXBkYXRlKGJhdGNoZXIuYXR0cmlidXRlU2l6ZSAqIDQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleGVjdXRlKGJhdGNoKSB7XG4gICAgaWYgKGJhdGNoLmFjdGlvbiA9PT0gXCJzdGFydEJhdGNoXCIpIHtcbiAgICAgIGNvbnN0IGJhdGNoZXIgPSBiYXRjaC5iYXRjaGVyO1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBiYXRjaGVyLmdlb21ldHJ5O1xuICAgICAgY29uc3Qgc2hhZGVyID0gYmF0Y2hlci5zaGFkZXI7XG4gICAgICB0aGlzLl9hZGFwdG9yLnN0YXJ0KHRoaXMsIGdlb21ldHJ5LCBzaGFkZXIpO1xuICAgIH1cbiAgICB0aGlzLl9hZGFwdG9yLmV4ZWN1dGUodGhpcywgYmF0Y2gpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWRhcHRvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2FjdGl2ZUJhdGNoZXMpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVCYXRjaGVzID0gbnVsbDtcbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fQmF0Y2hlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImJhdGNoXCJcbn07XG5fQmF0Y2hlclBpcGUuX2F2YWlsYWJsZUJhdGNoZXJzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5sZXQgQmF0Y2hlclBpcGUgPSBfQmF0Y2hlclBpcGU7XG5leHRlbnNpb25zLmhhbmRsZUJ5TWFwKEV4dGVuc2lvblR5cGUuQmF0Y2hlciwgQmF0Y2hlclBpcGUuX2F2YWlsYWJsZUJhdGNoZXJzKTtcbmV4dGVuc2lvbnMuYWRkKERlZmF1bHRCYXRjaGVyKTtcblxuZXhwb3J0IHsgQmF0Y2hlclBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoZXJQaXBlLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IFwiaW4gdmVjMiB2TWFza0Nvb3JkO1xcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1TWFza1RleHR1cmU7XFxuXFxudW5pZm9ybSBmbG9hdCB1QWxwaGE7XFxudW5pZm9ybSB2ZWM0IHVNYXNrQ2xhbXA7XFxudW5pZm9ybSBmbG9hdCB1SW52ZXJzZTtcXG5cXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcbiAgICAgICAgc3RlcCh1TWFza0NsYW1wLngsIHZNYXNrQ29vcmQueCkgK1xcbiAgICAgICAgc3RlcCh1TWFza0NsYW1wLnksIHZNYXNrQ29vcmQueSkgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLngsIHVNYXNrQ2xhbXAueikgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIHVNYXNrQ2xhbXAudykpO1xcblxcbiAgICAvLyBUT0RPIGxvb2sgaW50byB3aHkgdGhpcyBpcyBuZWVkZWRcXG4gICAgZmxvYXQgbnBtQWxwaGEgPSB1QWxwaGE7XFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlKHVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgdmVjNCBtYXNreSA9IHRleHR1cmUodU1hc2tUZXh0dXJlLCB2TWFza0Nvb3JkKTtcXG4gICAgZmxvYXQgYWxwaGFNdWwgPSAxLjAgLSBucG1BbHBoYSAqICgxLjAgLSBtYXNreS5hKTtcXG5cXG4gICAgZmxvYXQgYSA9IGFscGhhTXVsICogbWFza3kuciAqIG5wbUFscGhhICogY2xpcDtcXG5cXG4gICAgaWYgKHVJbnZlcnNlID09IDEuMCkge1xcbiAgICAgICAgYSA9IDEuMCAtIGE7XFxuICAgIH1cXG5cXG4gICAgZmluYWxDb2xvciA9IG9yaWdpbmFsICogYTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hc2suZnJhZy5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gXCJpbiB2ZWMyIGFQb3NpdGlvbjtcXG5cXG5vdXQgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbm91dCB2ZWMyIHZNYXNrQ29vcmQ7XFxuXFxuXFxudW5pZm9ybSB2ZWM0IHVJbnB1dFNpemU7XFxudW5pZm9ybSB2ZWM0IHVPdXRwdXRGcmFtZTtcXG51bmlmb3JtIHZlYzQgdU91dHB1dFRleHR1cmU7XFxudW5pZm9ybSBtYXQzIHVGaWx0ZXJNYXRyaXg7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggIHZlYzIgYVBvc2l0aW9uIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhUG9zaXRpb24gKiB1T3V0cHV0RnJhbWUuencgKyB1T3V0cHV0RnJhbWUueHk7XFxuICAgICAgIFxcbiAgICBwb3NpdGlvbi54ID0gcG9zaXRpb24ueCAqICgyLjAgLyB1T3V0cHV0VGV4dHVyZS54KSAtIDEuMDtcXG4gICAgcG9zaXRpb24ueSA9IHBvc2l0aW9uLnkgKiAoMi4wKnVPdXRwdXRUZXh0dXJlLnogLyB1T3V0cHV0VGV4dHVyZS55KSAtIHVPdXRwdXRUZXh0dXJlLno7XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XFxufVxcblxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCAgdmVjMiBhUG9zaXRpb24gKVxcbntcXG4gICAgcmV0dXJuIGFQb3NpdGlvbiAqICh1T3V0cHV0RnJhbWUuencgKiB1SW5wdXRTaXplLnp3KTtcXG59XFxuXFxudmVjMiBnZXRGaWx0ZXJDb29yZCggdmVjMiBhUG9zaXRpb24gKVxcbntcXG4gICAgcmV0dXJuICAoIHVGaWx0ZXJNYXRyaXggKiB2ZWMzKCBmaWx0ZXJUZXh0dXJlQ29vcmQoYVBvc2l0aW9uKSwgMS4wKSAgKS54eTtcXG59ICAgXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKGFQb3NpdGlvbik7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoYVBvc2l0aW9uKTtcXG4gICAgdk1hc2tDb29yZCA9IGdldEZpbHRlckNvb3JkKGFQb3NpdGlvbik7XFxufVxcblwiO1xuXG5leHBvcnQgeyB2ZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFzay52ZXJ0Lm1qcy5tYXBcbiIsInZhciBzb3VyY2UgPSBcInN0cnVjdCBHbG9iYWxGaWx0ZXJVbmlmb3JtcyB7XFxuICB1SW5wdXRTaXplOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dFBpeGVsOnZlYzQ8ZjMyPixcXG4gIHVJbnB1dENsYW1wOnZlYzQ8ZjMyPixcXG4gIHVPdXRwdXRGcmFtZTp2ZWM0PGYzMj4sXFxuICB1R2xvYmFsRnJhbWU6dmVjNDxmMzI+LFxcbiAgdU91dHB1dFRleHR1cmU6dmVjNDxmMzI+LFxcbn07XFxuXFxuc3RydWN0IE1hc2tVbmlmb3JtcyB7XFxuICB1RmlsdGVyTWF0cml4Om1hdDN4MzxmMzI+LFxcbiAgdU1hc2tDbGFtcDp2ZWM0PGYzMj4sXFxuICB1QWxwaGE6ZjMyLFxcbiAgdUludmVyc2U6ZjMyLFxcbn07XFxuXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnZnU6IEdsb2JhbEZpbHRlclVuaWZvcm1zO1xcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyIDogc2FtcGxlcjtcXG5cXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGZpbHRlclVuaWZvcm1zIDogTWFza1VuaWZvcm1zO1xcbkBncm91cCgxKSBAYmluZGluZygxKSB2YXIgdU1hc2tUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XFxuXFxuc3RydWN0IFZTT3V0cHV0IHtcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICAgIEBsb2NhdGlvbigwKSB1diA6IHZlYzI8ZjMyPixcXG4gICAgQGxvY2F0aW9uKDEpIGZpbHRlclV2IDogdmVjMjxmMzI+LFxcbn07XFxuXFxuZm4gZmlsdGVyVmVydGV4UG9zaXRpb24oYVBvc2l0aW9uOnZlYzI8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcbiAgICB2YXIgcG9zaXRpb24gPSBhUG9zaXRpb24gKiBnZnUudU91dHB1dEZyYW1lLnp3ICsgZ2Z1LnVPdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcG9zaXRpb24ueCA9IHBvc2l0aW9uLnggKiAoMi4wIC8gZ2Z1LnVPdXRwdXRUZXh0dXJlLngpIC0gMS4wO1xcbiAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAqICgyLjAqZ2Z1LnVPdXRwdXRUZXh0dXJlLnogLyBnZnUudU91dHB1dFRleHR1cmUueSkgLSBnZnUudU91dHB1dFRleHR1cmUuejtcXG5cXG4gICAgcmV0dXJuIHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcXG59XFxuXFxuZm4gZmlsdGVyVGV4dHVyZUNvb3JkKCBhUG9zaXRpb246dmVjMjxmMzI+ICkgLT4gdmVjMjxmMzI+XFxue1xcbiAgICByZXR1cm4gYVBvc2l0aW9uICogKGdmdS51T3V0cHV0RnJhbWUuencgKiBnZnUudUlucHV0U2l6ZS56dyk7XFxufVxcblxcbmZuIGdsb2JhbFRleHR1cmVDb29yZCggYVBvc2l0aW9uOnZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiAgKGFQb3NpdGlvbi54eSAvIGdmdS51R2xvYmFsRnJhbWUuencpICsgKGdmdS51R2xvYmFsRnJhbWUueHkgLyBnZnUudUdsb2JhbEZyYW1lLnp3KTtcXG59XFxuXFxuZm4gZ2V0RmlsdGVyQ29vcmQoYVBvc2l0aW9uOnZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiAoIGZpbHRlclVuaWZvcm1zLnVGaWx0ZXJNYXRyaXggKiB2ZWMzKCBmaWx0ZXJUZXh0dXJlQ29vcmQoYVBvc2l0aW9uKSwgMS4wKSAgKS54eTtcXG59XFxuXFxuZm4gZ2V0U2l6ZSgpIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiBnZnUudUdsb2JhbEZyYW1lLnp3O1xcbn1cXG5cXG5AdmVydGV4XFxuZm4gbWFpblZlcnRleChcXG4gIEBsb2NhdGlvbigwKSBhUG9zaXRpb24gOiB2ZWMyPGYzMj4sXFxuKSAtPiBWU091dHB1dCB7XFxuICByZXR1cm4gVlNPdXRwdXQoXFxuICAgZmlsdGVyVmVydGV4UG9zaXRpb24oYVBvc2l0aW9uKSxcXG4gICBmaWx0ZXJUZXh0dXJlQ29vcmQoYVBvc2l0aW9uKSxcXG4gICBnZXRGaWx0ZXJDb29yZChhUG9zaXRpb24pXFxuICApO1xcbn1cXG5cXG5AZnJhZ21lbnRcXG5mbiBtYWluRnJhZ21lbnQoXFxuICBAbG9jYXRpb24oMCkgdXY6IHZlYzI8ZjMyPixcXG4gIEBsb2NhdGlvbigxKSBmaWx0ZXJVdjogdmVjMjxmMzI+LFxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cXG4pIC0+IEBsb2NhdGlvbigwKSB2ZWM0PGYzMj4ge1xcblxcbiAgICB2YXIgbWFza0NsYW1wID0gZmlsdGVyVW5pZm9ybXMudU1hc2tDbGFtcDtcXG4gICAgdmFyIHVBbHBoYSA9IGZpbHRlclVuaWZvcm1zLnVBbHBoYTtcXG5cXG4gICAgdmFyIGNsaXAgPSBzdGVwKDMuNSxcXG4gICAgICBzdGVwKG1hc2tDbGFtcC54LCBmaWx0ZXJVdi54KSArXFxuICAgICAgc3RlcChtYXNrQ2xhbXAueSwgZmlsdGVyVXYueSkgK1xcbiAgICAgIHN0ZXAoZmlsdGVyVXYueCwgbWFza0NsYW1wLnopICtcXG4gICAgICBzdGVwKGZpbHRlclV2LnksIG1hc2tDbGFtcC53KSk7XFxuXFxuICAgIHZhciBtYXNrID0gdGV4dHVyZVNhbXBsZSh1TWFza1RleHR1cmUsIHVTYW1wbGVyLCBmaWx0ZXJVdik7XFxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlU2FtcGxlKHVUZXh0dXJlLCB1U2FtcGxlciwgdXYpO1xcbiAgICB2YXIgYWxwaGFNdWwgPSAxLjAgLSB1QWxwaGEgKiAoMS4wIC0gbWFzay5hKTtcXG5cXG4gICAgdmFyIGE6IGYzMiA9IGFscGhhTXVsICogbWFzay5yICogdUFscGhhICogY2xpcDtcXG5cXG4gICAgaWYgKGZpbHRlclVuaWZvcm1zLnVJbnZlcnNlID09IDEuMCkge1xcbiAgICAgICAgYSA9IDEuMCAtIGE7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHNvdXJjZSAqIGE7XFxufVxcblwiO1xuXG5leHBvcnQgeyBzb3VyY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFzay53Z3NsLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgR3B1UHJvZ3JhbSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci9HcHVQcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlTWF0cml4IH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9GaWx0ZXIubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL21hc2suZnJhZy5tanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuL21hc2sudmVydC5tanMnO1xuaW1wb3J0IHNvdXJjZSBmcm9tICcuL21hc2sud2dzbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1hc2tGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzcHJpdGUsIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4KHNwcml0ZS50ZXh0dXJlKTtcbiAgICBjb25zdCBmaWx0ZXJVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdUZpbHRlck1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVNYXNrQ2xhbXA6IHsgdmFsdWU6IHRleHR1cmVNYXRyaXgudUNsYW1wRnJhbWUsIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVBbHBoYTogeyB2YWx1ZTogMSwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdUludmVyc2U6IHsgdmFsdWU6IG9wdGlvbnMuaW52ZXJzZSA/IDEgOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcIm1hc2stZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICAuLi5yZXN0LFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIGNsaXBUb1ZpZXdwb3J0OiBmYWxzZSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBmaWx0ZXJVbmlmb3JtcyxcbiAgICAgICAgdU1hc2tUZXh0dXJlOiBzcHJpdGUudGV4dHVyZS5zb3VyY2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgICB0aGlzLl90ZXh0dXJlTWF0cml4ID0gdGV4dHVyZU1hdHJpeDtcbiAgfVxuICBzZXQgaW52ZXJzZSh2YWx1ZSkge1xuICAgIHRoaXMucmVzb3VyY2VzLmZpbHRlclVuaWZvcm1zLnVuaWZvcm1zLnVJbnZlcnNlID0gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBnZXQgaW52ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuZmlsdGVyVW5pZm9ybXMudW5pZm9ybXMudUludmVyc2UgPT09IDE7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgdGhpcy5fdGV4dHVyZU1hdHJpeC50ZXh0dXJlID0gdGhpcy5zcHJpdGUudGV4dHVyZTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeChcbiAgICAgIHRoaXMucmVzb3VyY2VzLmZpbHRlclVuaWZvcm1zLnVuaWZvcm1zLnVGaWx0ZXJNYXRyaXgsXG4gICAgICB0aGlzLnNwcml0ZVxuICAgICkucHJlcGVuZCh0aGlzLl90ZXh0dXJlTWF0cml4Lm1hcENvb3JkKTtcbiAgICB0aGlzLnJlc291cmNlcy51TWFza1RleHR1cmUgPSB0aGlzLnNwcml0ZS50ZXh0dXJlLnNvdXJjZTtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWFza0ZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza0ZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXJFZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuaW1wb3J0IHsgTWFza0ZpbHRlciB9IGZyb20gJy4uLy4uLy4uL2ZpbHRlcnMvbWFzay9NYXNrRmlsdGVyLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRHbG9iYWxCb3VuZHMubWpzJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuaW1wb3J0IHsgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmNsYXNzIEFscGhhTWFza0VmZmVjdCBleHRlbmRzIEZpbHRlckVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5maWx0ZXJzID0gW25ldyBNYXNrRmlsdGVyKHtcbiAgICAgIHNwcml0ZTogbmV3IFNwcml0ZShUZXh0dXJlLkVNUFRZKSxcbiAgICAgIGludmVyc2U6IGZhbHNlLFxuICAgICAgcmVzb2x1dGlvbjogXCJpbmhlcml0XCIsXG4gICAgICBhbnRpYWxpYXM6IFwiaW5oZXJpdFwiXG4gICAgfSldO1xuICB9XG4gIGdldCBzcHJpdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1swXS5zcHJpdGU7XG4gIH1cbiAgc2V0IHNwcml0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZmlsdGVyc1swXS5zcHJpdGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgaW52ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzWzBdLmludmVyc2U7XG4gIH1cbiAgc2V0IGludmVyc2UodmFsdWUpIHtcbiAgICB0aGlzLmZpbHRlcnNbMF0uaW52ZXJzZSA9IHZhbHVlO1xuICB9XG59XG5jbGFzcyBBbHBoYU1hc2tQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVNYXNrU3RhZ2UgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHB1c2gobWFzaywgbWFza2VkQ29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiYWxwaGFNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tCZWdpblwiLFxuICAgICAgbWFzayxcbiAgICAgIGludmVyc2U6IG1hc2tlZENvbnRhaW5lci5fbWFza09wdGlvbnMuaW52ZXJzZSxcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2UsXG4gICAgICBtYXNrZWRDb250YWluZXJcbiAgICB9KTtcbiAgICBtYXNrLmludmVyc2UgPSBtYXNrZWRDb250YWluZXIuX21hc2tPcHRpb25zLmludmVyc2U7XG4gICAgaWYgKG1hc2sucmVuZGVyTWFza1RvVGV4dHVyZSkge1xuICAgICAgY29uc3QgbWFza0NvbnRhaW5lciA9IG1hc2subWFzaztcbiAgICAgIG1hc2tDb250YWluZXIuaW5jbHVkZUluQnVpbGQgPSB0cnVlO1xuICAgICAgbWFza0NvbnRhaW5lci5jb2xsZWN0UmVuZGVyYWJsZXMoXG4gICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIG1hc2tDb250YWluZXIuaW5jbHVkZUluQnVpbGQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiYWxwaGFNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tFbmRcIixcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrZWRDb250YWluZXIsXG4gICAgICBpbnZlcnNlOiBtYXNrZWRDb250YWluZXIuX21hc2tPcHRpb25zLmludmVyc2UsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcG9wKG1hc2ssIF9tYXNrZWRDb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJhbHBoYU1hc2tcIixcbiAgICAgIGFjdGlvbjogXCJwb3BNYXNrRW5kXCIsXG4gICAgICBtYXNrLFxuICAgICAgaW52ZXJzZTogX21hc2tlZENvbnRhaW5lci5fbWFza09wdGlvbnMuaW52ZXJzZSxcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKGluc3RydWN0aW9uKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJNYXNrID0gaW5zdHJ1Y3Rpb24ubWFzay5yZW5kZXJNYXNrVG9UZXh0dXJlO1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicHVzaE1hc2tCZWdpblwiKSB7XG4gICAgICBjb25zdCBmaWx0ZXJFZmZlY3QgPSBCaWdQb29sLmdldChBbHBoYU1hc2tFZmZlY3QpO1xuICAgICAgZmlsdGVyRWZmZWN0LmludmVyc2UgPSBpbnN0cnVjdGlvbi5pbnZlcnNlO1xuICAgICAgaWYgKHJlbmRlck1hc2spIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ubWFzay5tYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRHbG9iYWxCb3VuZHMoaW5zdHJ1Y3Rpb24ubWFzay5tYXNrLCB0cnVlLCB0ZW1wQm91bmRzKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ubWFzay5tYXNrLm1lYXN1cmFibGUgPSBmYWxzZTtcbiAgICAgICAgYm91bmRzLmNlaWwoKTtcbiAgICAgICAgY29uc3QgY29sb3JUZXh0dXJlU291cmNlID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldC5jb2xvclRleHR1cmUuc291cmNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgY29sb3JUZXh0dXJlU291cmNlLl9yZXNvbHV0aW9uLFxuICAgICAgICAgIGNvbG9yVGV4dHVyZVNvdXJjZS5hbnRpYWxpYXNcbiAgICAgICAgKTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnB1c2goZmlsdGVyVGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogYm91bmRzLFxuICAgICAgICAgIHdvcmxkQ29sb3I6IDQyOTQ5NjcyOTVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IGZpbHRlckVmZmVjdC5zcHJpdGU7XG4gICAgICAgIHNwcml0ZS50ZXh0dXJlID0gZmlsdGVyVGV4dHVyZTtcbiAgICAgICAgc3ByaXRlLndvcmxkVHJhbnNmb3JtLnR4ID0gYm91bmRzLm1pblg7XG4gICAgICAgIHNwcml0ZS53b3JsZFRyYW5zZm9ybS50eSA9IGJvdW5kcy5taW5ZO1xuICAgICAgICB0aGlzLl9hY3RpdmVNYXNrU3RhZ2UucHVzaCh7XG4gICAgICAgICAgZmlsdGVyRWZmZWN0LFxuICAgICAgICAgIG1hc2tlZENvbnRhaW5lcjogaW5zdHJ1Y3Rpb24ubWFza2VkQ29udGFpbmVyLFxuICAgICAgICAgIGZpbHRlclRleHR1cmVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXJFZmZlY3Quc3ByaXRlID0gaW5zdHJ1Y3Rpb24ubWFzay5tYXNrO1xuICAgICAgICB0aGlzLl9hY3RpdmVNYXNrU3RhZ2UucHVzaCh7XG4gICAgICAgICAgZmlsdGVyRWZmZWN0LFxuICAgICAgICAgIG1hc2tlZENvbnRhaW5lcjogaW5zdHJ1Y3Rpb24ubWFza2VkQ29udGFpbmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInB1c2hNYXNrRW5kXCIpIHtcbiAgICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5fYWN0aXZlTWFza1N0YWdlW3RoaXMuX2FjdGl2ZU1hc2tTdGFnZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChyZW5kZXJNYXNrKSB7XG4gICAgICAgIGlmIChyZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR0wpIHtcbiAgICAgICAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuZmluaXNoUmVuZGVyUGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5wb3AoKTtcbiAgICAgICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucG9wKCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5maWx0ZXIucHVzaCh7XG4gICAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgICAgYWN0aW9uOiBcInB1c2hGaWx0ZXJcIixcbiAgICAgICAgY29udGFpbmVyOiBtYXNrRGF0YS5tYXNrZWRDb250YWluZXIsXG4gICAgICAgIGZpbHRlckVmZmVjdDogbWFza0RhdGEuZmlsdGVyRWZmZWN0LFxuICAgICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwb3BNYXNrRW5kXCIpIHtcbiAgICAgIHJlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5fYWN0aXZlTWFza1N0YWdlLnBvcCgpO1xuICAgICAgaWYgKHJlbmRlck1hc2spIHtcbiAgICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShtYXNrRGF0YS5maWx0ZXJUZXh0dXJlKTtcbiAgICAgIH1cbiAgICAgIEJpZ1Bvb2wucmV0dXJuKG1hc2tEYXRhLmZpbHRlckVmZmVjdCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZU1hc2tTdGFnZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5BbHBoYU1hc2tQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJhbHBoYU1hc2tcIlxufTtcblxuZXhwb3J0IHsgQWxwaGFNYXNrUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxwaGFNYXNrUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ29sb3JNYXNrUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fY29sb3JTdGFjayA9IFtdO1xuICAgIHRoaXMuX2NvbG9yU3RhY2tJbmRleCA9IDA7XG4gICAgdGhpcy5fY3VycmVudENvbG9yID0gMDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGJ1aWxkU3RhcnQoKSB7XG4gICAgdGhpcy5fY29sb3JTdGFja1swXSA9IDE1O1xuICAgIHRoaXMuX2NvbG9yU3RhY2tJbmRleCA9IDE7XG4gICAgdGhpcy5fY3VycmVudENvbG9yID0gMTU7XG4gIH1cbiAgcHVzaChtYXNrLCBfY29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGNvbnN0IGNvbG9yU3RhY2sgPSB0aGlzLl9jb2xvclN0YWNrO1xuICAgIGNvbG9yU3RhY2tbdGhpcy5fY29sb3JTdGFja0luZGV4XSA9IGNvbG9yU3RhY2tbdGhpcy5fY29sb3JTdGFja0luZGV4IC0gMV0gJiBtYXNrLm1hc2s7XG4gICAgY29uc3QgY3VycmVudENvbG9yID0gdGhpcy5fY29sb3JTdGFja1t0aGlzLl9jb2xvclN0YWNrSW5kZXhdO1xuICAgIGlmIChjdXJyZW50Q29sb3IgIT09IHRoaXMuX2N1cnJlbnRDb2xvcikge1xuICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcImNvbG9yTWFza1wiLFxuICAgICAgICBjb2xvck1hc2s6IGN1cnJlbnRDb2xvcixcbiAgICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2NvbG9yU3RhY2tJbmRleCsrO1xuICB9XG4gIHBvcChfbWFzaywgX2NvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBjb25zdCBjb2xvclN0YWNrID0gdGhpcy5fY29sb3JTdGFjaztcbiAgICB0aGlzLl9jb2xvclN0YWNrSW5kZXgtLTtcbiAgICBjb25zdCBjdXJyZW50Q29sb3IgPSBjb2xvclN0YWNrW3RoaXMuX2NvbG9yU3RhY2tJbmRleCAtIDFdO1xuICAgIGlmIChjdXJyZW50Q29sb3IgIT09IHRoaXMuX2N1cnJlbnRDb2xvcikge1xuICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcImNvbG9yTWFza1wiLFxuICAgICAgICBjb2xvck1hc2s6IGN1cnJlbnRDb2xvcixcbiAgICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHJlbmRlcmVyLmNvbG9yTWFzay5zZXRNYXNrKGluc3RydWN0aW9uLmNvbG9yTWFzayk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY29sb3JTdGFjayA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5Db2xvck1hc2tQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJjb2xvck1hc2tcIlxufTtcblxuZXhwb3J0IHsgQ29sb3JNYXNrUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JNYXNrUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDTEVBUiB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9nbC9jb25zdC5tanMnO1xuaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBTdGVuY2lsTWFza1BpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8vIHVzZWQgd2hlbiBidWlsZGluZyBhbmQgYWxzbyB3aGVuIGV4ZWN1dGluZy4uXG4gICAgdGhpcy5fbWFza1N0YWNrSGFzaCA9IHt9O1xuICAgIHRoaXMuX21hc2tIYXNoID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBwdXNoKG1hc2ssIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVmZmVjdCA9IG1hc2s7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmxlbmRNb2RlLnNldEJsZW5kTW9kZShlZmZlY3QubWFzaywgXCJub25lXCIsIGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tCZWdpblwiLFxuICAgICAgbWFzayxcbiAgICAgIGludmVyc2U6IF9jb250YWluZXIuX21hc2tPcHRpb25zLmludmVyc2UsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgbWFza0NvbnRhaW5lciA9IGVmZmVjdC5tYXNrO1xuICAgIG1hc2tDb250YWluZXIuaW5jbHVkZUluQnVpbGQgPSB0cnVlO1xuICAgIGlmICghdGhpcy5fbWFza0hhc2guaGFzKGVmZmVjdCkpIHtcbiAgICAgIHRoaXMuX21hc2tIYXNoLnNldChlZmZlY3QsIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zU3RhcnQ6IDAsXG4gICAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5fbWFza0hhc2guZ2V0KGVmZmVjdCk7XG4gICAgbWFza0RhdGEuaW5zdHJ1Y3Rpb25zU3RhcnQgPSBpbnN0cnVjdGlvblNldC5pbnN0cnVjdGlvblNpemU7XG4gICAgbWFza0NvbnRhaW5lci5jb2xsZWN0UmVuZGVyYWJsZXMoXG4gICAgICBpbnN0cnVjdGlvblNldCxcbiAgICAgIHJlbmRlcmVyLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgbWFza0NvbnRhaW5lci5pbmNsdWRlSW5CdWlsZCA9IGZhbHNlO1xuICAgIHJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tFbmRcIixcbiAgICAgIG1hc2ssXG4gICAgICBpbnZlcnNlOiBfY29udGFpbmVyLl9tYXNrT3B0aW9ucy5pbnZlcnNlLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uc0xlbmd0aCA9IGluc3RydWN0aW9uU2V0Lmluc3RydWN0aW9uU2l6ZSAtIG1hc2tEYXRhLmluc3RydWN0aW9uc1N0YXJ0IC0gMTtcbiAgICBtYXNrRGF0YS5pbnN0cnVjdGlvbnNMZW5ndGggPSBpbnN0cnVjdGlvbnNMZW5ndGg7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0VWlkID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldC51aWQ7XG4gICAgKF9hID0gdGhpcy5fbWFza1N0YWNrSGFzaClbcmVuZGVyVGFyZ2V0VWlkXSA/PyAoX2FbcmVuZGVyVGFyZ2V0VWlkXSA9IDApO1xuICB9XG4gIHBvcChtYXNrLCBfY29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGVmZmVjdCA9IG1hc2s7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmxlbmRNb2RlLnNldEJsZW5kTW9kZShlZmZlY3QubWFzaywgXCJub25lXCIsIGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicG9wTWFza0JlZ2luXCIsXG4gICAgICBpbnZlcnNlOiBfY29udGFpbmVyLl9tYXNrT3B0aW9ucy5pbnZlcnNlLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5fbWFza0hhc2guZ2V0KG1hc2spO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0RhdGEuaW5zdHJ1Y3Rpb25zTGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc3RydWN0aW9uU2V0Lmluc3RydWN0aW9uc1tpbnN0cnVjdGlvblNldC5pbnN0cnVjdGlvblNpemUrK10gPSBpbnN0cnVjdGlvblNldC5pbnN0cnVjdGlvbnNbbWFza0RhdGEuaW5zdHJ1Y3Rpb25zU3RhcnQrK107XG4gICAgfVxuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwic3RlbmNpbE1hc2tcIixcbiAgICAgIGFjdGlvbjogXCJwb3BNYXNrRW5kXCIsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShpbnN0cnVjdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldFVpZCA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5yZW5kZXJUYXJnZXQudWlkO1xuICAgIGxldCBtYXNrU3RhY2tJbmRleCA9IChfYSA9IHRoaXMuX21hc2tTdGFja0hhc2gpW3JlbmRlclRhcmdldFVpZF0gPz8gKF9hW3JlbmRlclRhcmdldFVpZF0gPSAwKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInB1c2hNYXNrQmVnaW5cIikge1xuICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmVuc3VyZURlcHRoU3RlbmNpbCgpO1xuICAgICAgcmVuZGVyZXIuc3RlbmNpbC5zZXRTdGVuY2lsTW9kZShTVEVOQ0lMX01PREVTLlJFTkRFUklOR19NQVNLX0FERCwgbWFza1N0YWNrSW5kZXgpO1xuICAgICAgbWFza1N0YWNrSW5kZXgrKztcbiAgICAgIHJlbmRlcmVyLmNvbG9yTWFzay5zZXRNYXNrKDApO1xuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInB1c2hNYXNrRW5kXCIpIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbi5pbnZlcnNlKSB7XG4gICAgICAgIHJlbmRlcmVyLnN0ZW5jaWwuc2V0U3RlbmNpbE1vZGUoU1RFTkNJTF9NT0RFUy5JTlZFUlNFX01BU0tfQUNUSVZFLCBtYXNrU3RhY2tJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuTUFTS19BQ1RJVkUsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLmNvbG9yTWFzay5zZXRNYXNrKDE1KTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwb3BNYXNrQmVnaW5cIikge1xuICAgICAgcmVuZGVyZXIuY29sb3JNYXNrLnNldE1hc2soMCk7XG4gICAgICBpZiAobWFza1N0YWNrSW5kZXggIT09IDApIHtcbiAgICAgICAgcmVuZGVyZXIuc3RlbmNpbC5zZXRTdGVuY2lsTW9kZShTVEVOQ0lMX01PREVTLlJFTkRFUklOR19NQVNLX1JFTU9WRSwgbWFza1N0YWNrSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNsZWFyKG51bGwsIENMRUFSLlNURU5DSUwpO1xuICAgICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuRElTQUJMRUQsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIH1cbiAgICAgIG1hc2tTdGFja0luZGV4LS07XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicG9wTWFza0VuZFwiKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24uaW52ZXJzZSkge1xuICAgICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuSU5WRVJTRV9NQVNLX0FDVElWRSwgbWFza1N0YWNrSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuc3RlbmNpbC5zZXRTdGVuY2lsTW9kZShTVEVOQ0lMX01PREVTLk1BU0tfQUNUSVZFLCBtYXNrU3RhY2tJbmRleCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5jb2xvck1hc2suc2V0TWFzaygxNSk7XG4gICAgfVxuICAgIHRoaXMuX21hc2tTdGFja0hhc2hbcmVuZGVyVGFyZ2V0VWlkXSA9IG1hc2tTdGFja0luZGV4O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX21hc2tTdGFja0hhc2ggPSBudWxsO1xuICAgIHRoaXMuX21hc2tIYXNoID0gbnVsbDtcbiAgfVxufVxuU3RlbmNpbE1hc2tQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJzdGVuY2lsTWFza1wiXG59O1xuXG5leHBvcnQgeyBTdGVuY2lsTWFza1BpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZW5jaWxNYXNrUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX0JhY2tncm91bmRTeXN0ZW0gPSBjbGFzcyBfQmFja2dyb3VuZFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwKTtcbiAgICB0aGlzLmNvbG9yID0gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuICB9XG4gIC8qKlxuICAgKiBpbml0aWF0ZXMgdGhlIGJhY2tncm91bmQgc3lzdGVtXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIG9wdGlvbnMgZm9yIHRoZSBiYWNrZ3JvdW5kIGNvbG9yc1xuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0JhY2tncm91bmRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcbiAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kIHx8IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGE7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldEFscGhhKG9wdGlvbnMuYmFja2dyb3VuZEFscGhhKTtcbiAgfVxuICAvKiogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnQgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgY29uc3QgaW5jb21pbmcgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpO1xuICAgIGlmIChpbmNvbWluZy5hbHBoYSA8IDEgJiYgdGhpcy5fYmFja2dyb3VuZENvbG9yLmFscGhhID09PSAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkNhbm5vdCBzZXQgYSB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIG9uIGFuIG9wYXF1ZSBjYW52YXMuIFRvIGVuYWJsZSB0cmFuc3BhcmVuY3ksIHNldCBiYWNrZ3JvdW5kQWxwaGEgPCAxIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgQXBwbGljYXRpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgLyoqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFscGhhLiBTZXR0aW5nIHRoaXMgdG8gMCB3aWxsIG1ha2UgdGhlIGNhbnZhcyB0cmFuc3BhcmVudC4gKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IuYWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldEFscGhhKHZhbHVlKTtcbiAgfVxuICAvKiogVGhlIGJhY2tncm91bmQgY29sb3IgYXMgYW4gW1IsIEcsIEIsIEFdIGFycmF5LiAqL1xuICBnZXQgY29sb3JSZ2JhKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IudG9BcnJheSgpO1xuICB9XG4gIC8qKlxuICAgKiBkZXN0cm95cyB0aGUgYmFja2dyb3VuZCBzeXN0ZW1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkZXN0cm95KCkge1xuICB9XG59O1xuLyoqIEBpZ25vcmUgKi9cbl9CYWNrZ3JvdW5kU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJiYWNrZ3JvdW5kXCIsXG4gIHByaW9yaXR5OiAwXG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyB1c2VkIGJ5IHRoZSBzeXN0ZW0gKi9cbl9CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGF9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGJhY2tncm91bmRBbHBoYTogMSxcbiAgLyoqXG4gICAqIHtAbGluayBXZWJHTE9wdGlvbnMuYmFja2dyb3VuZENvbG9yfVxuICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgKi9cbiAgYmFja2dyb3VuZENvbG9yOiAwLFxuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWVcbn07XG5sZXQgQmFja2dyb3VuZFN5c3RlbSA9IF9CYWNrZ3JvdW5kU3lzdGVtO1xuXG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEZpbHRlckVmZmVjdCB9IGZyb20gJy4uLy4uLy4uLy4uL2ZpbHRlcnMvRmlsdGVyRWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJHcm91cCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IEJMRU5EX01PREVfRklMVEVSUyA9IHt9O1xuZXh0ZW5zaW9ucy5oYW5kbGUoRXh0ZW5zaW9uVHlwZS5CbGVuZE1vZGUsICh2YWx1ZSkgPT4ge1xuICBpZiAoIXZhbHVlLm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbGVuZE1vZGUgZXh0ZW5zaW9uIG11c3QgaGF2ZSBhIG5hbWUgcHJvcGVydHlcIik7XG4gIH1cbiAgQkxFTkRfTU9ERV9GSUxURVJTW3ZhbHVlLm5hbWVdID0gdmFsdWUucmVmO1xufSwgKHZhbHVlKSA9PiB7XG4gIGRlbGV0ZSBCTEVORF9NT0RFX0ZJTFRFUlNbdmFsdWUubmFtZV07XG59KTtcbmNsYXNzIEJsZW5kTW9kZVBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2JsZW5kTW9kZVN0YWNrID0gW107XG4gICAgdGhpcy5faXNBZHZhbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbHRlckhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJ1bm5lcnMucHJlcmVuZGVyLmFkZCh0aGlzKTtcbiAgfVxuICBwcmVyZW5kZXIoKSB7XG4gICAgdGhpcy5fYWN0aXZlQmxlbmRNb2RlID0gXCJub3JtYWxcIjtcbiAgICB0aGlzLl9pc0FkdmFuY2VkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2ggYSBibGVuZCBtb2RlIG9udG8gdGhlIGludGVybmFsIHN0YWNrIGFuZCBhcHBseSBpdCB0byB0aGUgaW5zdHJ1Y3Rpb24gc2V0IGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHJlbmRlcmFibGUgLSBUaGUgcmVuZGVyYWJsZSBvciB7QGxpbmsgUmVuZGVyR3JvdXB9IGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhbmdlLlxuICAgKiBAcGFyYW0gYmxlbmRNb2RlIC0gVGhlIGJsZW5kIG1vZGUgdG8gYWN0aXZhdGUuXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvblNldCAtIFRoZSBpbnN0cnVjdGlvbiBzZXQgYmVpbmcgYnVpbHQuXG4gICAqL1xuICBwdXNoQmxlbmRNb2RlKHJlbmRlcmFibGUsIGJsZW5kTW9kZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9ibGVuZE1vZGVTdGFjay5wdXNoKGJsZW5kTW9kZSk7XG4gICAgdGhpcy5zZXRCbGVuZE1vZGUocmVuZGVyYWJsZSwgYmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcCB0aGUgbGFzdCBibGVuZCBtb2RlIGZyb20gdGhlIHN0YWNrIGFuZCBhcHBseSB0aGUgbmV3IHRvcC1vZi1zdGFjayBtb2RlLlxuICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25TZXQgLSBUaGUgaW5zdHJ1Y3Rpb24gc2V0IGJlaW5nIGJ1aWx0LlxuICAgKi9cbiAgcG9wQmxlbmRNb2RlKGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fYmxlbmRNb2RlU3RhY2sucG9wKCk7XG4gICAgY29uc3QgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlU3RhY2tbdGhpcy5fYWN0aXZlQmxlbmRNb2RlLmxlbmd0aCAtIDFdID8/IFwibm9ybWFsXCI7XG4gICAgdGhpcy5zZXRCbGVuZE1vZGUobnVsbCwgYmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZSBhIGJsZW5kIG1vZGUgc3dpdGNoIGlzIGFkZGVkIHRvIHRoZSBpbnN0cnVjdGlvbiBzZXQgd2hlbiB0aGUgbW9kZSBjaGFuZ2VzLlxuICAgKiBJZiBhbiBhZHZhbmNlZCBibGVuZCBtb2RlIGlzIGFjdGl2ZSwgc3Vic2VxdWVudCByZW5kZXJhYmxlcyB3aWxsIGJlIGNvbGxlY3RlZCBzbyB0aGV5IGNhbiBiZVxuICAgKiByZW5kZXJlZCB3aXRoaW4gYSBzaW5nbGUgZmlsdGVyIHBhc3MuXG4gICAqIEBwYXJhbSByZW5kZXJhYmxlIC0gVGhlIHJlbmRlcmFibGUgb3Ige0BsaW5rIFJlbmRlckdyb3VwfSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY2hhbmdlLCBvciBudWxsIHdoZW4gdW53aW5kaW5nLlxuICAgKiBAcGFyYW0gYmxlbmRNb2RlIC0gVGhlIHRhcmdldCBibGVuZCBtb2RlLlxuICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25TZXQgLSBUaGUgaW5zdHJ1Y3Rpb24gc2V0IGJlaW5nIGJ1aWx0LlxuICAgKi9cbiAgc2V0QmxlbmRNb2RlKHJlbmRlcmFibGUsIGJsZW5kTW9kZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBpc1JlbmRlckdyb3VwID0gcmVuZGVyYWJsZSBpbnN0YW5jZW9mIFJlbmRlckdyb3VwO1xuICAgIGlmICh0aGlzLl9hY3RpdmVCbGVuZE1vZGUgPT09IGJsZW5kTW9kZSkge1xuICAgICAgaWYgKHRoaXMuX2lzQWR2YW5jZWQgJiYgcmVuZGVyYWJsZSAmJiAhaXNSZW5kZXJHcm91cCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJhYmxlTGlzdD8ucHVzaChyZW5kZXJhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzQWR2YW5jZWQpXG4gICAgICB0aGlzLl9lbmRBZHZhbmNlZEJsZW5kTW9kZShpbnN0cnVjdGlvblNldCk7XG4gICAgdGhpcy5fYWN0aXZlQmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIGlmICghcmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc0FkdmFuY2VkID0gISFCTEVORF9NT0RFX0ZJTFRFUlNbYmxlbmRNb2RlXTtcbiAgICBpZiAodGhpcy5faXNBZHZhbmNlZClcbiAgICAgIHRoaXMuX2JlZ2luQWR2YW5jZWRCbGVuZE1vZGUocmVuZGVyYWJsZSwgaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIF9iZWdpbkFkdmFuY2VkQmxlbmRNb2RlKHJlbmRlcmFibGUsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGNvbnN0IGJsZW5kTW9kZSA9IHRoaXMuX2FjdGl2ZUJsZW5kTW9kZTtcbiAgICBpZiAoIUJMRU5EX01PREVfRklMVEVSU1tibGVuZE1vZGVdKSB7XG4gICAgICB3YXJuKGBVbmFibGUgdG8gYXNzaWduIEJsZW5kTW9kZTogJyR7YmxlbmRNb2RlfScuIFlvdSBtYXkgd2FudCB0byBpbmNsdWRlOiBpbXBvcnQgJ3BpeGkuanMvYWR2YW5jZWQtYmxlbmQtbW9kZXMnYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckVmZmVjdCA9IHRoaXMuX2Vuc3VyZUZpbHRlckVmZmVjdChibGVuZE1vZGUpO1xuICAgIGNvbnN0IGlzUmVuZGVyR3JvdXAgPSByZW5kZXJhYmxlIGluc3RhbmNlb2YgUmVuZGVyR3JvdXA7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiZmlsdGVyXCIsXG4gICAgICBhY3Rpb246IFwicHVzaEZpbHRlclwiLFxuICAgICAgZmlsdGVyRWZmZWN0LFxuICAgICAgcmVuZGVyYWJsZXM6IGlzUmVuZGVyR3JvdXAgPyBudWxsIDogW3JlbmRlcmFibGVdLFxuICAgICAgY29udGFpbmVyOiBpc1JlbmRlckdyb3VwID8gcmVuZGVyYWJsZS5yb290IDogbnVsbCxcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuX3JlbmRlcmFibGVMaXN0ID0gaW5zdHJ1Y3Rpb24ucmVuZGVyYWJsZXM7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGluc3RydWN0aW9uKTtcbiAgfVxuICBfZW5zdXJlRmlsdGVyRWZmZWN0KGJsZW5kTW9kZSkge1xuICAgIGxldCBmaWx0ZXJFZmZlY3QgPSB0aGlzLl9maWx0ZXJIYXNoW2JsZW5kTW9kZV07XG4gICAgaWYgKCFmaWx0ZXJFZmZlY3QpIHtcbiAgICAgIGZpbHRlckVmZmVjdCA9IHRoaXMuX2ZpbHRlckhhc2hbYmxlbmRNb2RlXSA9IG5ldyBGaWx0ZXJFZmZlY3QoKTtcbiAgICAgIGZpbHRlckVmZmVjdC5maWx0ZXJzID0gW25ldyBCTEVORF9NT0RFX0ZJTFRFUlNbYmxlbmRNb2RlXSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlckVmZmVjdDtcbiAgfVxuICBfZW5kQWR2YW5jZWRCbGVuZE1vZGUoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9pc0FkdmFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVuZGVyYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcImZpbHRlclwiLFxuICAgICAgYWN0aW9uOiBcInBvcEZpbHRlclwiLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsZWQgd2hlbiB0aGUgaW5zdHJ1Y3Rpb24gYnVpbGQgcHJvY2VzcyBpcyBzdGFydGluZyB0aGlzIHdpbGwgcmVzZXQgaW50ZXJuYWxseSB0byB0aGUgZGVmYXVsdCBibGVuZCBtb2RlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYnVpbGRTdGFydCgpIHtcbiAgICB0aGlzLl9pc0FkdmFuY2VkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxlZCB3aGVuIHRoZSBpbnN0cnVjdGlvbiBidWlsZCBwcm9jZXNzIGlzIGZpbmlzaGVkLCBlbnN1cmluZyB0aGF0IGlmIHRoZXJlIGlzIGFuIGFkdmFuY2VkIGJsZW5kIG1vZGVcbiAgICogYWN0aXZlLCB3ZSBhZGQgdGhlIGZpbmFsIHJlbmRlciBpbnN0cnVjdGlvbnMgYWRkZWQgdG8gdGhlIGluc3RydWN0aW9uIHNldFxuICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25TZXQgLSBUaGUgaW5zdHJ1Y3Rpb24gc2V0IHdlIGFyZSBhZGRpbmcgdG9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBidWlsZEVuZChpbnN0cnVjdGlvblNldCkge1xuICAgIGlmICghdGhpcy5faXNBZHZhbmNlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9lbmRBZHZhbmNlZEJsZW5kTW9kZShpbnN0cnVjdGlvblNldCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJhYmxlTGlzdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2ZpbHRlckhhc2gpIHtcbiAgICAgIHRoaXMuX2ZpbHRlckhhc2hbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9maWx0ZXJIYXNoID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkJsZW5kTW9kZVBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImJsZW5kTW9kZVwiXG59O1xuXG5leHBvcnQgeyBCbGVuZE1vZGVQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbGVuZE1vZGVQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgaW1hZ2VUeXBlcyA9IHtcbiAgcG5nOiBcImltYWdlL3BuZ1wiLFxuICBqcGc6IFwiaW1hZ2UvanBlZ1wiLFxuICB3ZWJwOiBcImltYWdlL3dlYnBcIlxufTtcbmNvbnN0IF9FeHRyYWN0U3lzdGVtID0gY2xhc3MgX0V4dHJhY3RTeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIF9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzID0ge30pIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lciB8fCBvcHRpb25zIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBvcHRpb25zLFxuICAgICAgICAuLi5kZWZhdWx0c1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSUltYWdlIGZyb20gYSBkaXNwbGF5IG9iamVjdCBvciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBpbWFnZSwgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBnZW5lcmF0ZWQgSUltYWdlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEJhc2ljIHVzYWdlIHdpdGggYSBzcHJpdGVcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCByZW5kZXJlci5leHRyYWN0LmltYWdlKHNwcml0ZSk7XG4gICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgKlxuICAgKiAvLyBBZHZhbmNlZCB1c2FnZSB3aXRoIG9wdGlvbnNcbiAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCByZW5kZXJlci5leHRyYWN0LmltYWdlKHtcbiAgICogICAgIHRhcmdldDogY29udGFpbmVyLFxuICAgKiAgICAgZm9ybWF0OiAnd2VicCcsXG4gICAqICAgICBxdWFsaXR5OiAwLjgsXG4gICAqICAgICBmcmFtZTogbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCksXG4gICAqICAgICByZXNvbHV0aW9uOiAyLFxuICAgKiAgICAgY2xlYXJDb2xvcjogJyNmZjAwMDAnLFxuICAgKiAgICAgYW50aWFsaWFzOiB0cnVlXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBFeHRyYWN0IGRpcmVjdGx5IGZyb20gYSB0ZXh0dXJlXG4gICAqIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oJ215VGV4dHVyZS5wbmcnKTtcbiAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCByZW5kZXJlci5leHRyYWN0LmltYWdlKHRleHR1cmUpO1xuICAgKiBgYGBcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdEltYWdlT3B0aW9uc30gRm9yIGRldGFpbGVkIG9wdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5iYXNlNjR9IEZvciBiYXNlNjQgc3RyaW5nIG91dHB1dFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0U3lzdGVtLmNhbnZhc30gRm9yIGNhbnZhcyBvdXRwdXRcbiAgICogQHNlZSB7QGxpbmsgSW1hZ2VMaWtlfSBGb3IgdGhlIGltYWdlIGludGVyZmFjZVxuICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAqL1xuICBhc3luYyBpbWFnZShvcHRpb25zKSB7XG4gICAgY29uc3QgaW1hZ2UgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gYXdhaXQgdGhpcy5iYXNlNjQob3B0aW9ucyk7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGFyZ2V0IGludG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdvcmtzIGJ5IGZpcnN0IGNyZWF0aW5nXG4gICAqIGEgY2FudmFzIHVzaW5nIGBFeHRyYWN0LmNhbnZhc2AgYW5kIHRoZW4gY29udmVydGluZyBpdCB0byBhIGJhc2U2NCBzdHJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBiYXNlNjQgc3RyaW5nLCBvciB0aGUgdGFyZ2V0IHRvIGV4dHJhY3RcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyB1c2FnZSB3aXRoIGEgc3ByaXRlXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIGNvbnN0IGJhc2U2NCA9IGF3YWl0IHJlbmRlcmVyLmV4dHJhY3QuYmFzZTY0KHNwcml0ZSk7XG4gICAqIGNvbnNvbGUubG9nKGJhc2U2NCk7IC8vIGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwuLi5cbiAgICpcbiAgICogLy8gQWR2YW5jZWQgdXNhZ2Ugd2l0aCBvcHRpb25zXG4gICAqIGNvbnN0IGJhc2U2NCA9IGF3YWl0IHJlbmRlcmVyLmV4dHJhY3QuYmFzZTY0KHtcbiAgICogICAgIHRhcmdldDogY29udGFpbmVyLFxuICAgKiAgICAgZm9ybWF0OiAnd2VicCcsXG4gICAqICAgICBxdWFsaXR5OiAwLjgsXG4gICAqICAgICBmcmFtZTogbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCksXG4gICAqICAgICByZXNvbHV0aW9uOiAyXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBwbGF0Zm9ybSBkb2Vzbid0IHN1cHBvcnQgYW55IG9mOlxuICAgKiAtIElDYW52YXMudG9EYXRhVVJMXG4gICAqIC0gSUNhbnZhcy50b0Jsb2JcbiAgICogLSBJQ2FudmFzLmNvbnZlcnRUb0Jsb2JcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdEltYWdlT3B0aW9uc30gRm9yIGRldGFpbGVkIG9wdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5jYW52YXN9IEZvciBjYW52YXMgb3V0cHV0XG4gICAqIEBzZWUge0BsaW5rIEV4dHJhY3RTeXN0ZW0uaW1hZ2V9IEZvciBIVE1MSW1hZ2Ugb3V0cHV0XG4gICAqIEBjYXRlZ29yeSByZW5kZXJpbmdcbiAgICovXG4gIGFzeW5jIGJhc2U2NChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX25vcm1hbGl6ZU9wdGlvbnMoXG4gICAgICBvcHRpb25zLFxuICAgICAgX0V4dHJhY3RTeXN0ZW0uZGVmYXVsdEltYWdlT3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgeyBmb3JtYXQsIHF1YWxpdHkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXMob3B0aW9ucyk7XG4gICAgaWYgKGNhbnZhcy50b0Jsb2IgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICAgIGlmICghYmxvYikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIklDYW52YXMudG9CbG9iIGZhaWxlZCFcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgICB9LCBpbWFnZVR5cGVzW2Zvcm1hdF0sIHF1YWxpdHkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjYW52YXMudG9EYXRhVVJMICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKGltYWdlVHlwZXNbZm9ybWF0XSwgcXVhbGl0eSk7XG4gICAgfVxuICAgIGlmIChjYW52YXMuY29udmVydFRvQmxvYiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyB0eXBlOiBpbWFnZVR5cGVzW2Zvcm1hdF0sIHF1YWxpdHkgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QuYmFzZTY0KCkgcmVxdWlyZXMgSUNhbnZhcy50b0RhdGFVUkwsIElDYW52YXMudG9CbG9iLCBvciBJQ2FudmFzLmNvbnZlcnRUb0Jsb2IgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCwgcmVuZGVycyB0aGUgdGFyZ2V0IHRvIGl0IGFuZCByZXR1cm5zIGl0LlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIHN0YXRpYyBpbWFnZXMgb3Igd2hlbiB5b3UgbmVlZCBkaXJlY3QgY2FudmFzIGFjY2Vzcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGNhbnZhcywgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIEEgQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgdGV4dHVyZSByZW5kZXJlZCBvblxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyBjYW52YXMgZXh0cmFjdGlvbiBmcm9tIGEgc3ByaXRlXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIGNvbnN0IGNhbnZhcyA9IHJlbmRlcmVyLmV4dHJhY3QuY2FudmFzKHNwcml0ZSk7XG4gICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICpcbiAgICogLy8gRXh0cmFjdCB3aXRoIGN1c3RvbSByZWdpb25cbiAgICogY29uc3QgY2FudmFzID0gcmVuZGVyZXIuZXh0cmFjdC5jYW52YXMoe1xuICAgKiAgICAgdGFyZ2V0OiBjb250YWluZXIsXG4gICAqICAgICBmcmFtZTogbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMClcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEV4dHJhY3Qgd2l0aCBoaWdoIHJlc29sdXRpb25cbiAgICogY29uc3QgY2FudmFzID0gcmVuZGVyZXIuZXh0cmFjdC5jYW52YXMoe1xuICAgKiAgICAgdGFyZ2V0OiBzcHJpdGUsXG4gICAqICAgICByZXNvbHV0aW9uOiAyLFxuICAgKiAgICAgY2xlYXJDb2xvcjogJyNmZjAwMDAnXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBFeHRyYWN0IGRpcmVjdGx5IGZyb20gYSB0ZXh0dXJlXG4gICAqIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oJ215VGV4dHVyZS5wbmcnKTtcbiAgICogY29uc3QgY2FudmFzID0gcmVuZGVyZXIuZXh0cmFjdC5jYW52YXModGV4dHVyZSk7XG4gICAqXG4gICAqIC8vIEV4dHJhY3Qgd2l0aCBhbnRpLWFsaWFzaW5nXG4gICAqIGNvbnN0IGNhbnZhcyA9IHJlbmRlcmVyLmV4dHJhY3QuY2FudmFzKHtcbiAgICogICAgIHRhcmdldDogZ3JhcGhpY3MsXG4gICAqICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0T3B0aW9uc30gRm9yIGRldGFpbGVkIG9wdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5pbWFnZX0gRm9yIEhUTUxJbWFnZSBvdXRwdXRcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5waXhlbHN9IEZvciByYXcgcGl4ZWwgZGF0YVxuICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAqL1xuICBjYW52YXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci50ZXh0dXJlLmdlbmVyYXRlQ2FudmFzKHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSByZW5kZXJlci50ZXh0dXJlR2VuZXJhdG9yLmdlbmVyYXRlVGV4dHVyZShvcHRpb25zKTtcbiAgICBjb25zdCBjYW52YXMgPSByZW5kZXJlci50ZXh0dXJlLmdlbmVyYXRlQ2FudmFzKHRleHR1cmUpO1xuICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlIGluIFJHQkEgb3JkZXIsXG4gICAqIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1c2l2ZSkuXG4gICAqID4gWyFOT0VdIFRoZSByZXR1cm5lZCBhcnJheSBpcyBhIGZsYXQgVWludDhBcnJheSB3aGVyZSBldmVyeSA0IHZhbHVlcyByZXByZXNlbnQgUkdCQVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBleHRyYWN0aW5nIHRoZSBpbWFnZSwgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIE9uZS1kaW1lbnNpb25hbCBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgaW4gUkdCQSBmb3JtYXRcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gQmFzaWMgcGl4ZWwgZXh0cmFjdGlvblxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICAgKiBjb25zdCBwaXhlbHMgPSByZW5kZXJlci5leHRyYWN0LnBpeGVscyhzcHJpdGUpO1xuICAgKiBjb25zb2xlLmxvZyhwaXhlbHNbMF0sIHBpeGVsc1sxXSwgcGl4ZWxzWzJdLCBwaXhlbHNbM10pOyAvLyBSLEcsQixBIHZhbHVlc1xuICAgKlxuICAgKiAvLyBFeHRyYWN0IHdpdGggY3VzdG9tIHJlZ2lvblxuICAgKiBjb25zdCBwaXhlbHMgPSByZW5kZXJlci5leHRyYWN0LnBpeGVscyh7XG4gICAqICAgICB0YXJnZXQ6IHNwcml0ZSxcbiAgICogICAgIGZyYW1lOiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gRXh0cmFjdCB3aXRoIGhpZ2ggcmVzb2x1dGlvblxuICAgKiBjb25zdCBwaXhlbHMgPSByZW5kZXJlci5leHRyYWN0LnBpeGVscyh7XG4gICAqICAgICB0YXJnZXQ6IHNwcml0ZSxcbiAgICogICAgIHJlc29sdXRpb246IDJcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0T3B0aW9uc30gRm9yIGRldGFpbGVkIG9wdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5jYW52YXN9IEZvciBjYW52YXMgb3V0cHV0XG4gICAqIEBzZWUge0BsaW5rIEV4dHJhY3RTeXN0ZW0uaW1hZ2V9IEZvciBpbWFnZSBvdXRwdXRcbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgcGl4ZWxzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0YXJnZXQgaW5zdGFuY2VvZiBUZXh0dXJlID8gdGFyZ2V0IDogcmVuZGVyZXIudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUob3B0aW9ucyk7XG4gICAgY29uc3QgcGl4ZWxJbmZvID0gcmVuZGVyZXIudGV4dHVyZS5nZXRQaXhlbHModGV4dHVyZSk7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGEgZGlzcGxheSBvYmplY3Qgb3IgZXhpc3RpbmcgdGV4dHVyZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nXG4gICAqIHJldXNhYmxlIHRleHR1cmVzIGZyb20gcmVuZGVyZWQgY29udGVudCBvciBtYWtpbmcgY29waWVzIG9mIGV4aXN0aW5nIHRleHR1cmVzLlxuICAgKiA+IFshTk9URV0gVGhlIHJldHVybmVkIHRleHR1cmUgc2hvdWxkIGJlIGRlc3Ryb3llZCB3aGVuIG5vIGxvbmdlciBuZWVkZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHRleHR1cmUsIG9yIHRoZSB0YXJnZXQgdG8gZXh0cmFjdFxuICAgKiBAcmV0dXJucyBBIG5ldyB0ZXh0dXJlIGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBjb250ZW50XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEJhc2ljIHRleHR1cmUgZXh0cmFjdGlvbiBmcm9tIGEgc3ByaXRlXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIGNvbnN0IGV4dHJhY3RlZFRleHR1cmUgPSByZW5kZXJlci5leHRyYWN0LnRleHR1cmUoc3ByaXRlKTtcbiAgICpcbiAgICogLy8gRXh0cmFjdCB3aXRoIGN1c3RvbSByZWdpb25cbiAgICogY29uc3QgcmVnaW9uVGV4dHVyZSA9IHJlbmRlcmVyLmV4dHJhY3QudGV4dHVyZSh7XG4gICAqICAgICB0YXJnZXQ6IGNvbnRhaW5lcixcbiAgICogICAgIGZyYW1lOiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gRXh0cmFjdCB3aXRoIGhpZ2ggcmVzb2x1dGlvblxuICAgKiBjb25zdCBoaVJlc1RleHR1cmUgPSByZW5kZXJlci5leHRyYWN0LnRleHR1cmUoe1xuICAgKiAgICAgdGFyZ2V0OiBzcHJpdGUsXG4gICAqICAgICByZXNvbHV0aW9uOiAyLFxuICAgKiAgICAgY2xlYXJDb2xvcjogJyNmZjAwMDAnXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBuZXcgc3ByaXRlIGZyb20gZXh0cmFjdGVkIHRleHR1cmVcbiAgICogY29uc3QgbmV3U3ByaXRlID0gbmV3IFNwcml0ZShcbiAgICogICAgIHJlbmRlcmVyLmV4dHJhY3QudGV4dHVyZSh7XG4gICAqICAgICAgICAgdGFyZ2V0OiBncmFwaGljcyxcbiAgICogICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICogICAgIH0pXG4gICAqICk7XG4gICAqXG4gICAqIC8vIENsZWFuIHVwIHdoZW4gZG9uZVxuICAgKiBleHRyYWN0ZWRUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAqIGBgYFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0T3B0aW9uc30gRm9yIGRldGFpbGVkIG9wdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgVGV4dHVyZX0gRm9yIHRleHR1cmUgbWFuYWdlbWVudFxuICAgKiBAc2VlIHtAbGluayBHZW5lcmF0ZVRleHR1cmVTeXN0ZW19IEZvciB0ZXh0dXJlIGdlbmVyYXRpb25cbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgdGV4dHVyZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX25vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgIHJldHVybiBvcHRpb25zLnRhcmdldDtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFuZCBkb3dubG9hZHMgY29udGVudCBmcm9tIHRoZSByZW5kZXJlciBhcyBhbiBpbWFnZSBmaWxlLlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVudCB3YXkgdG8gc2F2ZSBzY3JlZW5zaG90cyBvciBleHBvcnQgcmVuZGVyZWQgY29udGVudC5cbiAgICogPiBbIU5PVEVdIFRoZSBkb3dubG9hZCB3aWxsIHVzZSBQTkcgZm9ybWF0IHJlZ2FyZGxlc3Mgb2YgdGhlIGZpbGVuYW1lIGV4dGVuc2lvblxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkb3dubG9hZGluZyBhbmQgZXh0cmFjdGluZyB0aGUgaW1hZ2UsIG9yIHRoZSB0YXJnZXQgdG8gZXh0cmFjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyBkb3dubG9hZCB3aXRoIGRlZmF1bHQgZmlsZW5hbWVcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogcmVuZGVyZXIuZXh0cmFjdC5kb3dubG9hZChzcHJpdGUpOyAvLyBEb3dubG9hZHMgYXMgJ2ltYWdlLnBuZydcbiAgICpcbiAgICogLy8gRG93bmxvYWQgd2l0aCBjdXN0b20gZmlsZW5hbWVcbiAgICogcmVuZGVyZXIuZXh0cmFjdC5kb3dubG9hZCh7XG4gICAqICAgICB0YXJnZXQ6IHNwcml0ZSxcbiAgICogICAgIGZpbGVuYW1lOiAnc2NyZWVuc2hvdC5wbmcnXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBEb3dubG9hZCB3aXRoIGN1c3RvbSByZWdpb25cbiAgICogcmVuZGVyZXIuZXh0cmFjdC5kb3dubG9hZCh7XG4gICAqICAgICB0YXJnZXQ6IGNvbnRhaW5lcixcbiAgICogICAgIGZpbGVuYW1lOiAncmVnaW9uLnBuZycsXG4gICAqICAgICBmcmFtZTogbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMClcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIERvd25sb2FkIHdpdGggaGlnaCByZXNvbHV0aW9uIGFuZCBiYWNrZ3JvdW5kXG4gICAqIHJlbmRlcmVyLmV4dHJhY3QuZG93bmxvYWQoe1xuICAgKiAgICAgdGFyZ2V0OiBzdGFnZSxcbiAgICogICAgIGZpbGVuYW1lOiAnaGQtc2NyZWVuc2hvdC5wbmcnLFxuICAgKiAgICAgcmVzb2x1dGlvbjogMixcbiAgICogICAgIGNsZWFyQ29sb3I6ICcjZmYwMDAwJ1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gRG93bmxvYWQgd2l0aCBhbnRpLWFsaWFzaW5nXG4gICAqIHJlbmRlcmVyLmV4dHJhY3QuZG93bmxvYWQoe1xuICAgKiAgICAgdGFyZ2V0OiBncmFwaGljcyxcbiAgICogICAgIGZpbGVuYW1lOiAnc21vb3RoLnBuZycsXG4gICAqICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0RG93bmxvYWRPcHRpb25zfSBGb3IgZGV0YWlsZWQgb3B0aW9uc1xuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0U3lzdGVtLmltYWdlfSBGb3IgY3JlYXRpbmcgaW1hZ2VzIHdpdGhvdXQgZG93bmxvYWRcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5jYW52YXN9IEZvciBjYW52YXMgb3V0cHV0XG4gICAqIEBjYXRlZ29yeSByZW5kZXJpbmdcbiAgICovXG4gIGRvd25sb2FkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcyhvcHRpb25zKTtcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5kb3dubG9hZCA9IG9wdGlvbnMuZmlsZW5hbWUgPz8gXCJpbWFnZS5wbmdcIjtcbiAgICBsaW5rLmhyZWYgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gIH1cbiAgLyoqXG4gICAqIExvZ3MgdGhlIHRhcmdldCB0byB0aGUgY29uc29sZSBhcyBhbiBpbWFnZS4gVGhpcyBpcyBhIHVzZWZ1bCB3YXkgdG8gZGVidWcgd2hhdCdzIGhhcHBlbmluZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAqIFRoZSBpbWFnZSB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgYnJvd3NlcidzIGNvbnNvbGUgdXNpbmcgQ1NTIGJhY2tncm91bmQgaW1hZ2VzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBsb2dnaW5nIHRoZSBpbWFnZSwgb3IgdGhlIHRhcmdldCB0byBsb2dcbiAgICogQHBhcmFtIG9wdGlvbnMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGxvZ2dlZCBpbWFnZSBwcmV2aWV3IGluIHRoZSBjb25zb2xlIChpbiBwaXhlbHMpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEJhc2ljIHVzYWdlXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHJlbmRlcmVyLmV4dHJhY3QubG9nKHNwcml0ZSk7XG4gICAqIGBgYFxuICAgKiBAc2VlIHtAbGluayBFeHRyYWN0U3lzdGVtLmNhbnZhc30gRm9yIGdldHRpbmcgcmF3IGNhbnZhcyBvdXRwdXRcbiAgICogQHNlZSB7QGxpbmsgRXh0cmFjdFN5c3RlbS5waXhlbHN9IEZvciByYXcgcGl4ZWwgZGF0YVxuICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAqIEBhZHZhbmNlZFxuICAgKi9cbiAgbG9nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggPz8gMjAwO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGJhc2U2NCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICBjb25zb2xlLmxvZyhgW1BpeGkgVGV4dHVyZV0gJHtjYW52YXMud2lkdGh9cHggJHtjYW52YXMuaGVpZ2h0fXB4YCk7XG4gICAgY29uc3Qgc3R5bGUgPSBbXG4gICAgICBcImZvbnQtc2l6ZTogMXB4O1wiLFxuICAgICAgYHBhZGRpbmc6ICR7d2lkdGh9cHggJHszMDB9cHg7YCxcbiAgICAgIGBiYWNrZ3JvdW5kOiB1cmwoJHtiYXNlNjR9KSBuby1yZXBlYXQ7YCxcbiAgICAgIFwiYmFja2dyb3VuZC1zaXplOiBjb250YWluO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiLCBzdHlsZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0V4dHJhY3RTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImV4dHJhY3RcIlxufTtcbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBpbWFnZSBleHRyYWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAvLyBDdXN0b21pemUgZGVmYXVsdCBvcHRpb25zXG4gKiBFeHRyYWN0U3lzdGVtLmRlZmF1bHRJbWFnZU9wdGlvbnMuZm9ybWF0ID0gJ3dlYnAnO1xuICogRXh0cmFjdFN5c3RlbS5kZWZhdWx0SW1hZ2VPcHRpb25zLnF1YWxpdHkgPSAwLjg7XG4gKlxuICogLy8gVXNlIGRlZmF1bHRzXG4gKiBjb25zdCBpbWFnZSA9IGF3YWl0IHJlbmRlcmVyLmV4dHJhY3QuaW1hZ2Uoc3ByaXRlKTtcbiAqIGBgYFxuICovXG5fRXh0cmFjdFN5c3RlbS5kZWZhdWx0SW1hZ2VPcHRpb25zID0ge1xuICBmb3JtYXQ6IFwicG5nXCIsXG4gIHF1YWxpdHk6IDFcbn07XG5sZXQgRXh0cmFjdFN5c3RlbSA9IF9FeHRyYWN0U3lzdGVtO1xuXG5leHBvcnQgeyBFeHRyYWN0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyYWN0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRMb2NhbEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0TG9jYWxCb3VuZHMubWpzJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9Db250YWluZXIubWpzJztcbmltcG9ydCB7IFJlbmRlclRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlL1JlbmRlclRleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wUmVjdCA9IG5ldyBSZWN0YW5nbGUoKTtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5jb25zdCBub0NvbG9yID0gWzAsIDAsIDAsIDBdO1xuY2xhc3MgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGEgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgc3ByaXRlcyBhbmQgb3RoZXIgdGV4dHVyZXMuXG4gICAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igb3B0aW1pemluZyBwZXJmb3JtYW5jZSB3aGVuIGEgY29tcGxleCBjb250YWluZXIgbmVlZHMgdG8gYmUgcmV1c2VkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEdlbmVyYXRlIHRleHR1cmUgb3B0aW9ucyBvciBhIGNvbnRhaW5lciB0byBjb252ZXJ0IHRvIHRleHR1cmVcbiAgICogQHJldHVybnMgQSBuZXcgUmVuZGVyVGV4dHVyZSBjb250YWluaW5nIHRoZSByZW5kZXJlZCBkaXNwbGF5IG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyB1c2FnZSB3aXRoIGEgY29udGFpbmVyXG4gICAqIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcbiAgICogY29udGFpbmVyLmFkZENoaWxkKFxuICAgKiAgICAgbmV3IEdyYXBoaWNzKClcbiAgICogICAgICAgICAuY2lyY2xlKDAsIDAsIDUwKVxuICAgKiAgICAgICAgIC5maWxsKCdyZWQnKVxuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCB0ZXh0dXJlID0gcmVuZGVyZXIudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUoY29udGFpbmVyKTtcbiAgICpcbiAgICogLy8gQWR2YW5jZWQgdXNhZ2Ugd2l0aCBvcHRpb25zXG4gICAqIGNvbnN0IHRleHR1cmUgPSByZW5kZXJlci50ZXh0dXJlR2VuZXJhdG9yLmdlbmVyYXRlVGV4dHVyZSh7XG4gICAqICAgICB0YXJnZXQ6IGNvbnRhaW5lcixcbiAgICogICAgIGZyYW1lOiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKSwgLy8gU3BlY2lmaWMgcmVnaW9uXG4gICAqICAgICByZXNvbHV0aW9uOiAyLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZ2ggRFBJXG4gICAqICAgICBjbGVhckNvbG9yOiAnI2ZmMDAwMCcsICAgICAgICAgICAgICAgLy8gUmVkIGJhY2tncm91bmRcbiAgICogICAgIGFudGlhbGlhczogdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAvLyBTbW9vdGggZWRnZXNcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHNwcml0ZSBmcm9tIHRoZSBnZW5lcmF0ZWQgdGV4dHVyZVxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICAgKlxuICAgKiAvLyBDbGVhbiB1cCB3aGVuIGRvbmVcbiAgICogdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgKiBgYGBcbiAgICogQHNlZSB7QGxpbmsgR2VuZXJhdGVUZXh0dXJlT3B0aW9uc30gRm9yIGRldGFpbGVkIHRleHR1cmUgZ2VuZXJhdGlvbiBvcHRpb25zXG4gICAqIEBzZWUge0BsaW5rIFJlbmRlclRleHR1cmV9IEZvciB0aGUgdHlwZSBvZiB0ZXh0dXJlIGNyZWF0ZWRcbiAgICogQGNhdGVnb3J5IHJlbmRlcmluZ1xuICAgKi9cbiAgZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdGFyZ2V0OiBvcHRpb25zLFxuICAgICAgICBmcmFtZTogdm9pZCAwLFxuICAgICAgICB0ZXh0dXJlU291cmNlT3B0aW9uczoge30sXG4gICAgICAgIHJlc29sdXRpb246IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiB8fCB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGFudGlhbGlhcyA9IG9wdGlvbnMuYW50aWFsaWFzIHx8IHRoaXMuX3JlbmRlcmVyLnZpZXcuYW50aWFsaWFzO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIGxldCBjbGVhckNvbG9yID0gb3B0aW9ucy5jbGVhckNvbG9yO1xuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICBjb25zdCBpc1JHQkFBcnJheSA9IEFycmF5LmlzQXJyYXkoY2xlYXJDb2xvcikgJiYgY2xlYXJDb2xvci5sZW5ndGggPT09IDQ7XG4gICAgICBjbGVhckNvbG9yID0gaXNSR0JBQXJyYXkgPyBjbGVhckNvbG9yIDogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNsZWFyQ29sb3IpLnRvQXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJDb2xvciA9IG5vQ29sb3I7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbiA9IG9wdGlvbnMuZnJhbWU/LmNvcHlUbyh0ZW1wUmVjdCkgfHwgZ2V0TG9jYWxCb3VuZHMoY29udGFpbmVyLCB0ZW1wQm91bmRzKS5yZWN0YW5nbGU7XG4gICAgcmVnaW9uLndpZHRoID0gTWF0aC5tYXgocmVnaW9uLndpZHRoLCAxIC8gcmVzb2x1dGlvbikgfCAwO1xuICAgIHJlZ2lvbi5oZWlnaHQgPSBNYXRoLm1heChyZWdpb24uaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbikgfCAwO1xuICAgIGNvbnN0IHRhcmdldCA9IFJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICAgIC4uLm9wdGlvbnMudGV4dHVyZVNvdXJjZU9wdGlvbnMsXG4gICAgICB3aWR0aDogcmVnaW9uLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWdpb24uaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGFudGlhbGlhc1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IE1hdHJpeC5zaGFyZWQudHJhbnNsYXRlKC1yZWdpb24ueCwgLXJlZ2lvbi55KTtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXIoe1xuICAgICAgY29udGFpbmVyLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY2xlYXJDb2xvclxuICAgIH0pO1xuICAgIHRhcmdldC5zb3VyY2UudXBkYXRlTWlwbWFwcygpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HZW5lcmF0ZVRleHR1cmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInRleHR1cmVHZW5lcmF0b3JcIlxufTtcblxuZXhwb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xvYmFsVW5pZm9ybVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc3RhY2tJbmRleCA9IDA7XG4gICAgdGhpcy5fZ2xvYmFsVW5pZm9ybURhdGFTdGFjayA9IFtdO1xuICAgIHRoaXMuX3VuaWZvcm1zUG9vbCA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVVuaWZvcm1zID0gW107XG4gICAgdGhpcy5fYmluZEdyb3VwUG9vbCA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZUJpbmRHcm91cHMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3N0YWNrSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3VuaWZvcm1zUG9vbC5wdXNoKHRoaXMuX2FjdGl2ZVVuaWZvcm1zW2ldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVCaW5kR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9iaW5kR3JvdXBQb29sLnB1c2godGhpcy5fYWN0aXZlQmluZEdyb3Vwc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVVuaWZvcm1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fYWN0aXZlQmluZEdyb3Vwcy5sZW5ndGggPSAwO1xuICB9XG4gIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5wdXNoKG9wdGlvbnMpO1xuICB9XG4gIGJpbmQoe1xuICAgIHNpemUsXG4gICAgcHJvamVjdGlvbk1hdHJpeCxcbiAgICB3b3JsZFRyYW5zZm9ybU1hdHJpeCxcbiAgICB3b3JsZENvbG9yLFxuICAgIG9mZnNldFxuICB9KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldDtcbiAgICBjb25zdCBjdXJyZW50R2xvYmFsVW5pZm9ybURhdGEgPSB0aGlzLl9zdGFja0luZGV4ID8gdGhpcy5fZ2xvYmFsVW5pZm9ybURhdGFTdGFja1t0aGlzLl9zdGFja0luZGV4IC0gMV0gOiB7XG4gICAgICBwcm9qZWN0aW9uRGF0YTogcmVuZGVyVGFyZ2V0LFxuICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgIHdvcmxkQ29sb3I6IDQyOTQ5NjcyOTUsXG4gICAgICBvZmZzZXQ6IG5ldyBQb2ludCgpXG4gICAgfTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3JtRGF0YSA9IHtcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHByb2plY3Rpb25NYXRyaXggfHwgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgsXG4gICAgICByZXNvbHV0aW9uOiBzaXplIHx8IHJlbmRlclRhcmdldC5zaXplLFxuICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXg6IHdvcmxkVHJhbnNmb3JtTWF0cml4IHx8IGN1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YS53b3JsZFRyYW5zZm9ybU1hdHJpeCxcbiAgICAgIHdvcmxkQ29sb3I6IHdvcmxkQ29sb3IgfHwgY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLndvcmxkQ29sb3IsXG4gICAgICBvZmZzZXQ6IG9mZnNldCB8fCBjdXJyZW50R2xvYmFsVW5pZm9ybURhdGEub2Zmc2V0LFxuICAgICAgYmluZEdyb3VwOiBudWxsXG4gICAgfTtcbiAgICBjb25zdCB1bmlmb3JtR3JvdXAgPSB0aGlzLl91bmlmb3Jtc1Bvb2wucG9wKCkgfHwgdGhpcy5fY3JlYXRlVW5pZm9ybXMoKTtcbiAgICB0aGlzLl9hY3RpdmVVbmlmb3Jtcy5wdXNoKHVuaWZvcm1Hcm91cCk7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB1bmlmb3JtR3JvdXAudW5pZm9ybXM7XG4gICAgdW5pZm9ybXMudVByb2plY3Rpb25NYXRyaXggPSBnbG9iYWxVbmlmb3JtRGF0YS5wcm9qZWN0aW9uTWF0cml4O1xuICAgIHVuaWZvcm1zLnVSZXNvbHV0aW9uID0gZ2xvYmFsVW5pZm9ybURhdGEucmVzb2x1dGlvbjtcbiAgICB1bmlmb3Jtcy51V29ybGRUcmFuc2Zvcm1NYXRyaXguY29weUZyb20oZ2xvYmFsVW5pZm9ybURhdGEud29ybGRUcmFuc2Zvcm1NYXRyaXgpO1xuICAgIHVuaWZvcm1zLnVXb3JsZFRyYW5zZm9ybU1hdHJpeC50eCAtPSBnbG9iYWxVbmlmb3JtRGF0YS5vZmZzZXQueDtcbiAgICB1bmlmb3Jtcy51V29ybGRUcmFuc2Zvcm1NYXRyaXgudHkgLT0gZ2xvYmFsVW5pZm9ybURhdGEub2Zmc2V0Lnk7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdsb2JhbFVuaWZvcm1EYXRhLndvcmxkQ29sb3IsXG4gICAgICB1bmlmb3Jtcy51V29ybGRDb2xvckFscGhhLFxuICAgICAgMFxuICAgICk7XG4gICAgdW5pZm9ybUdyb3VwLnVwZGF0ZSgpO1xuICAgIGxldCBiaW5kR3JvdXA7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaCkge1xuICAgICAgYmluZEdyb3VwID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLmdldFVuaWZvcm1CaW5kR3JvdXAodW5pZm9ybUdyb3VwLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRHcm91cCA9IHRoaXMuX2JpbmRHcm91cFBvb2wucG9wKCkgfHwgbmV3IEJpbmRHcm91cCgpO1xuICAgICAgdGhpcy5fYWN0aXZlQmluZEdyb3Vwcy5wdXNoKGJpbmRHcm91cCk7XG4gICAgICBiaW5kR3JvdXAuc2V0UmVzb3VyY2UodW5pZm9ybUdyb3VwLCAwKTtcbiAgICB9XG4gICAgZ2xvYmFsVW5pZm9ybURhdGEuYmluZEdyb3VwID0gYmluZEdyb3VwO1xuICAgIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YSA9IGdsb2JhbFVuaWZvcm1EYXRhO1xuICB9XG4gIHB1c2gob3B0aW9ucykge1xuICAgIHRoaXMuYmluZChvcHRpb25zKTtcbiAgICB0aGlzLl9nbG9iYWxVbmlmb3JtRGF0YVN0YWNrW3RoaXMuX3N0YWNrSW5kZXgrK10gPSB0aGlzLl9jdXJyZW50R2xvYmFsVW5pZm9ybURhdGE7XG4gIH1cbiAgcG9wKCkge1xuICAgIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YSA9IHRoaXMuX2dsb2JhbFVuaWZvcm1EYXRhU3RhY2tbLS10aGlzLl9zdGFja0luZGV4IC0gMV07XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgdGhpcy5fY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLmJpbmRHcm91cC5yZXNvdXJjZXNbMF0udXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBiaW5kR3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YS5iaW5kR3JvdXA7XG4gIH1cbiAgZ2V0IGdsb2JhbFVuaWZvcm1EYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50R2xvYmFsVW5pZm9ybURhdGE7XG4gIH1cbiAgZ2V0IHVuaWZvcm1Hcm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLmJpbmRHcm91cC5yZXNvdXJjZXNbMF07XG4gIH1cbiAgX2NyZWF0ZVVuaWZvcm1zKCkge1xuICAgIGNvbnN0IGdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1UHJvamVjdGlvbk1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVXb3JsZFRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIC8vIFRPRE8gLSBzb21lb25lIHNtYXJ0IC0gc2V0IHRoaXMgdG8gYmUgYSB1bm9ybTh4NCByYXRoZXIgdGhhbiBhIHZlYzQ8ZjMyPlxuICAgICAgdVdvcmxkQ29sb3JBbHBoYTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVJlc29sdXRpb246IHsgdmFsdWU6IFswLCAwXSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgfSwge1xuICAgICAgaXNTdGF0aWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZ2xvYmFsVW5pZm9ybXM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fZ2xvYmFsVW5pZm9ybURhdGFTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3VuaWZvcm1zUG9vbC5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2FjdGl2ZVVuaWZvcm1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fYmluZEdyb3VwUG9vbC5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2FjdGl2ZUJpbmRHcm91cHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jdXJyZW50R2xvYmFsVW5pZm9ybURhdGEgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR2xvYmFsVW5pZm9ybVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiZ2xvYmFsVW5pZm9ybXNcIlxufTtcblxuZXhwb3J0IHsgR2xvYmFsVW5pZm9ybVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xvYmFsVW5pZm9ybVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi8uLi8uLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IHVpZCA9IDE7XG5jbGFzcyBTY2hlZHVsZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl90YXNrcyA9IFtdO1xuICAgIC8qKiBhIHNtYWxsIG9mZiBzZXQgdG8gYXBwbHkgdG8gdGhlIHJlcGVhdCBzY2hlZHVsZXMuIFRoaXMgaXMganVzdCB0byBtYWtlIHN1cmUgdGhleSBydW4gYXQgc2xpZ2h0bHkgZGlmZmVyZW50IHRpbWVzICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgfVxuICAvKiogSW5pdGlhbGl6ZXMgdGhlIHNjaGVkdWxlciBzeXN0ZW0gYW5kIHN0YXJ0cyB0aGUgdGlja2VyLiAqL1xuICBpbml0KCkge1xuICAgIFRpY2tlci5zeXN0ZW0uYWRkKHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIHJlcGVhdGluZyB0YXNrLlxuICAgKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgaW50ZXJ2YWwgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0gdXNlT2Zmc2V0IC0gdGhpcyB3aWxsIHNwcmVhZCBvdXQgdGFza3Mgc28gdGhhdCB0aGV5IGRvIG5vdCBhbGwgcnVuIGF0IHRoZSBzYW1lIHRpbWVcbiAgICogQHJldHVybnMgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2NoZWR1bGVkIHRhc2suXG4gICAqL1xuICByZXBlYXQoZnVuYywgZHVyYXRpb24sIHVzZU9mZnNldCA9IHRydWUpIHtcbiAgICBjb25zdCBpZCA9IHVpZCsrO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmICh1c2VPZmZzZXQpIHtcbiAgICAgIHRoaXMuX29mZnNldCArPSAxZTM7XG4gICAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3Rhc2tzLnB1c2goe1xuICAgICAgZnVuYyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgb2Zmc2V0LFxuICAgICAgbGFzdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICByZXBlYXQ6IHRydWUsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhIHNjaGVkdWxlZCB0YXNrLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhc2sgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsKGlkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3Rhc2tzW2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLl90YXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW5kIGV4ZWN1dGVzIHRoZSBzY2hlZHVsZWQgdGFza3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLl90YXNrc1tpXTtcbiAgICAgIGlmIChub3cgLSB0YXNrLm9mZnNldCAtIHRhc2subGFzdCA+PSB0YXNrLmR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSB0YXNrLnN0YXJ0O1xuICAgICAgICB0YXNrLmZ1bmMoZWxhcHNlZCk7XG4gICAgICAgIHRhc2subGFzdCA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBzY2hlZHVsZXIgc3lzdGVtIGFuZCByZW1vdmVzIGFsbCB0YXNrcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGFza3MubGVuZ3RoID0gMDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cblNjaGVkdWxlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic2NoZWR1bGVyXCIsXG4gIHByaW9yaXR5OiAwXG59O1xuXG5leHBvcnQgeyBTY2hlZHVsZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaGVkdWxlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgc2FpZEhlbGxvID0gZmFsc2U7XG5mdW5jdGlvbiBzYXlIZWxsbyh0eXBlKSB7XG4gIGlmIChzYWlkSGVsbG8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCkudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNocm9tZVwiKSA+IC0xKSB7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIGAlYyAgJWMgICVjICAlYyAgJWMgUGl4aUpTICVjIHYke1ZFUlNJT059ICgke3R5cGV9KSBodHRwOi8vd3d3LnBpeGlqcy5jb20vXG5cbmAsXG4gICAgICBcImJhY2tncm91bmQ6ICNFNzIyNjQ7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICM2Q0EyRUE7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICNCNUQzM0Q7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImJhY2tncm91bmQ6ICNGRUQyM0Y7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImNvbG9yOiAjRkZGRkZGOyBiYWNrZ3JvdW5kOiAjRTcyMjY0OyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJjb2xvcjogI0U3MjI2NDsgYmFja2dyb3VuZDogI0ZGRkZGRjsgcGFkZGluZzo1cHggMDtcIlxuICAgIF07XG4gICAgZ2xvYmFsVGhpcy5jb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgfSBlbHNlIGlmIChnbG9iYWxUaGlzLmNvbnNvbGUpIHtcbiAgICBnbG9iYWxUaGlzLmNvbnNvbGUubG9nKGBQaXhpSlMgJHtWRVJTSU9OfSAtICR7dHlwZX0gLSBodHRwOi8vd3d3LnBpeGlqcy5jb20vYCk7XG4gIH1cbiAgc2FpZEhlbGxvID0gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgc2F5SGVsbG8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNheUhlbGxvLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHNheUhlbGxvIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvc2F5SGVsbG8ubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgSGVsbG9TeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEl0IGFsbCBzdGFydHMgaGVyZSEgVGhpcyBpbml0aWF0ZXMgZXZlcnkgc3lzdGVtLCBwYXNzaW5nIGluIHRoZSBvcHRpb25zIGZvciBhbnkgc3lzdGVtIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHJlbmRlcmVyIGFuZCBhbGwgaXRzIHN5c3RlbXNcbiAgICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhlbGxvKSB7XG4gICAgICBsZXQgbmFtZSA9IHRoaXMuX3JlbmRlcmVyLm5hbWU7XG4gICAgICBpZiAodGhpcy5fcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdMKSB7XG4gICAgICAgIG5hbWUgKz0gYCAke3RoaXMuX3JlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9ufWA7XG4gICAgICB9XG4gICAgICBzYXlIZWxsbyhuYW1lKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5IZWxsb1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiaGVsbG9cIixcbiAgcHJpb3JpdHk6IC0yXG59O1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBzeXN0ZW0uICovXG5IZWxsb1N5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqIHtAbGluayBXZWJHTE9wdGlvbnMuaGVsbG99ICovXG4gIGhlbGxvOiBmYWxzZVxufTtcblxuZXhwb3J0IHsgSGVsbG9TeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhlbGxvU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2xlYW5IYXNoKGhhc2gpIHtcbiAgbGV0IGNsZWFuID0gZmFsc2U7XG4gIGZvciAoY29uc3QgaSBpbiBoYXNoKSB7XG4gICAgaWYgKGhhc2hbaV0gPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhbiA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFjbGVhbilcbiAgICByZXR1cm4gaGFzaDtcbiAgY29uc3QgY2xlYW5IYXNoMiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGkgaW4gaGFzaCkge1xuICAgIGNvbnN0IHZhbHVlID0gaGFzaFtpXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNsZWFuSGFzaDJbaV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuSGFzaDI7XG59XG5mdW5jdGlvbiBjbGVhbkFycmF5KGFycikge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldID09IHZvaWQgMCkge1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycltpIC0gb2Zmc2V0XSA9IGFycltpXTtcbiAgICB9XG4gIH1cbiAgYXJyLmxlbmd0aCAtPSBvZmZzZXQ7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCB7IGNsZWFuQXJyYXksIGNsZWFuSGFzaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xlYW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgY2xlYW5IYXNoLCBjbGVhbkFycmF5IH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS9jbGVhbi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCByZW5kZXJhYmxlR0NUaWNrID0gMDtcbmNvbnN0IF9SZW5kZXJhYmxlR0NTeXN0ZW0gPSBjbGFzcyBfUmVuZGVyYWJsZUdDU3lzdGVtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVuZGVyYWJsZUdDU3lzdGVtIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBnYXJiYWdlIGNvbGxlY3Rpb24gc3lzdGVtIHdvcmtzIGZvclxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAvKiogQXJyYXkgb2YgcmVuZGVyYWJsZXMgYmVpbmcgdHJhY2tlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uICovXG4gICAgdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzID0gW107XG4gICAgLyoqIEFycmF5IG9mIGhhc2ggb2JqZWN0cyBiZWluZyB0cmFja2VkIGZvciBjbGVhbnVwICovXG4gICAgdGhpcy5fbWFuYWdlZEhhc2hlcyA9IFtdO1xuICAgIC8qKiBBcnJheSBvZiBhcnJheXMgYmVpbmcgdHJhY2tlZCBmb3IgY2xlYW51cCAqL1xuICAgIHRoaXMuX21hbmFnZWRBcnJheXMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHN5c3RlbSB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJlbmRlcmVyXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fUmVuZGVyYWJsZUdDU3lzdGVtLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5tYXhVbnVzZWRUaW1lID0gb3B0aW9ucy5yZW5kZXJhYmxlR0NNYXhVbnVzZWRUaW1lO1xuICAgIHRoaXMuX2ZyZXF1ZW5jeSA9IG9wdGlvbnMucmVuZGVyYWJsZUdDRnJlcXVlbmN5O1xuICAgIHRoaXMuZW5hYmxlZCA9IG9wdGlvbnMucmVuZGVyYWJsZUdDQWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdhcmJhZ2UgY29sbGVjdGlvbiBzeXN0ZW0gaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgR0MgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBnZXQgZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9oYW5kbGVyO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBnYXJiYWdlIGNvbGxlY3Rpb24gc3lzdGVtLlxuICAgKiBXaGVuIGVuYWJsZWQsIHNjaGVkdWxlcyBwZXJpb2RpYyBjbGVhbnVwIG9mIHJlc291cmNlcy5cbiAgICogV2hlbiBkaXNhYmxlZCwgY2FuY2VscyBhbGwgc2NoZWR1bGVkIGNsZWFudXBzLlxuICAgKi9cbiAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXIgPSB0aGlzLl9yZW5kZXJlci5zY2hlZHVsZXIucmVwZWF0KFxuICAgICAgICAoKSA9PiB0aGlzLnJ1bigpLFxuICAgICAgICB0aGlzLl9mcmVxdWVuY3ksXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgdGhpcy5faGFzaEhhbmRsZXIgPSB0aGlzLl9yZW5kZXJlci5zY2hlZHVsZXIucmVwZWF0KFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIHRoaXMuX21hbmFnZWRIYXNoZXMpIHtcbiAgICAgICAgICAgIGhhc2guY29udGV4dFtoYXNoLmhhc2hdID0gY2xlYW5IYXNoKGhhc2guY29udGV4dFtoYXNoLmhhc2hdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVxuICAgICAgKTtcbiAgICAgIHRoaXMuX2FycmF5SGFuZGxlciA9IHRoaXMuX3JlbmRlcmVyLnNjaGVkdWxlci5yZXBlYXQoXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIHRoaXMuX21hbmFnZWRBcnJheXMpIHtcbiAgICAgICAgICAgIGNsZWFuQXJyYXkoYXJyYXkuY29udGV4dFthcnJheS5oYXNoXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aGlzLl9mcmVxdWVuY3lcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNjaGVkdWxlci5jYW5jZWwodGhpcy5faGFuZGxlcik7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zY2hlZHVsZXIuY2FuY2VsKHRoaXMuX2hhc2hIYW5kbGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNjaGVkdWxlci5jYW5jZWwodGhpcy5fYXJyYXlIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBoYXNoIHRhYmxlIHRvIGJlIG1hbmFnZWQgYnkgdGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaGFzaCB0YWJsZVxuICAgKiBAcGFyYW0gaGFzaCAtIFRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBoYXNoIHRhYmxlXG4gICAqL1xuICBhZGRNYW5hZ2VkSGFzaChjb250ZXh0LCBoYXNoKSB7XG4gICAgdGhpcy5fbWFuYWdlZEhhc2hlcy5wdXNoKHsgY29udGV4dCwgaGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhcnJheSB0byBiZSBtYW5hZ2VkIGJ5IHRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoIC0gVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGFycmF5XG4gICAqL1xuICBhZGRNYW5hZ2VkQXJyYXkoY29udGV4dCwgaGFzaCkge1xuICAgIHRoaXMuX21hbmFnZWRBcnJheXMucHVzaCh7IGNvbnRleHQsIGhhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIEdDIHRpbWVzdGFtcCBhbmQgdHJhY2tpbmcgYmVmb3JlIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVuZGVyIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byByZW5kZXJcbiAgICovXG4gIHByZXJlbmRlcih7XG4gICAgY29udGFpbmVyXG4gIH0pIHtcbiAgICB0aGlzLl9ub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb250YWluZXIucmVuZGVyR3JvdXAuZ2NUaWNrID0gcmVuZGVyYWJsZUdDVGljaysrO1xuICAgIHRoaXMuX3VwZGF0ZUluc3RydWN0aW9uR0NUaWNrKGNvbnRhaW5lci5yZW5kZXJHcm91cCwgY29udGFpbmVyLnJlbmRlckdyb3VwLmdjVGljayk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0cmFja2luZyBhIHJlbmRlcmFibGUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHJlbmRlcmFibGUgLSBUaGUgcmVuZGVyYWJsZSB0byB0cmFja1xuICAgKi9cbiAgYWRkUmVuZGVyYWJsZShyZW5kZXJhYmxlKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlbmRlcmFibGUuX2xhc3RVc2VkID09PSAtMSkge1xuICAgICAgdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzLnB1c2gocmVuZGVyYWJsZSk7XG4gICAgICByZW5kZXJhYmxlLm9uY2UoXCJkZXN0cm95ZWRcIiwgdGhpcy5fcmVtb3ZlUmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgfVxuICAgIHJlbmRlcmFibGUuX2xhc3RVc2VkID0gdGhpcy5fbm93O1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgY2xlYW5pbmcgdXAgdW51c2VkIHJlbmRlcmFibGVzLlxuICAgKiBSZW1vdmVzIHJlbmRlcmFibGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgZm9yIGxvbmdlciB0aGFuIG1heFVudXNlZFRpbWUuXG4gICAqL1xuICBydW4oKSB7XG4gICAgY29uc3Qgbm93ID0gdGhpcy5fbm93O1xuICAgIGNvbnN0IG1hbmFnZWRSZW5kZXJhYmxlcyA9IHRoaXMuX21hbmFnZWRSZW5kZXJhYmxlcztcbiAgICBjb25zdCByZW5kZXJQaXBlcyA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZFJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZW5kZXJhYmxlID0gbWFuYWdlZFJlbmRlcmFibGVzW2ldO1xuICAgICAgaWYgKHJlbmRlcmFibGUgPT09IG51bGwpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyR3JvdXAgPSByZW5kZXJhYmxlLnJlbmRlckdyb3VwID8/IHJlbmRlcmFibGUucGFyZW50UmVuZGVyR3JvdXA7XG4gICAgICBjb25zdCBjdXJyZW50VGljayA9IHJlbmRlckdyb3VwPy5pbnN0cnVjdGlvblNldD8uZ2NUaWNrID8/IC0xO1xuICAgICAgaWYgKChyZW5kZXJHcm91cD8uZ2NUaWNrID8/IDApID09PSBjdXJyZW50VGljaykge1xuICAgICAgICByZW5kZXJhYmxlLl9sYXN0VXNlZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIGlmIChub3cgLSByZW5kZXJhYmxlLl9sYXN0VXNlZCA+IHRoaXMubWF4VW51c2VkVGltZSkge1xuICAgICAgICBpZiAoIXJlbmRlcmFibGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY29uc3QgcnAgPSByZW5kZXJQaXBlcztcbiAgICAgICAgICBpZiAocmVuZGVyR3JvdXApXG4gICAgICAgICAgICByZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHJwW3JlbmRlcmFibGUucmVuZGVyUGlwZUlkXS5kZXN0cm95UmVuZGVyYWJsZShyZW5kZXJhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJhYmxlLl9sYXN0VXNlZCA9IC0xO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgcmVuZGVyYWJsZS5vZmYoXCJkZXN0cm95ZWRcIiwgdGhpcy5fcmVtb3ZlUmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYW5hZ2VkUmVuZGVyYWJsZXNbaSAtIG9mZnNldF0gPSByZW5kZXJhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkUmVuZGVyYWJsZXMubGVuZ3RoIC09IG9mZnNldDtcbiAgfVxuICAvKiogQ2xlYW5zIHVwIHRoZSBnYXJiYWdlIGNvbGxlY3Rpb24gc3lzdGVtLiBEaXNhYmxlcyBHQyBhbmQgcmVtb3ZlcyBhbGwgdHJhY2tlZCByZXNvdXJjZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX21hbmFnZWRSZW5kZXJhYmxlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX21hbmFnZWRIYXNoZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYW5hZ2VkQXJyYXlzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZW5kZXJhYmxlIGZyb20gYmVpbmcgdHJhY2tlZCB3aGVuIGl0J3MgZGVzdHJveWVkLlxuICAgKiBAcGFyYW0gcmVuZGVyYWJsZSAtIFRoZSByZW5kZXJhYmxlIHRvIHN0b3AgdHJhY2tpbmdcbiAgICovXG4gIF9yZW1vdmVSZW5kZXJhYmxlKHJlbmRlcmFibGUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX21hbmFnZWRSZW5kZXJhYmxlcy5pbmRleE9mKHJlbmRlcmFibGUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZW5kZXJhYmxlLm9mZihcImRlc3Ryb3llZFwiLCB0aGlzLl9yZW1vdmVSZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIHRoaXMuX21hbmFnZWRSZW5kZXJhYmxlc1tpbmRleF0gPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgR0MgdGljayBjb3VudGVyIGZvciBhIHJlbmRlciBncm91cCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gcmVuZGVyR3JvdXAgLSBUaGUgcmVuZGVyIGdyb3VwIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gZ2NUaWNrIC0gVGhlIG5ldyB0aWNrIHZhbHVlXG4gICAqL1xuICBfdXBkYXRlSW5zdHJ1Y3Rpb25HQ1RpY2socmVuZGVyR3JvdXAsIGdjVGljaykge1xuICAgIHJlbmRlckdyb3VwLmluc3RydWN0aW9uU2V0LmdjVGljayA9IGdjVGljaztcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUluc3RydWN0aW9uR0NUaWNrKGNoaWxkLCBnY1RpY2spO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogRXh0ZW5zaW9uIG1ldGFkYXRhIGZvciByZWdpc3RlcmluZyB0aGlzIHN5c3RlbSB3aXRoIHRoZSByZW5kZXJlci5cbiAqIEBpZ25vcmVcbiAqL1xuX1JlbmRlcmFibGVHQ1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwicmVuZGVyYWJsZUdDXCIsXG4gIHByaW9yaXR5OiAwXG59O1xuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGdhcmJhZ2UgY29sbGVjdGlvbiBzeXN0ZW0uXG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB3aGVuIGluaXRpYWxpemluZyB0aGUgcmVuZGVyZXIuXG4gKi9cbl9SZW5kZXJhYmxlR0NTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiBFbmFibGUvZGlzYWJsZSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgKi9cbiAgcmVuZGVyYWJsZUdDQWN0aXZlOiB0cnVlLFxuICAvKiogVGltZSBpbiBtcyBiZWZvcmUgYW4gdW51c2VkIHJlc291cmNlIGlzIGNvbGxlY3RlZCAoZGVmYXVsdCAxIG1pbnV0ZSkgKi9cbiAgcmVuZGVyYWJsZUdDTWF4VW51c2VkVGltZTogNmU0LFxuICAvKiogSG93IG9mdGVuIHRvIHJ1biBnYXJiYWdlIGNvbGxlY3Rpb24gaW4gbXMgKGRlZmF1bHQgMzAgc2Vjb25kcykgKi9cbiAgcmVuZGVyYWJsZUdDRnJlcXVlbmN5OiAzZTRcbn07XG5sZXQgUmVuZGVyYWJsZUdDU3lzdGVtID0gX1JlbmRlcmFibGVHQ1N5c3RlbTtcblxuZXhwb3J0IHsgUmVuZGVyYWJsZUdDU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJhYmxlR0NTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9UZXh0dXJlR0NTeXN0ZW0gPSBjbGFzcyBfVGV4dHVyZUdDU3lzdGVtIHtcbiAgLyoqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBvcHRpb25zLnRleHR1cmVHQ0NoZWNrQ291bnRNYXg7XG4gICAgdGhpcy5tYXhJZGxlID0gb3B0aW9ucy50ZXh0dXJlR0NBTWF4SWRsZSA/PyBvcHRpb25zLnRleHR1cmVHQ01heElkbGU7XG4gICAgdGhpcy5hY3RpdmUgPSBvcHRpb25zLnRleHR1cmVHQ0FjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSB3aGVuIHRoZSBsYXN0IHRpbWUgYSB0ZXh0dXJlIHdhcyB1c2VkLlxuICAgKiBJZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFUuXG4gICAqL1xuICBwb3N0cmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb3VudCsrO1xuICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jaGVja0NvdW50Kys7XG4gICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWQuXG4gICAqIElmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVS5cbiAgICovXG4gIHJ1bigpIHtcbiAgICBjb25zdCBtYW5hZ2VkVGV4dHVyZXMgPSB0aGlzLl9yZW5kZXJlci50ZXh0dXJlLm1hbmFnZWRUZXh0dXJlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgIGlmICh0ZXh0dXJlLmF1dG9HYXJiYWdlQ29sbGVjdCAmJiB0ZXh0dXJlLnJlc291cmNlICYmIHRleHR1cmUuX3RvdWNoZWQgPiAtMSAmJiB0aGlzLmNvdW50IC0gdGV4dHVyZS5fdG91Y2hlZCA+IHRoaXMubWF4SWRsZSkge1xuICAgICAgICB0ZXh0dXJlLl90b3VjaGVkID0gLTE7XG4gICAgICAgIHRleHR1cmUudW5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59O1xuLyoqIEBpZ25vcmUgKi9cbl9UZXh0dXJlR0NTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInRleHR1cmVHQ1wiXG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIFRleHR1cmVHQ1N5c3RlbSAqL1xuX1RleHR1cmVHQ1N5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIElmIHNldCB0byB0cnVlLCB0aGlzIHdpbGwgZW5hYmxlIHRoZSBnYXJiYWdlIGNvbGxlY3RvciBvbiB0aGUgR1BVLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICB0ZXh0dXJlR0NBY3RpdmU6IHRydWUsXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjMuMFxuICAgKiBAc2VlIHtAbGluayBUZXh0dXJlR0NTeXN0ZW1PcHRpb25zLnRleHR1cmVHQ01heElkbGV9XG4gICAqL1xuICB0ZXh0dXJlR0NBTWF4SWRsZTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGlkbGUgZnJhbWVzIGJlZm9yZSBhIHRleHR1cmUgaXMgZGVzdHJveWVkIGJ5IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogQGRlZmF1bHQgNjAgKiA2MFxuICAgKi9cbiAgdGV4dHVyZUdDTWF4SWRsZTogNjAgKiA2MCxcbiAgLyoqXG4gICAqIEZyYW1lcyBiZXR3ZWVuIHR3byBnYXJiYWdlIGNvbGxlY3Rpb25zLlxuICAgKiBAZGVmYXVsdCA2MDBcbiAgICovXG4gIHRleHR1cmVHQ0NoZWNrQ291bnRNYXg6IDYwMFxufTtcbmxldCBUZXh0dXJlR0NTeXN0ZW0gPSBfVGV4dHVyZUdDU3lzdGVtO1xuXG5leHBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVHQ1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzJztcbmltcG9ydCB7IGdldENhbnZhc1RleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlL3V0aWxzL2dldENhbnZhc1RleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVmlld1N5c3RlbSA9IGNsYXNzIF9WaWV3U3lzdGVtIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgQ1NTIGRpbWVuc2lvbnMgb2YgY2FudmFzIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgdG8gc2NyZWVuIGRpbWVuc2lvbnMgYXV0b21hdGljYWxseS5cbiAgICogVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgSFRNTENhbnZhc0VsZW1lbnQgYW5kIHdpbGwgYmUgaWdub3JlZCBpZiB0aGUgY2FudmFzIGlzIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYXV0b0RlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZS5zb3VyY2UuYXV0b0RlbnNpdHk7XG4gIH1cbiAgc2V0IGF1dG9EZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy50ZXh0dXJlLnNvdXJjZS5hdXRvRGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy50ZXh0dXJlLnNvdXJjZS5yZXNpemUoXG4gICAgICB0aGlzLnRleHR1cmUuc291cmNlLndpZHRoLFxuICAgICAgdGhpcy50ZXh0dXJlLnNvdXJjZS5oZWlnaHQsXG4gICAgICB2YWx1ZVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgdmlldyBzeXN0ZW1cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIHZpZXdcbiAgICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5fVmlld1N5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnZpZXcpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJWaWV3U3lzdGVtLnZpZXcgaGFzIGJlZW4gcmVuYW1lZCB0byBWaWV3U3lzdGVtLmNhbnZhc1wiKTtcbiAgICAgIG9wdGlvbnMuY2FudmFzID0gb3B0aW9ucy52aWV3O1xuICAgIH1cbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgIHRoaXMuY2FudmFzID0gb3B0aW9ucy5jYW52YXMgfHwgRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLmFudGlhbGlhcyA9ICEhb3B0aW9ucy5hbnRpYWxpYXM7XG4gICAgdGhpcy50ZXh0dXJlID0gZ2V0Q2FudmFzVGV4dHVyZSh0aGlzLmNhbnZhcywgb3B0aW9ucyk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KHtcbiAgICAgIGNvbG9yVGV4dHVyZXM6IFt0aGlzLnRleHR1cmVdLFxuICAgICAgZGVwdGg6ICEhb3B0aW9ucy5kZXB0aCxcbiAgICAgIGlzUm9vdDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZS5zb3VyY2UudHJhbnNwYXJlbnQgPSBvcHRpb25zLmJhY2tncm91bmRBbHBoYSA8IDE7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBzY3JlZW4gYW5kIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuSGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtIHJlc29sdXRpb25cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnRleHR1cmUuc291cmNlLnJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIHRoaXMuc2NyZWVuLndpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIGNhbnZhcyBmcm9tIHRoZSBkb20uXG4gICAqIEBwYXJhbSB7b3B0aW9ucyB8IGZhbHNlfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGRlc3Ryb3lpbmcgdGhlIHZpZXcsIG9yIFwiZmFsc2VcIi5cbiAgICogQGV4YW1wbGVcbiAgICogdmlld1N5c3RlbS5kZXN0cm95KCk7XG4gICAqIHZpZXdTeXN0ZW0uZGVzdHJveSh0cnVlKTtcbiAgICogdmlld1N5c3RlbS5kZXN0cm95KHsgcmVtb3ZlVmlldzogdHJ1ZSB9KTtcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVtb3ZlVmlldyA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiAhIW9wdGlvbnM/LnJlbW92ZVZpZXc7XG4gICAgaWYgKHJlbW92ZVZpZXcgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX1ZpZXdTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcInZpZXdcIixcbiAgcHJpb3JpdHk6IDBcbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHZpZXcgc3lzdGVtLiAqL1xuX1ZpZXdTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLndpZHRofVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG4gIHdpZHRoOiA4MDAsXG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLmhlaWdodH1cbiAgICogQGRlZmF1bHQgNjAwXG4gICAqL1xuICBoZWlnaHQ6IDYwMCxcbiAgLyoqXG4gICAqIHtAbGluayBXZWJHTE9wdGlvbnMuYXV0b0RlbnNpdHl9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhdXRvRGVuc2l0eTogZmFsc2UsXG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLmFudGlhbGlhc31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFudGlhbGlhczogZmFsc2Vcbn07XG5sZXQgVmlld1N5c3RlbSA9IF9WaWV3U3lzdGVtO1xuXG5leHBvcnQgeyBWaWV3U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEN1c3RvbVJlbmRlclBpcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvQ3VzdG9tUmVuZGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyR3JvdXBTeXN0ZW0gfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXBTeXN0ZW0ubWpzJztcbmltcG9ydCB7IFNwcml0ZVBpcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9zcHJpdGUvU3ByaXRlUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyZXJJbml0SG9vayB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2dsb2JhbC9nbG9iYWxIb29rcy5tanMnO1xuaW1wb3J0IHsgQmF0Y2hlclBpcGUgfSBmcm9tICcuLi8uLi8uLi9iYXRjaGVyL3NoYXJlZC9CYXRjaGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgQWxwaGFNYXNrUGlwZSB9IGZyb20gJy4uLy4uLy4uL21hc2svYWxwaGEvQWxwaGFNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgQ29sb3JNYXNrUGlwZSB9IGZyb20gJy4uLy4uLy4uL21hc2svY29sb3IvQ29sb3JNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgU3RlbmNpbE1hc2tQaXBlIH0gZnJvbSAnLi4vLi4vLi4vbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgQmFja2dyb3VuZFN5c3RlbSB9IGZyb20gJy4uL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgQmxlbmRNb2RlUGlwZSB9IGZyb20gJy4uL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanMnO1xuaW1wb3J0IHsgRXh0cmFjdFN5c3RlbSB9IGZyb20gJy4uL2V4dHJhY3QvRXh0cmFjdFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi4vZXh0cmFjdC9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdsb2JhbFVuaWZvcm1TeXN0ZW0gfSBmcm9tICcuLi9yZW5kZXJUYXJnZXQvR2xvYmFsVW5pZm9ybVN5c3RlbS5tanMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyU3lzdGVtIH0gZnJvbSAnLi4vU2NoZWR1bGVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBIZWxsb1N5c3RlbSB9IGZyb20gJy4uL3N0YXJ0dXAvSGVsbG9TeXN0ZW0ubWpzJztcbmltcG9ydCB7IFJlbmRlcmFibGVHQ1N5c3RlbSB9IGZyb20gJy4uL3RleHR1cmUvUmVuZGVyYWJsZUdDU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfSBmcm9tICcuLi90ZXh0dXJlL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4uL3ZpZXcvVmlld1N5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFNoYXJlZFN5c3RlbXMgPSBbXG4gIEJhY2tncm91bmRTeXN0ZW0sXG4gIEdsb2JhbFVuaWZvcm1TeXN0ZW0sXG4gIEhlbGxvU3lzdGVtLFxuICBWaWV3U3lzdGVtLFxuICBSZW5kZXJHcm91cFN5c3RlbSxcbiAgVGV4dHVyZUdDU3lzdGVtLFxuICBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0sXG4gIEV4dHJhY3RTeXN0ZW0sXG4gIFJlbmRlcmVySW5pdEhvb2ssXG4gIFJlbmRlcmFibGVHQ1N5c3RlbSxcbiAgU2NoZWR1bGVyU3lzdGVtXG5dO1xuY29uc3QgU2hhcmVkUmVuZGVyUGlwZXMgPSBbXG4gIEJsZW5kTW9kZVBpcGUsXG4gIEJhdGNoZXJQaXBlLFxuICBTcHJpdGVQaXBlLFxuICBSZW5kZXJHcm91cFBpcGUsXG4gIEFscGhhTWFza1BpcGUsXG4gIFN0ZW5jaWxNYXNrUGlwZSxcbiAgQ29sb3JNYXNrUGlwZSxcbiAgQ3VzdG9tUmVuZGVyUGlwZVxuXTtcblxuZXhwb3J0IHsgU2hhcmVkUmVuZGVyUGlwZXMsIFNoYXJlZFN5c3RlbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYXJlZFN5c3RlbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1161\n\n}')},1172(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ GpuStencilModesToPixi)\n/* harmony export */ });\n/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1957);\n\n\n"use strict";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.NONE] = void 0;\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: "equal",\n    passOp: "increment-clamp"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "increment-clamp"\n  }\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: "equal",\n    passOp: "decrement-clamp"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "decrement-clamp"\n  }\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: "equal",\n    passOp: "keep"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "keep"\n  }\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: "not-equal",\n    passOp: "keep"\n  },\n  stencilBack: {\n    compare: "not-equal",\n    passOp: "keep"\n  }\n};\n\n\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3Mi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0Esc0JBQXNCLDJFQUFhO0FBQ25DLHNCQUFzQiwyRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zdGF0ZS9HcHVTdGVuY2lsTW9kZXNUb1BpeGkubWpzPzhhODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9zdGF0ZS9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IEdwdVN0ZW5jaWxNb2Rlc1RvUGl4aSA9IFtdO1xuR3B1U3RlbmNpbE1vZGVzVG9QaXhpW1NURU5DSUxfTU9ERVMuTk9ORV0gPSB2b2lkIDA7XG5HcHVTdGVuY2lsTW9kZXNUb1BpeGlbU1RFTkNJTF9NT0RFUy5ESVNBQkxFRF0gPSB7XG4gIHN0ZW5jaWxXcml0ZU1hc2s6IDAsXG4gIHN0ZW5jaWxSZWFkTWFzazogMFxufTtcbkdwdVN0ZW5jaWxNb2Rlc1RvUGl4aVtTVEVOQ0lMX01PREVTLlJFTkRFUklOR19NQVNLX0FERF0gPSB7XG4gIHN0ZW5jaWxGcm9udDoge1xuICAgIGNvbXBhcmU6IFwiZXF1YWxcIixcbiAgICBwYXNzT3A6IFwiaW5jcmVtZW50LWNsYW1wXCJcbiAgfSxcbiAgc3RlbmNpbEJhY2s6IHtcbiAgICBjb21wYXJlOiBcImVxdWFsXCIsXG4gICAgcGFzc09wOiBcImluY3JlbWVudC1jbGFtcFwiXG4gIH1cbn07XG5HcHVTdGVuY2lsTW9kZXNUb1BpeGlbU1RFTkNJTF9NT0RFUy5SRU5ERVJJTkdfTUFTS19SRU1PVkVdID0ge1xuICBzdGVuY2lsRnJvbnQ6IHtcbiAgICBjb21wYXJlOiBcImVxdWFsXCIsXG4gICAgcGFzc09wOiBcImRlY3JlbWVudC1jbGFtcFwiXG4gIH0sXG4gIHN0ZW5jaWxCYWNrOiB7XG4gICAgY29tcGFyZTogXCJlcXVhbFwiLFxuICAgIHBhc3NPcDogXCJkZWNyZW1lbnQtY2xhbXBcIlxuICB9XG59O1xuR3B1U3RlbmNpbE1vZGVzVG9QaXhpW1NURU5DSUxfTU9ERVMuTUFTS19BQ1RJVkVdID0ge1xuICBzdGVuY2lsV3JpdGVNYXNrOiAwLFxuICBzdGVuY2lsRnJvbnQ6IHtcbiAgICBjb21wYXJlOiBcImVxdWFsXCIsXG4gICAgcGFzc09wOiBcImtlZXBcIlxuICB9LFxuICBzdGVuY2lsQmFjazoge1xuICAgIGNvbXBhcmU6IFwiZXF1YWxcIixcbiAgICBwYXNzT3A6IFwia2VlcFwiXG4gIH1cbn07XG5HcHVTdGVuY2lsTW9kZXNUb1BpeGlbU1RFTkNJTF9NT0RFUy5JTlZFUlNFX01BU0tfQUNUSVZFXSA9IHtcbiAgc3RlbmNpbFdyaXRlTWFzazogMCxcbiAgc3RlbmNpbEZyb250OiB7XG4gICAgY29tcGFyZTogXCJub3QtZXF1YWxcIixcbiAgICBwYXNzT3A6IFwia2VlcFwiXG4gIH0sXG4gIHN0ZW5jaWxCYWNrOiB7XG4gICAgY29tcGFyZTogXCJub3QtZXF1YWxcIixcbiAgICBwYXNzT3A6IFwia2VlcFwiXG4gIH1cbn07XG5cbmV4cG9ydCB7IEdwdVN0ZW5jaWxNb2Rlc1RvUGl4aSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1U3RlbmNpbE1vZGVzVG9QaXhpLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1172\n\n}')},1266(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ uboSyncFunctionsWGSL),\n/* harmony export */   g: () => (/* binding */ uboSyncFunctionsSTD40)\n/* harmony export */ });\n\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  "vec2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  "vec3<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  "vec4<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  "vec2<i32>": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  "vec3<i32>": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  "vec4<i32>": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  "mat2x2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  "mat3x3<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  "mat4x4<f32>": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  "mat3x2<f32>": loopMatrix(3, 2),\n  "mat4x2<f32>": loopMatrix(4, 2),\n  "mat2x3<f32>": loopMatrix(2, 3),\n  "mat4x3<f32>": loopMatrix(4, 3),\n  "mat2x4<f32>": loopMatrix(2, 4),\n  "mat3x4<f32>": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  "mat2x2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\n\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxRQUFRO0FBQ3RDLG1DQUFtQyxJQUFJLG1CQUFtQixJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVEO0FBQ3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy91Ym9TeW5jRnVuY3Rpb25zLm1qcz9hOGI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbG9vcE1hdHJpeChjb2wsIHJvdykge1xuICBjb25zdCB0b3RhbCA9IGNvbCAqIHJvdztcbiAgcmV0dXJuIGBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAke3RvdGFsfTsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArICgoKGkgLyAke2NvbH0pfDApICogNCkgKyAoaSAlICR7Y29sfSldID0gdltpXTtcbiAgICAgICAgfVxuICAgIGA7XG59XG5jb25zdCB1Ym9TeW5jRnVuY3Rpb25zU1RENDAgPSB7XG4gIGYzMjogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2O2AsXG4gIGkzMjogYFxuICAgICAgICBkYXRhSW50MzJbb2Zmc2V0XSA9IHY7YCxcbiAgXCJ2ZWMyPGYzMj5cIjogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCArIDFdID0gdlsxXTtgLFxuICBcInZlYzM8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gdlsyXTtgLFxuICBcInZlYzQ8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IHZbM107YCxcbiAgXCJ2ZWMyPGkzMj5cIjogYFxuICAgICAgICBkYXRhSW50MzJbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAxXSA9IHZbMV07YCxcbiAgXCJ2ZWMzPGkzMj5cIjogYFxuICAgICAgICBkYXRhSW50MzJbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAyXSA9IHZbMl07YCxcbiAgXCJ2ZWM0PGkzMj5cIjogYFxuICAgICAgICBkYXRhSW50MzJbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAyXSA9IHZbMl07XG4gICAgICAgIGRhdGFJbnQzMltvZmZzZXQgKyAzXSA9IHZbM107YCxcbiAgXCJtYXQyeDI8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCArIDRdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9IHZbM107YCxcbiAgXCJtYXQzeDM8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9IHZbM107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSB2WzRdO1xuICAgICAgICBkYXRhW29mZnNldCArIDZdID0gdls1XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9IHZbNl07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSB2WzddO1xuICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9IHZbOF07YCxcbiAgXCJtYXQ0eDQ8ZjMyPlwiOiBgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBpXSA9IHZbaV07XG4gICAgICAgIH1gLFxuICBcIm1hdDN4MjxmMzI+XCI6IGxvb3BNYXRyaXgoMywgMiksXG4gIFwibWF0NHgyPGYzMj5cIjogbG9vcE1hdHJpeCg0LCAyKSxcbiAgXCJtYXQyeDM8ZjMyPlwiOiBsb29wTWF0cml4KDIsIDMpLFxuICBcIm1hdDR4MzxmMzI+XCI6IGxvb3BNYXRyaXgoNCwgMyksXG4gIFwibWF0Mng0PGYzMj5cIjogbG9vcE1hdHJpeCgyLCA0KSxcbiAgXCJtYXQzeDQ8ZjMyPlwiOiBsb29wTWF0cml4KDMsIDQpXG59O1xuY29uc3QgdWJvU3luY0Z1bmN0aW9uc1dHU0wgPSB7XG4gIC4uLnVib1N5bmNGdW5jdGlvbnNTVEQ0MCxcbiAgXCJtYXQyeDI8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IHZbM107XG4gICAgYFxufTtcblxuZXhwb3J0IHsgdWJvU3luY0Z1bmN0aW9uc1NURDQwLCB1Ym9TeW5jRnVuY3Rpb25zV0dTTCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWJvU3luY0Z1bmN0aW9ucy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1266\n\n}')},2067(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ls: () => (/* binding */ localUniformBit),\n/* harmony export */   _Q: () => (/* binding */ localUniformBitGroup2),\n/* harmony export */   mA: () => (/* binding */ localUniformBitGl)\n/* harmony export */ });\n\nconst localUniformBit = {\n  name: "local-uniform-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace("group(1)", "group(2)")\n  }\n};\nconst localUniformBitGl = {\n  name: "local-uniform-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformBit.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtQml0Lm1qcz8xNjBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbG9jYWxVbmlmb3JtQml0ID0ge1xuICBuYW1lOiBcImxvY2FsLXVuaWZvcm0tYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuXG4gICAgICAgICAgICBzdHJ1Y3QgTG9jYWxVbmlmb3JtcyB7XG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVSb3VuZDpmMzIsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gbG9jYWxVbmlmb3JtcyA6IExvY2FsVW5pZm9ybXM7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHZDb2xvciAqPSBsb2NhbFVuaWZvcm1zLnVDb2xvcjtcbiAgICAgICAgICAgIG1vZGVsTWF0cml4ICo9IGxvY2FsVW5pZm9ybXMudVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgYFxuICAgICksXG4gICAgZW5kOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBpZihsb2NhbFVuaWZvcm1zLnVSb3VuZCA9PSAxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZQb3NpdGlvbiA9IHZlYzQocm91bmRQaXhlbHModlBvc2l0aW9uLnh5LCBnbG9iYWxVbmlmb3Jtcy51UmVzb2x1dGlvbiksIHZQb3NpdGlvbi56dyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCBsb2NhbFVuaWZvcm1CaXRHcm91cDIgPSB7XG4gIC4uLmxvY2FsVW5pZm9ybUJpdCxcbiAgdmVydGV4OiB7XG4gICAgLi4ubG9jYWxVbmlmb3JtQml0LnZlcnRleCxcbiAgICAvLyByZXBsYWNlIHRoZSBncm91cCFcbiAgICBoZWFkZXI6IGxvY2FsVW5pZm9ybUJpdC52ZXJ0ZXguaGVhZGVyLnJlcGxhY2UoXCJncm91cCgxKVwiLCBcImdyb3VwKDIpXCIpXG4gIH1cbn07XG5jb25zdCBsb2NhbFVuaWZvcm1CaXRHbCA9IHtcbiAgbmFtZTogXCJsb2NhbC11bmlmb3JtLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcblxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNvbG9yO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1Um91bmQ7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHZDb2xvciAqPSB1Q29sb3I7XG4gICAgICAgICAgICBtb2RlbE1hdHJpeCA9IHVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYodVJvdW5kID09IDEuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnh5ID0gcm91bmRQaXhlbHMoZ2xfUG9zaXRpb24ueHksIHVSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgbG9jYWxVbmlmb3JtQml0LCBsb2NhbFVuaWZvcm1CaXRHbCwgbG9jYWxVbmlmb3JtQml0R3JvdXAyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFVuaWZvcm1CaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2067\n\n}')},2760(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ color32BitToUniform)\n/* harmony export */ });\n/* unused harmony export colorToUniform */\n\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\n\n//# sourceMappingURL=colorToUniform.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc2MC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcz85ODNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY29sb3JUb1VuaWZvcm0ocmdiLCBhbHBoYSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0W29mZnNldCsrXSA9IChyZ2IgPj4gMTYgJiAyNTUpIC8gMjU1O1xuICBvdXRbb2Zmc2V0KytdID0gKHJnYiA+PiA4ICYgMjU1KSAvIDI1NTtcbiAgb3V0W29mZnNldCsrXSA9IChyZ2IgJiAyNTUpIC8gMjU1O1xuICBvdXRbb2Zmc2V0KytdID0gYWxwaGE7XG59XG5mdW5jdGlvbiBjb2xvcjMyQml0VG9Vbmlmb3JtKGFiZ3IsIG91dCwgb2Zmc2V0KSB7XG4gIGNvbnN0IGFscGhhID0gKGFiZ3IgPj4gMjQgJiAyNTUpIC8gMjU1O1xuICBvdXRbb2Zmc2V0KytdID0gKGFiZ3IgJiAyNTUpIC8gMjU1ICogYWxwaGE7XG4gIG91dFtvZmZzZXQrK10gPSAoYWJnciA+PiA4ICYgMjU1KSAvIDI1NSAqIGFscGhhO1xuICBvdXRbb2Zmc2V0KytdID0gKGFiZ3IgPj4gMTYgJiAyNTUpIC8gMjU1ICogYWxwaGE7XG4gIG91dFtvZmZzZXQrK10gPSBhbHBoYTtcbn1cblxuZXhwb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSwgY29sb3JUb1VuaWZvcm0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yVG9Vbmlmb3JtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2760\n\n}")},3391(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   R: () => (/* binding */ textureBit),\n/* harmony export */   m: () => (/* binding */ textureBitGl)\n/* harmony export */ });\n\nconst textureBit = {\n  name: "texture-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: "texture-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=textureBit.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM5MS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanM/MjM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRleHR1cmVCaXQgPSB7XG4gIG5hbWU6IFwidGV4dHVyZS1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG5cbiAgICAgICAgc3RydWN0IFRleHR1cmVVbmlmb3JtcyB7XG4gICAgICAgICAgICB1VGV4dHVyZU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgfVxuXG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXI8dW5pZm9ybT4gdGV4dHVyZVVuaWZvcm1zIDogVGV4dHVyZVVuaWZvcm1zO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB1diA9ICh0ZXh0dXJlVW5pZm9ybXMudVRleHR1cmVNYXRyaXggKiB2ZWMzKHV2LCAxLjApKS54eTtcbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygxKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XG5cblxuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBvdXRDb2xvciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2VVYpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgdGV4dHVyZUJpdEdsID0ge1xuICBuYW1lOiBcInRleHR1cmUtYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1diA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzModXYsIDEuMCkpLnh5O1xuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuXG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlVWKTtcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgdGV4dHVyZUJpdCwgdGV4dHVyZUJpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlQml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3391\n\n}')},6423(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ createUboSyncFunction)\n/* harmony export */ });\n/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8166);\n\n\n"use strict";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$.length; j++) {\n      const uniformParser = _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = "${name}";`,\n          `offset += ${offset - prev};`,\n          _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j][parserCode] || _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join("\\n");\n  return new Function(\n    "uv",\n    "data",\n    "dataInt32",\n    "offset",\n    fragmentSrc\n  );\n}\n\n\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQyMy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLHdFQUFjLFNBQVM7QUFDL0MsNEJBQTRCLHdFQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLEVBQUU7QUFDNUIsdUJBQXVCLGVBQWU7QUFDdEMsVUFBVSx3RUFBYyxtQkFBbUIsd0VBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jRnVuY3Rpb24ubWpzP2UwODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY3JlYXRlVWJvU3luY0Z1bmN0aW9uKHVib0VsZW1lbnRzLCBwYXJzZXJDb2RlLCBhcnJheUdlbmVyYXRpb25GdW5jdGlvbiwgc2luZ2xlU2V0dGVyc01hcCkge1xuICBjb25zdCBmdW5jRnJhZ21lbnRzID0gW2BcbiAgICAgICAgdmFyIHYgPSBudWxsO1xuICAgICAgICB2YXIgdjIgPSBudWxsO1xuICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGFycmF5T2Zmc2V0ID0gbnVsbDtcbiAgICBgXTtcbiAgbGV0IHByZXYgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVib0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdWJvRWxlbWVudCA9IHVib0VsZW1lbnRzW2ldO1xuICAgIGNvbnN0IG5hbWUgPSB1Ym9FbGVtZW50LmRhdGEubmFtZTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgdW5pZm9ybVBhcnNlciA9IHVuaWZvcm1QYXJzZXJzW2pdO1xuICAgICAgaWYgKHVuaWZvcm1QYXJzZXIudGVzdCh1Ym9FbGVtZW50LmRhdGEpKSB7XG4gICAgICAgIG9mZnNldCA9IHVib0VsZW1lbnQub2Zmc2V0IC8gNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKFxuICAgICAgICAgIGBuYW1lID0gXCIke25hbWV9XCI7YCxcbiAgICAgICAgICBgb2Zmc2V0ICs9ICR7b2Zmc2V0IC0gcHJldn07YCxcbiAgICAgICAgICB1bmlmb3JtUGFyc2Vyc1tqXVtwYXJzZXJDb2RlXSB8fCB1bmlmb3JtUGFyc2Vyc1tqXS51Ym9cbiAgICAgICAgKTtcbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBpZiAodWJvRWxlbWVudC5kYXRhLnNpemUgPiAxKSB7XG4gICAgICAgIG9mZnNldCA9IHVib0VsZW1lbnQub2Zmc2V0IC8gNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGFycmF5R2VuZXJhdGlvbkZ1bmN0aW9uKHVib0VsZW1lbnQsIG9mZnNldCAtIHByZXYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gc2luZ2xlU2V0dGVyc01hcFt1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgICAgIG9mZnNldCA9IHVib0VsZW1lbnQub2Zmc2V0IC8gNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKFxuICAgICAgICAgIC8qIHdnc2wgKi9cbiAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gJHtvZmZzZXQgLSBwcmV2fTtcbiAgICAgICAgICAgICAgICAgICAgJHt0ZW1wbGF0ZX07XG4gICAgICAgICAgICAgICAgYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IGZyYWdtZW50U3JjID0gZnVuY0ZyYWdtZW50cy5qb2luKFwiXFxuXCIpO1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFxuICAgIFwidXZcIixcbiAgICBcImRhdGFcIixcbiAgICBcImRhdGFJbnQzMlwiLFxuICAgIFwib2Zmc2V0XCIsXG4gICAgZnJhZ21lbnRTcmNcbiAgKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVVYm9TeW5jRnVuY3Rpb24ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6423\n\n}')},7047(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   W: () => (/* binding */ UboSystem)\n/* harmony export */ });\n/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4577);\n/* harmony import */ var _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(949);\n/* harmony import */ var _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1132);\n\n\n\n\n"use strict";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don\'t have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__/* .unsafeEvalSupported */ .f)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .h({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .h({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\n\n//# sourceMappingURL=UboSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Y7QUFDMUM7QUFDSTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0dBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQU07QUFDNUQ7QUFDQSxhQUFhLG1FQUFXLFdBQVcsbUVBQVc7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQU07QUFDNUQ7QUFDQSxhQUFhLG1FQUFXLFdBQVcsbUVBQVc7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1Vib1N5c3RlbS5tanM/MWU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvYnJvd3Nlci91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi9idWZmZXIvQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4uL2J1ZmZlci9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFVib1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKGFkYXB0b3IpIHtcbiAgICAvKiogQ2FjaGUgb2YgdW5pZm9ybSBidWZmZXIgbGF5b3V0cyBhbmQgc3luYyBmdW5jdGlvbnMsIHNvIHdlIGRvbid0IGhhdmUgdG8gcmUtY3JlYXRlIHRoZW0gKi9cbiAgICB0aGlzLl9zeW5jRnVuY3Rpb25IYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fc3lzdGVtQ2hlY2soKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgZnVuY3Rpb24gYnkgYHBpeGkuanMvdW5zYWZlLWV2YWxgIHRvIHNpbGVuY2VcbiAgICogdGhyb3dpbmcgYW4gZXJyb3IgaWYgcGxhdGZvcm0gZG9lc24ndCBzdXBwb3J0IHVuc2FmZS1ldmFscy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zeXN0ZW1DaGVjaygpIHtcbiAgICBpZiAoIXVuc2FmZUV2YWxTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBhbGxvdyB1bnNhZmUtZXZhbCwgcGxlYXNlIHVzZSBwaXhpLmpzL3Vuc2FmZS1ldmFsIG1vZHVsZSB0byBlbmFibGUgc3VwcG9ydC5cIik7XG4gICAgfVxuICB9XG4gIGVuc3VyZVVuaWZvcm1Hcm91cCh1bmlmb3JtR3JvdXApIHtcbiAgICBjb25zdCB1bmlmb3JtRGF0YSA9IHRoaXMuZ2V0VW5pZm9ybUdyb3VwRGF0YSh1bmlmb3JtR3JvdXApO1xuICAgIHVuaWZvcm1Hcm91cC5idWZmZXIgfHwgKHVuaWZvcm1Hcm91cC5idWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodW5pZm9ybURhdGEubGF5b3V0LnNpemUgLyA0KSxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5VTklGT1JNIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KSk7XG4gIH1cbiAgZ2V0VW5pZm9ybUdyb3VwRGF0YSh1bmlmb3JtR3JvdXApIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY0Z1bmN0aW9uSGFzaFt1bmlmb3JtR3JvdXAuX3NpZ25hdHVyZV0gfHwgdGhpcy5faW5pdFVuaWZvcm1Hcm91cCh1bmlmb3JtR3JvdXApO1xuICB9XG4gIF9pbml0VW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCkge1xuICAgIGNvbnN0IHVuaWZvcm1Hcm91cFNpZ25hdHVyZSA9IHVuaWZvcm1Hcm91cC5fc2lnbmF0dXJlO1xuICAgIGxldCB1bmlmb3JtRGF0YSA9IHRoaXMuX3N5bmNGdW5jdGlvbkhhc2hbdW5pZm9ybUdyb3VwU2lnbmF0dXJlXTtcbiAgICBpZiAoIXVuaWZvcm1EYXRhKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC5rZXlzKHVuaWZvcm1Hcm91cC51bmlmb3JtU3RydWN0dXJlcykubWFwKChpKSA9PiB1bmlmb3JtR3JvdXAudW5pZm9ybVN0cnVjdHVyZXNbaV0pO1xuICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fYWRhcHRvci5jcmVhdGVVYm9FbGVtZW50cyhlbGVtZW50cyk7XG4gICAgICBjb25zdCBzeW5jRnVuY3Rpb24gPSB0aGlzLl9nZW5lcmF0ZVVib1N5bmMobGF5b3V0LnVib0VsZW1lbnRzKTtcbiAgICAgIHVuaWZvcm1EYXRhID0gdGhpcy5fc3luY0Z1bmN0aW9uSGFzaFt1bmlmb3JtR3JvdXBTaWduYXR1cmVdID0ge1xuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHN5bmNGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNGdW5jdGlvbkhhc2hbdW5pZm9ybUdyb3VwU2lnbmF0dXJlXTtcbiAgfVxuICBfZ2VuZXJhdGVVYm9TeW5jKHVib0VsZW1lbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0b3IuZ2VuZXJhdGVVYm9TeW5jKHVib0VsZW1lbnRzKTtcbiAgfVxuICBzeW5jVW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCwgZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgdW5pZm9ybUdyb3VwRGF0YSA9IHRoaXMuZ2V0VW5pZm9ybUdyb3VwRGF0YSh1bmlmb3JtR3JvdXApO1xuICAgIHVuaWZvcm1Hcm91cC5idWZmZXIgfHwgKHVuaWZvcm1Hcm91cC5idWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodW5pZm9ybUdyb3VwRGF0YS5sYXlvdXQuc2l6ZSAvIDQpLFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgIH0pKTtcbiAgICBsZXQgZGF0YUludDMyID0gbnVsbDtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGRhdGEgPSB1bmlmb3JtR3JvdXAuYnVmZmVyLmRhdGE7XG4gICAgICBkYXRhSW50MzIgPSB1bmlmb3JtR3JvdXAuYnVmZmVyLmRhdGFJbnQzMjtcbiAgICB9XG4gICAgb2Zmc2V0IHx8IChvZmZzZXQgPSAwKTtcbiAgICB1bmlmb3JtR3JvdXBEYXRhLnN5bmNGdW5jdGlvbih1bmlmb3JtR3JvdXAudW5pZm9ybXMsIGRhdGEsIGRhdGFJbnQzMiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwKSB7XG4gICAgaWYgKHVuaWZvcm1Hcm91cC5pc1N0YXRpYyAmJiAhdW5pZm9ybUdyb3VwLl9kaXJ0eUlkKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHVuaWZvcm1Hcm91cC5fZGlydHlJZCA9IDA7XG4gICAgY29uc3Qgc3luY2VkID0gdGhpcy5zeW5jVW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCk7XG4gICAgdW5pZm9ybUdyb3VwLmJ1ZmZlci51cGRhdGUoKTtcbiAgICByZXR1cm4gc3luY2VkO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3luY0Z1bmN0aW9uSGFzaCA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgVWJvU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VYm9TeXN0ZW0ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7047\n\n}')},7084(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ ensureAttributes)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(268);\n/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8306);\n\n\n\n"use strict";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .R)(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__/* .getAttributeInfoFromFormat */ .m)(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__/* .getAttributeInfoFromFormat */ .m)(attribute.format).stride;\n  }\n}\n\n\n//# sourceMappingURL=ensureAttributes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUM4Qzs7QUFFM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sc0VBQUksY0FBYyxHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEhBQTBCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEhBQTBCO0FBQ2pFO0FBQ0E7O0FBRTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZW5zdXJlQXR0cmlidXRlcy5tanM/MGQyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVJbmZvRnJvbUZvcm1hdCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9nZW9tZXRyeS91dGlscy9nZXRBdHRyaWJ1dGVJbmZvRnJvbUZvcm1hdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGVuc3VyZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIGV4dHJhY3RlZERhdGEpIHtcbiAgZm9yIChjb25zdCBpIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2ldO1xuICAgIGNvbnN0IGF0dHJpYnV0ZURhdGEgPSBleHRyYWN0ZWREYXRhW2ldO1xuICAgIGlmIChhdHRyaWJ1dGVEYXRhKSB7XG4gICAgICBhdHRyaWJ1dGUuZm9ybWF0ID8/IChhdHRyaWJ1dGUuZm9ybWF0ID0gYXR0cmlidXRlRGF0YS5mb3JtYXQpO1xuICAgICAgYXR0cmlidXRlLm9mZnNldCA/PyAoYXR0cmlidXRlLm9mZnNldCA9IGF0dHJpYnV0ZURhdGEub2Zmc2V0KTtcbiAgICAgIGF0dHJpYnV0ZS5pbnN0YW5jZSA/PyAoYXR0cmlidXRlLmluc3RhbmNlID0gYXR0cmlidXRlRGF0YS5pbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oYEF0dHJpYnV0ZSAke2l9IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzaGFkZXIsIGJ1dCBpcyBwcmVzZW50IGluIHRoZSBnZW9tZXRyeS4gVW5hYmxlIHRvIGluZmVyIGF0dHJpYnV0ZSBkZXRhaWxzLmApO1xuICAgIH1cbiAgfVxuICBlbnN1cmVTdGFydEFuZFN0cmlkZShnZW9tZXRyeSk7XG59XG5mdW5jdGlvbiBlbnN1cmVTdGFydEFuZFN0cmlkZShnZW9tZXRyeSkge1xuICBjb25zdCB7IGJ1ZmZlcnMsIGF0dHJpYnV0ZXMgfSA9IGdlb21ldHJ5O1xuICBjb25zdCB0ZW1wU3RyaWRlID0ge307XG4gIGNvbnN0IHRlbXBTdGFydCA9IHt9O1xuICBmb3IgKGNvbnN0IGogaW4gYnVmZmVycykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgdGVtcFN0cmlkZVtidWZmZXIudWlkXSA9IDA7XG4gICAgdGVtcFN0YXJ0W2J1ZmZlci51aWRdID0gMDtcbiAgfVxuICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyLnVpZF0gKz0gZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQoYXR0cmlidXRlLmZvcm1hdCkuc3RyaWRlO1xuICB9XG4gIGZvciAoY29uc3QgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBhdHRyaWJ1dGUuc3RyaWRlID8/IChhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyLnVpZF0pO1xuICAgIGF0dHJpYnV0ZS5zdGFydCA/PyAoYXR0cmlidXRlLnN0YXJ0ID0gdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXIudWlkXSk7XG4gICAgdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXIudWlkXSArPSBnZXRBdHRyaWJ1dGVJbmZvRnJvbUZvcm1hdChhdHRyaWJ1dGUuZm9ybWF0KS5zdHJpZGU7XG4gIH1cbn1cblxuZXhwb3J0IHsgZW5zdXJlQXR0cmlidXRlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zdXJlQXR0cmlidXRlcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7084\n\n}')},7238(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("{\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  l: () => (/* binding */ RenderTargetSystem)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9313);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(9252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(1257);\n;// ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs\n\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\n\n//# sourceMappingURL=calculateProjection.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs\nvar SystemRunner = __webpack_require__(7729);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(4884);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs\nvar TextureSource = __webpack_require__(583);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 1 modules\nvar Texture = __webpack_require__(5589);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs\nvar getCanvasTexture = __webpack_require__(8725);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs\n\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\n\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs\nvar RenderTarget = __webpack_require__(279);\n;// ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle/* Rectangle */.M();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle/* Rectangle */.M();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner/* SystemRunner */.C(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix/* Matrix */.u();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture/* Texture */.g) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = gl_const/* CLEAR */.u.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = gl_const/* CLEAR */.u.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource/* CanvasSource */.q.test(renderSurface)) {\n      renderSurface = (0,getCanvasTexture/* getCanvasTexture */.c)(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget/* RenderTarget */.O) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource/* TextureSource */.v) {\n      renderTarget = new RenderTarget/* RenderTarget */.O({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource/* CanvasSource */.q) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\n\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3JELHlCQUF5QixnQ0FBWTtBQUNyQztBQUNBLE9BQU87QUFDUCwwQ0FBMEMsZ0NBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9yZW5kZXJUYXJnZXQvY2FsY3VsYXRlUHJvamVjdGlvbi5tanM/Njk1OCIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L2lzUmVuZGVyaW5nVG9TY3JlZW4ubWpzPzc5OWQiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXRTeXN0ZW0ubWpzP2RhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm9qZWN0aW9uKHBtLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmbGlwWSkge1xuICBjb25zdCBzaWduID0gZmxpcFkgPyAxIDogLTE7XG4gIHBtLmlkZW50aXR5KCk7XG4gIHBtLmEgPSAxIC8gd2lkdGggKiAyO1xuICBwbS5kID0gc2lnbiAqICgxIC8gaGVpZ2h0ICogMik7XG4gIHBtLnR4ID0gLTEgLSB4ICogcG0uYTtcbiAgcG0udHkgPSAtc2lnbiAtIHkgKiBwbS5kO1xuICByZXR1cm4gcG07XG59XG5cbmV4cG9ydCB7IGNhbGN1bGF0ZVByb2plY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGN1bGF0ZVByb2plY3Rpb24ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1JlbmRlcmluZ1RvU2NyZWVuKHJlbmRlclRhcmdldCkge1xuICBjb25zdCByZXNvdXJjZSA9IHJlbmRlclRhcmdldC5jb2xvclRleHR1cmUuc291cmNlLnJlc291cmNlO1xuICByZXR1cm4gZ2xvYmFsVGhpcy5IVE1MQ2FudmFzRWxlbWVudCAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMocmVzb3VyY2UpO1xufVxuXG5leHBvcnQgeyBpc1JlbmRlcmluZ1RvU2NyZWVuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1JlbmRlcmluZ1RvU2NyZWVuLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IENMRUFSIH0gZnJvbSAnLi4vLi4vZ2wvY29uc3QubWpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVByb2plY3Rpb24gfSBmcm9tICcuLi8uLi9ncHUvcmVuZGVyVGFyZ2V0L2NhbGN1bGF0ZVByb2plY3Rpb24ubWpzJztcbmltcG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4uL3N5c3RlbS9TeXN0ZW1SdW5uZXIubWpzJztcbmltcG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4uL3RleHR1cmUvc291cmNlcy9DYW52YXNTb3VyY2UubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvdXRpbHMvZ2V0Q2FudmFzVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgaXNSZW5kZXJpbmdUb1NjcmVlbiB9IGZyb20gJy4vaXNSZW5kZXJpbmdUb1NjcmVlbi5tanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9SZW5kZXJUYXJnZXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZW5kZXJUYXJnZXRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8qKiBUaGlzIGlzIHRoZSByb290IHZpZXdwb3J0IGZvciB0aGUgcmVuZGVyIHBhc3MqL1xuICAgIHRoaXMucm9vdFZpZXdQb3J0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIC8qKiB0aGUgY3VycmVudCB2aWV3cG9ydCB0aGF0IHRoZSBncHUgaXMgdXNpbmcgKi9cbiAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIC8qKlxuICAgICAqIGEgcnVubmVyIHRoYXQgbGV0cyBzeXN0ZW1zIGtub3cgaWYgdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IGhhcyBjaGFuZ2VkLlxuICAgICAqIEVnIHRoZSBTdGVuY2lsIFN5c3RlbSBuZWVkcyB0byBrbm93IHNvIGl0IGNhbiBtYW5hZ2UgdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICovXG4gICAgdGhpcy5vblJlbmRlclRhcmdldENoYW5nZSA9IG5ldyBTeXN0ZW1SdW5uZXIoXCJvblJlbmRlclRhcmdldENoYW5nZVwiKTtcbiAgICAvKiogdGhlIHByb2plY3Rpb24gbWF0cml4IHRoYXQgaXMgdXNlZCBieSB0aGUgc2hhZGVycyBiYXNlZCBvbiB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgYW5kIHRoZSB2aWV3cG9ydCAqL1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAvKiogdGhlIGRlZmF1bHQgY2xlYXIgY29sb3IgZm9yIHJlbmRlciB0YXJnZXRzICovXG4gICAgdGhpcy5kZWZhdWx0Q2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICAvKipcbiAgICAgKiBhIGhhc2ggdGhhdCBzdG9yZXMgdGhlIHJlbmRlciB0YXJnZXQgZm9yIGEgZ2l2ZW4gcmVuZGVyIHN1cmZhY2UuIFdoZW4geW91IHBhc3MgaW4gYSB0ZXh0dXJlIHNvdXJjZSxcbiAgICAgKiBhIHJlbmRlciB0YXJnZXQgaXMgY3JlYXRlZCBmb3IgaXQuIFRoaXMgbWFwIHN0b3JlcyBhbmQgbWFrZXMgaXQgZWFzeSB0byByZXRyaWV2ZSB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuICAgIHRoaXMuX3JlbmRlclN1cmZhY2VUb1JlbmRlclRhcmdldEhhc2ggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8qKiBBIGhhc2ggdGhhdCBzdG9yZXMgYSBncHUgcmVuZGVyIHRhcmdldCBmb3IgYSBnaXZlbiByZW5kZXIgdGFyZ2V0LiAqL1xuICAgIHRoaXMuX2dwdVJlbmRlclRhcmdldEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBBIHN0YWNrIHRoYXQgc3RvcmVzIHRoZSByZW5kZXIgdGFyZ2V0IGFuZCBmcmFtZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCB0by5cbiAgICAgKiBXaGVuIHB1c2ggaXMgY2FsbGVkLCB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlzIHN0b3JlZCBpbiB0aGlzIHN0YWNrLlxuICAgICAqIFdoZW4gcG9wIGlzIGNhbGxlZCwgdGhlIHByZXZpb3VzIHJlbmRlciB0YXJnZXQgaXMgcmVzdG9yZWQuXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2sgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnJlbmRlcmFibGVHQy5hZGRNYW5hZ2VkSGFzaCh0aGlzLCBcIl9ncHVSZW5kZXJUYXJnZXRIYXNoXCIpO1xuICB9XG4gIC8qKiBjYWxsZWQgd2hlbiBkZXYgd2FudHMgdG8gZmluaXNoIGEgcmVuZGVyIHBhc3MgKi9cbiAgZmluaXNoUmVuZGVyUGFzcygpIHtcbiAgICB0aGlzLmFkYXB0b3IuZmluaXNoUmVuZGVyUGFzcyh0aGlzLnJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJlciBzdGFydHMgdG8gcmVuZGVyIGEgc2NlbmUuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLnRhcmdldCAtIHRoZSByZW5kZXIgdGFyZ2V0IHRvIHJlbmRlciB0b1xuICAgKiBAcGFyYW0gb3B0aW9ucy5jbGVhciAtIHRoZSBjbGVhciBtb2RlIHRvIHVzZS4gQ2FuIGJlIHRydWUgb3IgYSBDTEVBUiBudW1iZXIgJ0NPTE9SIHwgREVQVEggfCBTVEVOQ0lMJyAwYjExMVxuICAgKiBAcGFyYW0gb3B0aW9ucy5jbGVhckNvbG9yIC0gdGhlIGNvbG9yIHRvIGNsZWFyIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zLmZyYW1lIC0gdGhlIGZyYW1lIHRvIHJlbmRlciB0b1xuICAgKi9cbiAgcmVuZGVyU3RhcnQoe1xuICAgIHRhcmdldCxcbiAgICBjbGVhcixcbiAgICBjbGVhckNvbG9yLFxuICAgIGZyYW1lXG4gIH0pIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMucHVzaChcbiAgICAgIHRhcmdldCxcbiAgICAgIGNsZWFyLFxuICAgICAgY2xlYXJDb2xvcixcbiAgICAgIGZyYW1lXG4gICAgKTtcbiAgICB0aGlzLnJvb3RWaWV3UG9ydC5jb3B5RnJvbSh0aGlzLnZpZXdwb3J0KTtcbiAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gaXNSZW5kZXJpbmdUb1NjcmVlbih0aGlzLnJvb3RSZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuYWRhcHRvci5wcmVyZW5kZXI/Lih0aGlzLnJvb3RSZW5kZXJUYXJnZXQpO1xuICB9XG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgdGhpcy5hZGFwdG9yLnBvc3RyZW5kZXI/Lih0aGlzLnJvb3RSZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kaW5nIGEgcmVuZGVyIHN1cmZhY2UhIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gb2YgdGhlIHJlbmRlciB0YXJnZXQgc3lzdGVtLlxuICAgKiBJdCB3aWxsIHRha2UgdGhlIFJlbmRlclN1cmZhY2UgKHdoaWNoIGNhbiBiZSBhIHRleHR1cmUsIGNhbnZhcywgb3IgcmVuZGVyIHRhcmdldCkgYW5kIGJpbmQgaXQgdG8gdGhlIHJlbmRlcmVyLlxuICAgKiBPbmNlIGJvdW5kIGFsbCBkcmF3IGNhbGxzIHdpbGwgYmUgcmVuZGVyZWQgdG8gdGhlIHJlbmRlciBzdXJmYWNlLlxuICAgKlxuICAgKiBJZiBhIGZyYW1lIGlzIG5vdCBwcm92aWRlIGFuZCB0aGUgcmVuZGVyIHN1cmZhY2UgaXMgYSB0ZXh0dXJlLCB0aGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcmVuZGVyU3VyZmFjZSAtIHRoZSByZW5kZXIgc3VyZmFjZSB0byBiaW5kXG4gICAqIEBwYXJhbSBjbGVhciAtIHRoZSBjbGVhciBtb2RlIHRvIHVzZS4gQ2FuIGJlIHRydWUgb3IgYSBDTEVBUiBudW1iZXIgJ0NPTE9SIHwgREVQVEggfCBTVEVOQ0lMJyAwYjExMVxuICAgKiBAcGFyYW0gY2xlYXJDb2xvciAtIHRoZSBjb2xvciB0byBjbGVhciB0b1xuICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgZnJhbWUgdG8gcmVuZGVyIHRvXG4gICAqIEByZXR1cm5zIHRoZSByZW5kZXIgdGFyZ2V0IHRoYXQgd2FzIGJvdW5kXG4gICAqL1xuICBiaW5kKHJlbmRlclN1cmZhY2UsIGNsZWFyID0gdHJ1ZSwgY2xlYXJDb2xvciwgZnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLmdldFJlbmRlclRhcmdldChyZW5kZXJTdXJmYWNlKTtcbiAgICBjb25zdCBkaWRDaGFuZ2UgPSB0aGlzLnJlbmRlclRhcmdldCAhPT0gcmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyU3VyZmFjZSA9IHJlbmRlclN1cmZhY2U7XG4gICAgY29uc3QgZ3B1UmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LnBpeGVsV2lkdGggIT09IGdwdVJlbmRlclRhcmdldC53aWR0aCB8fCByZW5kZXJUYXJnZXQucGl4ZWxIZWlnaHQgIT09IGdwdVJlbmRlclRhcmdldC5oZWlnaHQpIHtcbiAgICAgIHRoaXMuYWRhcHRvci5yZXNpemVHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICAgIGdwdVJlbmRlclRhcmdldC53aWR0aCA9IHJlbmRlclRhcmdldC5waXhlbFdpZHRoO1xuICAgICAgZ3B1UmVuZGVyVGFyZ2V0LmhlaWdodCA9IHJlbmRlclRhcmdldC5waXhlbEhlaWdodDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG4gICAgY29uc3QgcGl4ZWxXaWR0aCA9IHNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGNvbnN0IHBpeGVsSGVpZ2h0ID0gc291cmNlLnBpeGVsSGVpZ2h0O1xuICAgIGlmICghZnJhbWUgJiYgcmVuZGVyU3VyZmFjZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIGZyYW1lID0gcmVuZGVyU3VyZmFjZS5mcmFtZTtcbiAgICB9XG4gICAgaWYgKGZyYW1lKSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gc291cmNlLl9yZXNvbHV0aW9uO1xuICAgICAgdmlld3BvcnQueCA9IGZyYW1lLnggKiByZXNvbHV0aW9uICsgMC41IHwgMDtcbiAgICAgIHZpZXdwb3J0LnkgPSBmcmFtZS55ICogcmVzb2x1dGlvbiArIDAuNSB8IDA7XG4gICAgICB2aWV3cG9ydC53aWR0aCA9IGZyYW1lLndpZHRoICogcmVzb2x1dGlvbiArIDAuNSB8IDA7XG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uICsgMC41IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld3BvcnQueCA9IDA7XG4gICAgICB2aWV3cG9ydC55ID0gMDtcbiAgICAgIHZpZXdwb3J0LndpZHRoID0gcGl4ZWxXaWR0aDtcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9IHBpeGVsSGVpZ2h0O1xuICAgIH1cbiAgICBjYWxjdWxhdGVQcm9qZWN0aW9uKFxuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB2aWV3cG9ydC53aWR0aCAvIHNvdXJjZS5yZXNvbHV0aW9uLFxuICAgICAgdmlld3BvcnQuaGVpZ2h0IC8gc291cmNlLnJlc29sdXRpb24sXG4gICAgICAhcmVuZGVyVGFyZ2V0LmlzUm9vdFxuICAgICk7XG4gICAgdGhpcy5hZGFwdG9yLnN0YXJ0UmVuZGVyUGFzcyhyZW5kZXJUYXJnZXQsIGNsZWFyLCBjbGVhckNvbG9yLCB2aWV3cG9ydCk7XG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgdGhpcy5vblJlbmRlclRhcmdldENoYW5nZS5lbWl0KHJlbmRlclRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJUYXJnZXQ7XG4gIH1cbiAgY2xlYXIodGFyZ2V0LCBjbGVhciA9IENMRUFSLkFMTCwgY2xlYXJDb2xvcikge1xuICAgIGlmICghY2xlYXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gdGhpcy5nZXRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgdGhpcy5hZGFwdG9yLmNsZWFyKFxuICAgICAgdGFyZ2V0IHx8IHRoaXMucmVuZGVyVGFyZ2V0LFxuICAgICAgY2xlYXIsXG4gICAgICBjbGVhckNvbG9yLFxuICAgICAgdGhpcy52aWV3cG9ydFxuICAgICk7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLl9ncHVSZW5kZXJUYXJnZXRIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2ggYSByZW5kZXIgc3VyZmFjZSB0byB0aGUgcmVuZGVyZXIuIFRoaXMgd2lsbCBiaW5kIHRoZSByZW5kZXIgc3VyZmFjZSB0byB0aGUgcmVuZGVyZXIsXG4gICAqIEBwYXJhbSByZW5kZXJTdXJmYWNlIC0gdGhlIHJlbmRlciBzdXJmYWNlIHRvIHB1c2hcbiAgICogQHBhcmFtIGNsZWFyIC0gdGhlIGNsZWFyIG1vZGUgdG8gdXNlLiBDYW4gYmUgdHJ1ZSBvciBhIENMRUFSIG51bWJlciAnQ09MT1IgfCBERVBUSCB8IFNURU5DSUwnIDBiMTExXG4gICAqIEBwYXJhbSBjbGVhckNvbG9yIC0gdGhlIGNvbG9yIHRvIGNsZWFyIHRvXG4gICAqIEBwYXJhbSBmcmFtZSAtIHRoZSBmcmFtZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdG8gdGhlIHJlbmRlciBzdXJmYWNlXG4gICAqL1xuICBwdXNoKHJlbmRlclN1cmZhY2UsIGNsZWFyID0gQ0xFQVIuQUxMLCBjbGVhckNvbG9yLCBmcmFtZSkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMuYmluZChyZW5kZXJTdXJmYWNlLCBjbGVhciwgY2xlYXJDb2xvciwgZnJhbWUpO1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN0YWNrLnB1c2goe1xuICAgICAgcmVuZGVyVGFyZ2V0LFxuICAgICAgZnJhbWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICB9XG4gIC8qKiBQb3BzIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXQgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIHJlc3RvcmVzIHRoZSBwcmV2aW91cyByZW5kZXIgdGFyZ2V0LiAqL1xuICBwb3AoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2sucG9wKCk7XG4gICAgY29uc3QgY3VycmVudFJlbmRlclRhcmdldERhdGEgPSB0aGlzLl9yZW5kZXJUYXJnZXRTdGFja1t0aGlzLl9yZW5kZXJUYXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmJpbmQoY3VycmVudFJlbmRlclRhcmdldERhdGEucmVuZGVyVGFyZ2V0LCBmYWxzZSwgbnVsbCwgY3VycmVudFJlbmRlclRhcmdldERhdGEuZnJhbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZW5kZXIgdGFyZ2V0IGZyb20gdGhlIHByb3ZpZGUgcmVuZGVyIHN1cmZhY2UuIEVnIGlmIGl0cyBhIHRleHR1cmUsXG4gICAqIGl0IHdpbGwgcmV0dXJuIHRoZSByZW5kZXIgdGFyZ2V0IGZvciB0aGUgdGV4dHVyZS5cbiAgICogSWYgaXRzIGEgcmVuZGVyIHRhcmdldCwgaXQgd2lsbCByZXR1cm4gdGhlIHNhbWUgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHJlbmRlclN1cmZhY2UgLSB0aGUgcmVuZGVyIHN1cmZhY2UgdG8gZ2V0IHRoZSByZW5kZXIgdGFyZ2V0IGZvclxuICAgKiBAcmV0dXJucyB0aGUgcmVuZGVyIHRhcmdldCBmb3IgdGhlIHJlbmRlciBzdXJmYWNlXG4gICAqL1xuICBnZXRSZW5kZXJUYXJnZXQocmVuZGVyU3VyZmFjZSkge1xuICAgIGlmIChyZW5kZXJTdXJmYWNlLmlzVGV4dHVyZSkge1xuICAgICAgcmVuZGVyU3VyZmFjZSA9IHJlbmRlclN1cmZhY2Uuc291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyU3VyZmFjZVRvUmVuZGVyVGFyZ2V0SGFzaC5nZXQocmVuZGVyU3VyZmFjZSkgPz8gdGhpcy5faW5pdFJlbmRlclRhcmdldChyZW5kZXJTdXJmYWNlKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGEgcmVuZGVyIHN1cmZhY2UgdG8gYW5vdGhlciB0ZXh0dXJlLlxuICAgKlxuICAgKiBOT1RFOlxuICAgKiBmb3Igc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmUsIFRoZSByZW5kZXIgdGFyZ2V0IG11c3QgYmUgc29tZXRoaW5nIHRoYXQgaXMgd3JpdHRlbiB0b28gYnkgdGhlIHJlbmRlcmVyXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgaXMgbm90IHZhbGlkOlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgKiBjYW52YXMud2lkdGggPSAyMDA7XG4gICAqIGNhbnZhcy5oZWlnaHQgPSAyMDA7XG4gICAqXG4gICAqIGNvbnN0IGN0eCA9IGNhbnZhczIuZ2V0Q29udGV4dCgnMmQnKSFcbiAgICogY3R4LmZpbGxTdHlsZSA9ICdyZWQnXG4gICAqIGN0eC5maWxsUmVjdCgwLCAwLCAyMDAsIDIwMCk7XG4gICAqXG4gICAqIGNvbnN0IHRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLmNyZWF0ZSh7XG4gICAqICAgd2lkdGg6IDIwMCxcbiAgICogICBoZWlnaHQ6IDIwMCxcbiAgICogfSlcbiAgICogY29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmdldFJlbmRlclRhcmdldChjYW52YXMyKTtcbiAgICpcbiAgICogcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNvcHlUb1RleHR1cmUocmVuZGVyVGFyZ2V0LHRleHR1cmUsIHt4OjAseTowfSx7d2lkdGg6MjAwLGhlaWdodDoyMDB9LHt4OjAseTowfSk7XG4gICAqXG4gICAqIFRoZSBiZXN0IHdheSB0byBjb3B5IGEgY2FudmFzIGlzIHRvIGNyZWF0ZSBhIHRleHR1cmUgZnJvbSBpdC4gVGhlbiByZW5kZXIgd2l0aCB0aGF0LlxuICAgKlxuICAgKiBQYXJzaW5nIGluIGEgUmVuZGVyVGFyZ2V0IGNhbnZhcyBjb250ZXh0ICh3aXRoIGEgMmQgY29udGV4dClcbiAgICogQHBhcmFtIHNvdXJjZVJlbmRlclN1cmZhY2VUZXh0dXJlIC0gdGhlIHJlbmRlciBzdXJmYWNlIHRvIGNvcHkgZnJvbVxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25UZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gY29weSB0b1xuICAgKiBAcGFyYW0gb3JpZ2luU3JjIC0gdGhlIG9yaWdpbiBvZiB0aGUgY29weVxuICAgKiBAcGFyYW0gb3JpZ2luU3JjLnggLSB0aGUgeCBvcmlnaW4gb2YgdGhlIGNvcHlcbiAgICogQHBhcmFtIG9yaWdpblNyYy55IC0gdGhlIHkgb3JpZ2luIG9mIHRoZSBjb3B5XG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGNvcHlcbiAgICogQHBhcmFtIHNpemUud2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGNvcHlcbiAgICogQHBhcmFtIHNpemUuaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgY29weVxuICAgKiBAcGFyYW0gb3JpZ2luRGVzdCAtIHRoZSBkZXN0aW5hdGlvbiBvcmlnaW4gKHRvcCBsZWZ0IHRvIHBhc3RlIGZyb20hKVxuICAgKiBAcGFyYW0gb3JpZ2luRGVzdC54IC0gdGhlIHggb3JpZ2luIG9mIHRoZSBwYXN0ZVxuICAgKiBAcGFyYW0gb3JpZ2luRGVzdC55IC0gdGhlIHkgb3JpZ2luIG9mIHRoZSBwYXN0ZVxuICAgKi9cbiAgY29weVRvVGV4dHVyZShzb3VyY2VSZW5kZXJTdXJmYWNlVGV4dHVyZSwgZGVzdGluYXRpb25UZXh0dXJlLCBvcmlnaW5TcmMsIHNpemUsIG9yaWdpbkRlc3QpIHtcbiAgICBpZiAob3JpZ2luU3JjLnggPCAwKSB7XG4gICAgICBzaXplLndpZHRoICs9IG9yaWdpblNyYy54O1xuICAgICAgb3JpZ2luRGVzdC54IC09IG9yaWdpblNyYy54O1xuICAgICAgb3JpZ2luU3JjLnggPSAwO1xuICAgIH1cbiAgICBpZiAob3JpZ2luU3JjLnkgPCAwKSB7XG4gICAgICBzaXplLmhlaWdodCArPSBvcmlnaW5TcmMueTtcbiAgICAgIG9yaWdpbkRlc3QueSAtPSBvcmlnaW5TcmMueTtcbiAgICAgIG9yaWdpblNyYy55ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeyBwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCB9ID0gc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmU7XG4gICAgc2l6ZS53aWR0aCA9IE1hdGgubWluKHNpemUud2lkdGgsIHBpeGVsV2lkdGggLSBvcmlnaW5TcmMueCk7XG4gICAgc2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihzaXplLmhlaWdodCwgcGl4ZWxIZWlnaHQgLSBvcmlnaW5TcmMueSk7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRvci5jb3B5VG9UZXh0dXJlKFxuICAgICAgc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmUsXG4gICAgICBkZXN0aW5hdGlvblRleHR1cmUsXG4gICAgICBvcmlnaW5TcmMsXG4gICAgICBzaXplLFxuICAgICAgb3JpZ2luRGVzdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIGVuc3VyZXMgdGhhdCB3ZSBoYXZlIGEgZGVwdGggc3RlbmNpbCBidWZmZXIgYXZhaWxhYmxlIHRvIHJlbmRlciB0b1xuICAgKiBUaGlzIGlzIHVzZWQgYnkgdGhlIG1hc2sgc3lzdGVtIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXG4gICAqL1xuICBlbnN1cmVEZXB0aFN0ZW5jaWwoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlclRhcmdldC5zdGVuY2lsKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC5zdGVuY2lsID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRhcHRvci5zdGFydFJlbmRlclBhc3ModGhpcy5yZW5kZXJUYXJnZXQsIGZhbHNlLCBudWxsLCB0aGlzLnZpZXdwb3J0KTtcbiAgICB9XG4gIH1cbiAgLyoqIG51a2VzIHRoZSByZW5kZXIgdGFyZ2V0IHN5c3RlbSAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJTdXJmYWNlVG9SZW5kZXJUYXJnZXRIYXNoLmZvckVhY2goKHJlbmRlclRhcmdldCwga2V5KSA9PiB7XG4gICAgICBpZiAocmVuZGVyVGFyZ2V0ICE9PSBrZXkpIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9yZW5kZXJTdXJmYWNlVG9SZW5kZXJUYXJnZXRIYXNoLmNsZWFyKCk7XG4gICAgdGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIF9pbml0UmVuZGVyVGFyZ2V0KHJlbmRlclN1cmZhY2UpIHtcbiAgICBsZXQgcmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICBpZiAoQ2FudmFzU291cmNlLnRlc3QocmVuZGVyU3VyZmFjZSkpIHtcbiAgICAgIHJlbmRlclN1cmZhY2UgPSBnZXRDYW52YXNUZXh0dXJlKHJlbmRlclN1cmZhY2UpLnNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHJlbmRlclN1cmZhY2UgaW5zdGFuY2VvZiBSZW5kZXJUYXJnZXQpIHtcbiAgICAgIHJlbmRlclRhcmdldCA9IHJlbmRlclN1cmZhY2U7XG4gICAgfSBlbHNlIGlmIChyZW5kZXJTdXJmYWNlIGluc3RhbmNlb2YgVGV4dHVyZVNvdXJjZSkge1xuICAgICAgcmVuZGVyVGFyZ2V0ID0gbmV3IFJlbmRlclRhcmdldCh7XG4gICAgICAgIGNvbG9yVGV4dHVyZXM6IFtyZW5kZXJTdXJmYWNlXVxuICAgICAgfSk7XG4gICAgICBpZiAocmVuZGVyU3VyZmFjZS5zb3VyY2UgaW5zdGFuY2VvZiBDYW52YXNTb3VyY2UpIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmlzUm9vdCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZW5kZXJTdXJmYWNlLm9uY2UoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3VyZmFjZVRvUmVuZGVyVGFyZ2V0SGFzaC5kZWxldGUocmVuZGVyU3VyZmFjZSk7XG4gICAgICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHRoaXMuX2dwdVJlbmRlclRhcmdldEhhc2hbcmVuZGVyVGFyZ2V0LnVpZF07XG4gICAgICAgIGlmIChncHVSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLl9ncHVSZW5kZXJUYXJnZXRIYXNoW3JlbmRlclRhcmdldC51aWRdID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmFkYXB0b3IuZGVzdHJveUdwdVJlbmRlclRhcmdldChncHVSZW5kZXJUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyU3VyZmFjZVRvUmVuZGVyVGFyZ2V0SGFzaC5zZXQocmVuZGVyU3VyZmFjZSwgcmVuZGVyVGFyZ2V0KTtcbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICB9XG4gIGdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaFtyZW5kZXJUYXJnZXQudWlkXSB8fCAodGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaFtyZW5kZXJUYXJnZXQudWlkXSA9IHRoaXMuYWRhcHRvci5pbml0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkpO1xuICB9XG4gIHJlc2V0U3RhdGUoKSB7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyU3VyZmFjZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVuZGVyVGFyZ2V0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUYXJnZXRTeXN0ZW0ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7238\n\n}")},8166(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ uniformParsers)\n/* harmony export */ });\n\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: "mat3x3<f32>",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: "vec4<f32>",\n    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: "vec2<f32>",\n    test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: "vec4<f32>",\n    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: "vec3<f32>",\n    test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\n\n//# sourceMappingURL=uniformParsers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci91dGlscy91bmlmb3JtUGFyc2Vycy5tanM/M2MzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHVuaWZvcm1QYXJzZXJzID0gW1xuICAvLyB1cGxvYWRpbmcgcGl4aSBtYXRyaXggb2JqZWN0IHRvIG1hdDNcbiAge1xuICAgIHR5cGU6IFwibWF0M3gzPGYzMj5cIixcbiAgICB0ZXN0OiAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlLmEgIT09IHZvaWQgMDtcbiAgICB9LFxuICAgIHVibzogYFxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHV2W25hbWVdLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICBkYXRhW29mZnNldF0gPSBtYXRyaXhbMF07XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gbWF0cml4WzFdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IG1hdHJpeFsyXTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNF0gPSBtYXRyaXhbM107XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDVdID0gbWF0cml4WzRdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA9IG1hdHJpeFs1XTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPSBtYXRyaXhbNl07XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDldID0gbWF0cml4WzddO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxMF0gPSBtYXRyaXhbOF07XG4gICAgICAgIGAsXG4gICAgdW5pZm9ybTogYFxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1ZFtuYW1lXS5sb2NhdGlvbiwgZmFsc2UsIHV2W25hbWVdLnRvQXJyYXkodHJ1ZSkpO1xuICAgICAgICBgXG4gIH0sXG4gIC8vIHVwbG9hZGluZyBhIHBpeGkgcmVjdGFuZ2xlIGFzIGEgdmVjNFxuICB7XG4gICAgdHlwZTogXCJ2ZWM0PGYzMj5cIixcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcInZlYzQ8ZjMyPlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiBkYXRhLnZhbHVlLndpZHRoICE9PSB2b2lkIDAsXG4gICAgdWJvOiBgXG4gICAgICAgICAgICB2ID0gdXZbbmFtZV07XG4gICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2Lng7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gdi55O1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IHYud2lkdGg7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDNdID0gdi5oZWlnaHQ7XG4gICAgICAgIGAsXG4gICAgdW5pZm9ybTogYFxuICAgICAgICAgICAgY3YgPSB1ZFtuYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIHYgPSB1dltuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkgfHwgY3ZbMl0gIT09IHYud2lkdGggfHwgY3ZbM10gIT09IHYuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XG4gICAgICAgICAgICAgICAgY3ZbMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgICAgIGN2WzNdID0gdi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW25hbWVdLmxvY2F0aW9uLCB2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gIH0sXG4gIC8vIHVwbG9hZGluZyBhIHBpeGkgcG9pbnQgYXMgYSB2ZWMyXG4gIHtcbiAgICB0eXBlOiBcInZlYzI8ZjMyPlwiLFxuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMjxmMzI+XCIgJiYgZGF0YS5zaXplID09PSAxICYmIGRhdGEudmFsdWUueCAhPT0gdm9pZCAwLFxuICAgIHVibzogYFxuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi54O1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHYueTtcbiAgICAgICAgYCxcbiAgICB1bmlmb3JtOiBgXG4gICAgICAgICAgICBjdiA9IHVkW25hbWVdLnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgaWYgKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSkge1xuICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZFtuYW1lXS5sb2NhdGlvbiwgdi54LCB2LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gIH0sXG4gIC8vIHVwbG9hZGluZyBhIHBpeGkgY29sb3IgYXMgYSB2ZWM0XG4gIHtcbiAgICB0eXBlOiBcInZlYzQ8ZjMyPlwiLFxuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNDxmMzI+XCIgJiYgZGF0YS5zaXplID09PSAxICYmIGRhdGEudmFsdWUucmVkICE9PSB2b2lkIDAsXG4gICAgdWJvOiBgXG4gICAgICAgICAgICB2ID0gdXZbbmFtZV07XG4gICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2LnJlZDtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSB2LmFscGhhO1xuICAgICAgICBgLFxuICAgIHVuaWZvcm06IGBcbiAgICAgICAgICAgIGN2ID0gdWRbbmFtZV0udmFsdWU7XG4gICAgICAgICAgICB2ID0gdXZbbmFtZV07XG4gICAgICAgICAgICBpZiAoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUgfHwgY3ZbM10gIT09IHYuYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICBjdlsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICBjdlszXSA9IHYuYWxwaGE7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW25hbWVdLmxvY2F0aW9uLCB2LnJlZCwgdi5ncmVlbiwgdi5ibHVlLCB2LmFscGhhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWRpbmcgYSBwaXhpIGNvbG9yIGFzIGEgdmVjM1xuICB7XG4gICAgdHlwZTogXCJ2ZWMzPGYzMj5cIixcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcInZlYzM8ZjMyPlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiBkYXRhLnZhbHVlLnJlZCAhPT0gdm9pZCAwLFxuICAgIHVibzogYFxuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2LmJsdWU7XG4gICAgICAgIGAsXG4gICAgdW5pZm9ybTogYFxuICAgICAgICAgICAgY3YgPSB1ZFtuYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIHYgPSB1dltuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdlswXSAhPT0gdi5yZWQgfHwgY3ZbMV0gIT09IHYuZ3JlZW4gfHwgY3ZbMl0gIT09IHYuYmx1ZSkge1xuICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgY3ZbMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgIGN2WzJdID0gdi5ibHVlO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZih1ZFtuYW1lXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgfVxuXTtcblxuZXhwb3J0IHsgdW5pZm9ybVBhcnNlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaWZvcm1QYXJzZXJzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8166\n\n}')},8422(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ BatchableSprite)\n/* harmony export */ });\n\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = "default";\n    this.topology = "triangle-list";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\n\n//# sourceMappingURL=BatchableSprite.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQyMi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanM/ZGNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoYWJsZVNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlck5hbWUgPSBcImRlZmF1bHRcIjtcbiAgICB0aGlzLnRvcG9sb2d5ID0gXCJ0cmlhbmdsZS1saXN0XCI7XG4gICAgLy8gYmF0Y2ggc3BlY2lmaWMuLlxuICAgIHRoaXMuYXR0cmlidXRlU2l6ZSA9IDQ7XG4gICAgdGhpcy5pbmRleFNpemUgPSA2O1xuICAgIHRoaXMucGFja0FzUXVhZCA9IHRydWU7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IDA7XG4gICAgdGhpcy5fYXR0cmlidXRlU3RhcnQgPSAwO1xuICAgIC8vIGxvY2F0aW9uIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLl9iYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJhYmxlLmdyb3VwQmxlbmRNb2RlO1xuICB9XG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJhYmxlLmdyb3VwQ29sb3JBbHBoYTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5fYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5fYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoYWJsZVNwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hhYmxlU3ByaXRlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8422\n\n}')},8725(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ getCanvasTexture)\n/* harmony export */ });\n/* unused harmony export hasCachedCanvasTexture */\n/* harmony import */ var _utils_pool_GlobalResourceRegistry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6083);\n/* harmony import */ var _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4884);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5589);\n\n\n\n\n"use strict";\nconst canvasCache = /* @__PURE__ */ new Map();\n_utils_pool_GlobalResourceRegistry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .GlobalResourceRegistry */ .L.register(canvasCache);\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .g({\n      source: new _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .CanvasSource */ .q({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once("destroy", onDestroy);\n    texture.source.once("destroy", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\n\n//# sourceMappingURL=getCanvasTexture.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcyNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThGO0FBQ25DO0FBQ2xCOztBQUV6QztBQUNBO0FBQ0EsbUdBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx3QkFBd0IsMERBQU87QUFDL0Isa0JBQWtCLDRFQUFZO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0Q2FudmFzVGV4dHVyZS5tanM/ODA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHbG9iYWxSZXNvdXJjZVJlZ2lzdHJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvcG9vbC9HbG9iYWxSZXNvdXJjZVJlZ2lzdHJ5Lm1qcyc7XG5pbXBvcnQgeyBDYW52YXNTb3VyY2UgfSBmcm9tICcuLi9zb3VyY2VzL0NhbnZhc1NvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL1RleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjYW52YXNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5HbG9iYWxSZXNvdXJjZVJlZ2lzdHJ5LnJlZ2lzdGVyKGNhbnZhc0NhY2hlKTtcbmZ1bmN0aW9uIGdldENhbnZhc1RleHR1cmUoY2FudmFzLCBvcHRpb25zKSB7XG4gIGlmICghY2FudmFzQ2FjaGUuaGFzKGNhbnZhcykpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgQ2FudmFzU291cmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IGNhbnZhcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBvbkRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICBpZiAoY2FudmFzQ2FjaGUuZ2V0KGNhbnZhcykgPT09IHRleHR1cmUpIHtcbiAgICAgICAgY2FudmFzQ2FjaGUuZGVsZXRlKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0ZXh0dXJlLm9uY2UoXCJkZXN0cm95XCIsIG9uRGVzdHJveSk7XG4gICAgdGV4dHVyZS5zb3VyY2Uub25jZShcImRlc3Ryb3lcIiwgb25EZXN0cm95KTtcbiAgICBjYW52YXNDYWNoZS5zZXQoY2FudmFzLCB0ZXh0dXJlKTtcbiAgfVxuICByZXR1cm4gY2FudmFzQ2FjaGUuZ2V0KGNhbnZhcyk7XG59XG5mdW5jdGlvbiBoYXNDYWNoZWRDYW52YXNUZXh0dXJlKGNhbnZhcykge1xuICByZXR1cm4gY2FudmFzQ2FjaGUuaGFzKGNhbnZhcyk7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc1RleHR1cmUsIGhhc0NhY2hlZENhbnZhc1RleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENhbnZhc1RleHR1cmUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8725\n\n}')}}]);