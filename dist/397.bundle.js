"use strict";(self.webpackChunkneural_racer=self.webpackChunkneural_racer||[]).push([[397],{8397(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('{\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(8507);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 13 modules\nvar Container = __webpack_require__(266);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(4458);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(7309);\n;// ./node_modules/pixi.js/lib/dom/CanvasObserver.mjs\n\n\n\n"use strict";\nclass CanvasObserver {\n  constructor(options) {\n    /** A cached value of the last transform applied to the DOM element. */\n    this._lastTransform = "";\n    /** A ResizeObserver instance to observe changes in the canvas size. */\n    this._observer = null;\n    /** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */\n    this._tickerAttached = false;\n    /**\n     * Updates the transform of the DOM element based on the canvas size and position.\n     * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.\n     */\n    this.updateTranslation = () => {\n      if (!this._canvas)\n        return;\n      const rect = this._canvas.getBoundingClientRect();\n      const contentWidth = this._canvas.width;\n      const contentHeight = this._canvas.height;\n      const sx = rect.width / contentWidth * this._renderer.resolution;\n      const sy = rect.height / contentHeight * this._renderer.resolution;\n      const tx = rect.left;\n      const ty = rect.top;\n      const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;\n      if (newTransform !== this._lastTransform) {\n        this._domElement.style.transform = newTransform;\n        this._lastTransform = newTransform;\n      }\n    };\n    this._domElement = options.domElement;\n    this._renderer = options.renderer;\n    if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas)\n      return;\n    this._canvas = this._renderer.canvas;\n    this._attachObserver();\n  }\n  /** The canvas element that this CanvasObserver is associated with. */\n  get canvas() {\n    return this._canvas;\n  }\n  /** Attaches the DOM element to the canvas parent if it is not already attached. */\n  ensureAttached() {\n    if (!this._domElement.parentNode && this._canvas.parentNode) {\n      this._canvas.parentNode.appendChild(this._domElement);\n      this.updateTranslation();\n    }\n  }\n  /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */\n  _attachObserver() {\n    if ("ResizeObserver" in globalThis) {\n      if (this._observer) {\n        this._observer.disconnect();\n        this._observer = null;\n      }\n      this._observer = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.target !== this._canvas) {\n            continue;\n          }\n          const contentWidth = this.canvas.width;\n          const contentHeight = this.canvas.height;\n          const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;\n          const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;\n          const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;\n          if (needsUpdate) {\n            this.updateTranslation();\n            this._lastScaleX = sx;\n            this._lastScaleY = sy;\n          }\n        }\n      });\n      this._observer.observe(this._canvas);\n    } else if (!this._tickerAttached) {\n      Ticker/* Ticker */.R.shared.add(this.updateTranslation, this, ticker_const/* UPDATE_PRIORITY */.d.HIGH);\n    }\n  }\n  /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */\n  destroy() {\n    if (this._observer) {\n      this._observer.disconnect();\n      this._observer = null;\n    } else if (this._tickerAttached) {\n      Ticker/* Ticker */.R.shared.remove(this.updateTranslation);\n    }\n    this._domElement = null;\n    this._renderer = null;\n    this._canvas = null;\n    this._tickerAttached = false;\n    this._lastTransform = "";\n    this._lastScaleX = null;\n    this._lastScaleY = null;\n  }\n}\n\n\n//# sourceMappingURL=CanvasObserver.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(5101);\n;// ./node_modules/pixi.js/lib/events/FederatedEvent.mjs\n\n\n"use strict";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary\'s jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new Point/* Point */.b();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new Point/* Point */.b();\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    this.NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    this.CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    this.AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated `InteractionEvent.data`.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /**\n   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n   * @advanced\n   */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n   * @deprecated\n   * @ignore\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n   * @ignore\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /**\n   * Prevent default behavior of both PixiJS and the user agent.\n   * @example\n   * ```ts\n   * sprite.on(\'click\', (event) => {\n   *     // Prevent both browser\'s default click behavior\n   *     // and PixiJS\'s default handling\n   *     event.preventDefault();\n   *\n   *     // Custom handling\n   *     customClickHandler();\n   * });\n   * ```\n   * @remarks\n   * - Only works if the native event is cancelable\n   * - Does not stop event propagation\n   */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any additional listeners, including those\n   * on the current target and any following targets in the propagation path.\n   * @example\n   * ```ts\n   * container.on(\'pointerdown\', (event) => {\n   *     // Stop all further event handling\n   *     event.stopImmediatePropagation();\n   *\n   *     // These handlers won\'t be called:\n   *     // - Other pointerdown listeners on this container\n   *     // - Any pointerdown listeners on parent containers\n   * });\n   * ```\n   * @remarks\n   * - Immediately stops all event propagation\n   * - Prevents other listeners on same target from being called\n   * - More aggressive than stopPropagation()\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next target in the propagation path.\n   * The rest of the listeners on the current target will still be notified.\n   * @example\n   * ```ts\n   * child.on(\'pointermove\', (event) => {\n   *     // Handle event on child\n   *     updateChild();\n   *\n   *     // Prevent parent handlers from being called\n   *     event.stopPropagation();\n   * });\n   *\n   * // This won\'t be called if child handles the event\n   * parent.on(\'pointermove\', (event) => {\n   *     updateParent();\n   * });\n   * ```\n   * @remarks\n   * - Stops event bubbling to parent containers\n   * - Does not prevent other listeners on same target\n   * - Less aggressive than stopImmediatePropagation()\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n\n;// ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== \'undefined\' &&\n        navigator.platform === \'MacIntel\' &&\n        typeof navigator.maxTouchPoints === \'number\' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === \'undefined\');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: \'\',\n        platform: \'\',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== \'undefined\') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === \'string\') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split(\'[FBAN\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split(\'Twitter\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n//# sourceMappingURL=isMobile.js.map\n;// ./node_modules/pixi.js/lib/utils/browser/isMobile.mjs\n\n\n"use strict";\nconst isMobileCall = isMobile["default"] ?? isMobile;\nconst isMobile_isMobile = isMobileCall(globalThis.navigator);\n\n\n//# sourceMappingURL=isMobile.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(9903);\n;// ./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs\n\n\n\n\n\n\n"use strict";\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nconst _AccessibilitySystem = class _AccessibilitySystem {\n  // eslint-disable-next-line jsdoc/require-param\n  /**\n   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer, _mobileInfo = isMobile_isMobile) {\n    this._mobileInfo = _mobileInfo;\n    /** Whether accessibility divs are visible for debugging */\n    this.debug = false;\n    /** Whether to activate on tab key press */\n    this._activateOnTab = true;\n    /** Whether to deactivate accessibility when mouse moves */\n    this._deactivateOnMouseMove = true;\n    /** Internal variable, see isActive getter. */\n    this._isActive = false;\n    /** Internal variable, see isMobileAccessibility getter. */\n    this._isMobileAccessibility = false;\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    this._div = null;\n    /** A simple pool for storing divs. */\n    this._pools = {};\n    /** This is a tick used to check if an object is no longer being rendered. */\n    this._renderId = 0;\n    /** The array of currently active accessible items. */\n    this._children = [];\n    /** Count to throttle div updates on android devices. */\n    this._androidUpdateCount = 0;\n    /**  The frequency to update the div elements. */\n    this._androidUpdateFrequency = 500;\n    // eslint-disable-next-line @typescript-eslint/prefer-readonly\n    this._isRunningTests = false;\n    /** Bound function references for proper event listener removal */\n    this._boundOnKeyDown = this._onKeyDown.bind(this);\n    this._boundOnMouseMove = this._onMouseMove.bind(this);\n    this._hookDiv = null;\n    if (_mobileInfo.tablet || _mobileInfo.phone) {\n      this._createTouchHook();\n    }\n    this._renderer = renderer;\n  }\n  /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @type {boolean}\n   * @readonly\n   */\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @type {boolean}\n   * @readonly\n   */\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  /**\n   * Button element for handling touch hooks.\n   * @readonly\n   */\n  get hookDiv() {\n    return this._hookDiv;\n  }\n  /**\n   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n   * @readonly\n   */\n  get div() {\n    return this._div;\n  }\n  /**\n   * Creates the touch hooks.\n   * @private\n   */\n  _createTouchHook() {\n    const hookDiv = document.createElement("button");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = "absolute";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = "#FF0000";\n    hookDiv.title = "select to enable accessibility for this content";\n    hookDiv.addEventListener("focus", () => {\n      this._isMobileAccessibility = true;\n      this._activate();\n      this._destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  /**\n   * Destroys the touch hooks.\n   * @private\n   */\n  _destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */\n  _activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    if (!this._div) {\n      this._div = document.createElement("div");\n      this._div.style.position = "absolute";\n      this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n      this._div.style.pointerEvents = "none";\n      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      this._canvasObserver = new CanvasObserver({\n        domElement: this._div,\n        renderer: this._renderer\n      });\n    }\n    if (this._activateOnTab) {\n      globalThis.addEventListener("keydown", this._boundOnKeyDown, false);\n    }\n    if (this._deactivateOnMouseMove) {\n      globalThis.document.addEventListener("mousemove", this._boundOnMouseMove, true);\n    }\n    const canvas = this._renderer.view.canvas;\n    if (!canvas.parentNode) {\n      const observer = new MutationObserver(() => {\n        if (canvas.parentNode) {\n          observer.disconnect();\n          this._canvasObserver.ensureAttached();\n          this._initAccessibilitySetup();\n        }\n      });\n      observer.observe(document.body, { childList: true, subtree: true });\n    } else {\n      this._canvasObserver.ensureAttached();\n      this._initAccessibilitySetup();\n    }\n  }\n  // New method to handle initialization after div is ready\n  _initAccessibilitySetup() {\n    this._renderer.runners.postrender.add(this);\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n    }\n  }\n  /**\n   * Deactivates the accessibility system. Removes listeners and accessibility elements.\n   * @private\n   */\n  _deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);\n    if (this._activateOnTab) {\n      globalThis.addEventListener("keydown", this._boundOnKeyDown, false);\n    }\n    this._renderer.runners.postrender.remove(this);\n    for (const child of this._children) {\n      if (child._accessibleDiv?.parentNode) {\n        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n        child._accessibleDiv = null;\n      }\n      child._accessibleActive = false;\n    }\n    for (const accessibleType in this._pools) {\n      const pool = this._pools[accessibleType];\n      pool.forEach((div) => {\n        if (div.parentNode) {\n          div.parentNode.removeChild(div);\n        }\n      });\n      delete this._pools[accessibleType];\n    }\n    if (this._div?.parentNode) {\n      this._div.parentNode.removeChild(this._div);\n    }\n    this._pools = {};\n    this._children = [];\n  }\n  /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {Container} container - The Container to check.\n   */\n  _updateAccessibleObjects(container) {\n    if (!container.visible || !container.accessibleChildren) {\n      return;\n    }\n    if (container.accessible) {\n      if (!container._accessibleActive) {\n        this._addChild(container);\n      }\n      container._renderId = this._renderId;\n    }\n    const children = container.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this._updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const defaultOpts = _AccessibilitySystem.defaultOptions;\n    const mergedOptions = {\n      accessibilityOptions: {\n        ...defaultOpts,\n        ...options?.accessibilityOptions || {}\n      }\n    };\n    this.debug = mergedOptions.accessibilityOptions.debug;\n    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n    if (mergedOptions.accessibilityOptions.enabledByDefault) {\n      this._activate();\n    }\n    this._renderer.runners.postrender.remove(this);\n  }\n  /**\n   * Updates the accessibility layer during rendering.\n   * - Removes divs for containers no longer in the scene\n   * - Updates the position and dimensions of the root div\n   * - Updates positions of active accessibility divs\n   * Only fires while the accessibility system is active.\n   * @ignore\n   */\n  postrender() {\n    const now = performance.now();\n    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {\n      return;\n    }\n    this._androidUpdateCount = now + this._androidUpdateFrequency;\n    if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests) {\n      return;\n    }\n    const activeIds = /* @__PURE__ */ new Set();\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n      for (const child of this._children) {\n        if (child._renderId === this._renderId) {\n          activeIds.add(this._children.indexOf(child));\n        }\n      }\n    }\n    for (let i = this._children.length - 1; i >= 0; i--) {\n      const child = this._children[i];\n      if (!activeIds.has(i)) {\n        if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n          const pool = this._getPool(child.accessibleType);\n          pool.push(child._accessibleDiv);\n          child._accessibleDiv = null;\n        }\n        child._accessibleActive = false;\n        (0,removeItems/* removeItems */.d)(this._children, i, 1);\n      }\n    }\n    if (this._renderer.renderingToScreen) {\n      this._canvasObserver.ensureAttached();\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      if (!child._accessibleActive || !child._accessibleDiv) {\n        continue;\n      }\n      const div = child._accessibleDiv;\n      const hitArea = child.hitArea || child.getBounds().rectangle;\n      if (child.hitArea) {\n        const wt = child.worldTransform;\n        div.style.left = `${wt.tx + hitArea.x * wt.a}px`;\n        div.style.top = `${wt.ty + hitArea.y * wt.d}px`;\n        div.style.width = `${hitArea.width * wt.a}px`;\n        div.style.height = `${hitArea.height * wt.d}px`;\n      } else {\n        this._capHitArea(hitArea);\n        div.style.left = `${hitArea.x}px`;\n        div.style.top = `${hitArea.y}px`;\n        div.style.width = `${hitArea.width}px`;\n        div.style.height = `${hitArea.height}px`;\n      }\n    }\n    this._renderId++;\n  }\n  /**\n   * private function that will visually add the information to the\n   * accessibility div\n   * @param {HTMLElement} div -\n   */\n  _updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {Rectangle} hitArea - Bounds of the child\n   */\n  _capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this._renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  /**\n   * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n   * Sets up ARIA attributes, event listeners, and positioning based on the container\'s properties.\n   * @private\n   * @param {Container} container - The child to make accessible.\n   */\n  _addChild(container) {\n    const pool = this._getPool(container.accessibleType);\n    let div = pool.pop();\n    if (div) {\n      div.innerHTML = "";\n      div.removeAttribute("title");\n      div.removeAttribute("aria-label");\n      div.tabIndex = 0;\n    } else {\n      if (container.accessibleType === "button") {\n        div = document.createElement("button");\n      } else {\n        div = document.createElement(container.accessibleType);\n        div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n        if (container.accessibleText) {\n          div.innerText = container.accessibleText;\n        }\n      }\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";\n      div.style.position = "absolute";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = "none";\n      if (navigator.userAgent.toLowerCase().includes("chrome")) {\n        div.setAttribute("aria-live", "off");\n      } else {\n        div.setAttribute("aria-live", "polite");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute("aria-relevant", "additions");\n      } else {\n        div.setAttribute("aria-relevant", "text");\n      }\n      div.addEventListener("click", this._onClick.bind(this));\n      div.addEventListener("focus", this._onFocus.bind(this));\n      div.addEventListener("focusout", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = container.accessiblePointerEvents;\n    div.type = container.accessibleType;\n    if (container.accessibleTitle && container.accessibleTitle !== null) {\n      div.title = container.accessibleTitle;\n    } else if (!container.accessibleHint || container.accessibleHint === null) {\n      div.title = `container ${container.tabIndex}`;\n    }\n    if (container.accessibleHint && container.accessibleHint !== null) {\n      div.setAttribute("aria-label", container.accessibleHint);\n    }\n    if (container.interactive) {\n      div.tabIndex = container.tabIndex;\n    } else {\n      div.tabIndex = 0;\n    }\n    if (this.debug) {\n      this._updateDebugHTML(div);\n    }\n    container._accessibleActive = true;\n    container._accessibleDiv = div;\n    div.container = container;\n    this._children.push(container);\n    this._div.appendChild(container._accessibleDiv);\n  }\n  /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */\n  _dispatchEvent(e, type) {\n    const { container: target } = e.target;\n    const boundary = this._renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent(boundary), { target });\n    boundary.rootTarget = this._renderer.lastObjectRendered;\n    type.forEach((type2) => boundary.dispatchEvent(event, type2));\n  }\n  /**\n   * Maps the div button press to pixi\'s EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */\n  _onClick(e) {\n    this._dispatchEvent(e, ["click", "pointertap", "tap"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */\n  _onFocus(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "assertive");\n    }\n    this._dispatchEvent(e, ["mouseover"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */\n  _onFocusOut(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "polite");\n    }\n    this._dispatchEvent(e, ["mouseout"]);\n  }\n  /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {\n      return;\n    }\n    this._activate();\n  }\n  /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this._deactivate();\n  }\n  /**\n   * Destroys the accessibility system. Removes all elements and listeners.\n   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n   * > A typically user should not need to call this method directly.\n   */\n  destroy() {\n    this._deactivate();\n    this._destroyTouchHook();\n    this._canvasObserver?.destroy();\n    this._canvasObserver = null;\n    this._div = null;\n    this._pools = null;\n    this._children = null;\n    this._renderer = null;\n    this._hookDiv = null;\n    globalThis.removeEventListener("keydown", this._boundOnKeyDown);\n    this._boundOnKeyDown = null;\n    globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);\n    this._boundOnMouseMove = null;\n  }\n  /**\n   * Enables or disables the accessibility system.\n   * @param enabled - Whether to enable or disable accessibility.\n   * @example\n   * ```js\n   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n   * ```\n   */\n  setAccessibilityEnabled(enabled) {\n    if (enabled) {\n      this._activate();\n    } else {\n      this._deactivate();\n    }\n  }\n  _getPool(accessibleType) {\n    if (!this._pools[accessibleType]) {\n      this._pools[accessibleType] = [];\n    }\n    return this._pools[accessibleType];\n  }\n};\n/** @ignore */\n_AccessibilitySystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "accessibility"\n};\n/**\n * The default options used by the system.\n * You can set these before initializing the {@link Application} to change the default behavior.\n * @example\n * ```js\n * import { AccessibilitySystem } from \'pixi.js\';\n *\n * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n *\n * const app = new Application()\n * app.init()\n * ```\n */\n_AccessibilitySystem.defaultOptions = {\n  /**\n   * Whether to enable accessibility features on initialization\n   * @default false\n   */\n  enabledByDefault: false,\n  /**\n   * Whether to visually show the accessibility divs for debugging\n   * @default false\n   */\n  debug: false,\n  /**\n   * Whether to activate accessibility when tab key is pressed\n   * @default true\n   */\n  activateOnTab: true,\n  /**\n   * Whether to deactivate accessibility when mouse moves\n   * @default true\n   */\n  deactivateOnMouseMove: true\n};\nlet AccessibilitySystem = _AccessibilitySystem;\n\n\n//# sourceMappingURL=AccessibilitySystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs\n\nconst accessibilityTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  accessibleType: "button",\n  accessibleText: null,\n  accessiblePointerEvents: "auto",\n  accessibleChildren: true,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  _renderId: -1\n};\n\n\n//# sourceMappingURL=accessibilityTarget.mjs.map\n\n;// ./node_modules/pixi.js/lib/accessibility/init.mjs\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.XO.add(AccessibilitySystem);\nExtensions/* extensions */.XO.mixin(Container/* Container */.mc, accessibilityTarget);\n//# sourceMappingURL=init.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/app/init.mjs + 2 modules\nvar init = __webpack_require__(4732);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(8875);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(268);\n;// ./node_modules/pixi.js/lib/events/EventTicker.mjs\n\n\n\n"use strict";\nclass EventsTickerClass {\n  constructor() {\n    /** The frequency that fake events will be fired. */\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    if (this._tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker/* Ticker */.R.system.add(this._tickerUpdate, this, ticker_const/* UPDATE_PRIORITY */.d.INTERACTION);\n    this._tickerAdded = true;\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    if (!this._tickerAdded) {\n      return;\n    }\n    Ticker/* Ticker */.R.system.remove(this._tickerUpdate, this);\n    this._tickerAdded = false;\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = true;\n  }\n  /** Updates the state of interactive objects. */\n  _update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events["_rootPointerEvent"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {\n      return;\n    }\n    globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY,\n      pointerType: rootPointerEvent.pointerType,\n      pointerId: rootPointerEvent.pointerId\n    }) : new MouseEvent("mousemove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */\n  _tickerUpdate(ticker) {\n    this._deltaTime += ticker.deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this._update();\n  }\n  /** Destroys the event ticker. */\n  destroy() {\n    this.removeTickerListener();\n    this.events = null;\n    this.domElement = null;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\n\n//# sourceMappingURL=EventTicker.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs\n\n\n\n"use strict";\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new Point/* Point */.b();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new Point/* Point */.b();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new Point/* Point */.b();\n    /** The pointer coordinates in world space. */\n    this.global = new Point/* Point */.b();\n    /**\n     * The pointer coordinates in the renderer\'s {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new Point/* Point */.b();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for `screen.x`.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for `screen.y`.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * Converts global coordinates into container-local coordinates.\n   *\n   * This method transforms coordinates from world space to a container\'s local space,\n   * useful for precise positioning and hit testing.\n   * @param container - The Container to get local coordinates for\n   * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n   * @param globalPos - Optional custom global coordinates. If not provided, the event\'s global position is used\n   * @returns The local coordinates as a Point object\n   * @example\n   * ```ts\n   * // Basic usage - get local coordinates relative to a container\n   * sprite.on(\'pointermove\', (event: FederatedMouseEvent) => {\n   *     // Get position relative to the sprite\n   *     const localPos = event.getLocalPosition(sprite);\n   *     console.log(\'Local position:\', localPos.x, localPos.y);\n   * });\n   * // Using custom global coordinates\n   * const customGlobal = new Point(100, 100);\n   * sprite.on(\'pointermove\', (event: FederatedMouseEvent) => {\n   *     // Transform custom coordinates\n   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n   *     console.log(\'Custom local position:\', localPos.x, localPos.y);\n   * });\n   * ```\n   * @see {@link Container.worldTransform} For the transformation matrix\n   * @see {@link Point} For the point class used to store coordinates\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   * @ignore\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs\n\n\n"use strict";\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer\'s contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer\'s contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getCoalescedEvents() {\n    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {\n      return [this];\n    }\n    return [];\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs\n\n\n"use strict";\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    this.DOM_DELTA_PIXEL = 0;\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    this.DOM_DELTA_LINE = 1;\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\n/**\n * Units specified in pixels.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\n/**\n * Units specified in lines.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\n/**\n * Units specified in pages.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\n\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/EventBoundary.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point/* Point */.b();\nconst tempLocalMapping = new Point/* Point */.b();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new eventemitter3/* default */.A();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API\'s approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping("pointerdown", this.mapPointerDown);\n    this.addEventMapping("pointermove", this.mapPointerMove);\n    this.addEventMapping("pointerout", this.mapPointerOut);\n    this.addEventMapping("pointerleave", this.mapPointerOut);\n    this.addEventMapping("pointerover", this.mapPointerOver);\n    this.addEventMapping("pointerup", this.mapPointerUp);\n    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);\n    this.addEventMapping("wheel", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      (0,warn/* warn */.R)(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target `e.target`.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * `target`. The last element in the path is `target`.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error("Cannot find propagation path to disconnected target");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === "static" || int === "dynamic";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === "none") {\n      return true;\n    }\n    if (container.eventMode === "passive" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}\'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event\'s `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type ?? (type = e.type);\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerdown");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchstart");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, "pointerout");\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, "mouseleave");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, "pointerover");\n      if (isMouse)\n        this.dispatchEvent(overEvent, "mouseover");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, "pointerenter");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, "mouseenter");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");\n    allowGlobalPointerEvents && allMethods.push("globalpointermove");\n    if (e.pointerType === "touch") {\n      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");\n      allowGlobalPointerEvents && allMethods.push("globaltouchmove");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");\n      allowGlobalPointerEvents && allMethods.push("globalmousemove");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    this.dispatchEvent(e, "pointerover");\n    if (isMouse)\n      this.dispatchEvent(e, "mouseover");\n    if (e.pointerType === "mouse")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, "pointerenter");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, "mouseenter");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, "mouseleave");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event\'s target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerup");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchend");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, "click");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === "mouse") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");\n      } else if (clickEvent.pointerType === "touch") {\n        this.dispatchEvent(clickEvent, "tap");\n      }\n      this.dispatchEvent(clickEvent, "pointertap");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}\'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-wheel event as a wheel event");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The `originalEvent` for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === "string") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose `originalEvent` is `from`.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event `from`, with an optional `type` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event\'s constructor.\n   * @returns An event of the given type.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.defaultPrevented = false;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error("It is illegal to free an event not managed by this EventBoundary!");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if ("fn" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=EventBoundary.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/EventSystem.mjs\n\n\n\n\n\n\n"use strict";\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: "pointerdown",\n  touchend: "pointerup",\n  touchendoutside: "pointerupoutside",\n  touchmove: "pointermove",\n  touchcancel: "pointercancel"\n};\nconst _EventSystem = class _EventSystem {\n  /**\n   * @param {Renderer} renderer\n   */\n  constructor(renderer) {\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default \'ontouchstart\' in globalThis\n     */\n    this.supportsTouchEvents = "ontouchstart" in globalThis;\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer\'s {@link Renderer#view view}.\n     */\n    this.domElement = null;\n    /** The resolution used to convert between the DOM client space into world space. */\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this._eventsAdded = false;\n    this._rootPointerEvent = new FederatedPointerEvent(null);\n    this._rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: "inherit",\n      pointer: "pointer"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === "globalMove") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this._onPointerDown = this._onPointerDown.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerUp = this._onPointerUp.bind(this);\n    this._onPointerOverOut = this._onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const { canvas, resolution } = this.renderer;\n    this.setTargetElement(canvas);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? "passive";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    EventsTicker.destroy();\n    this.setTargetElement(null);\n    this.renderer = null;\n    this._currentCursor = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n   * @param mode - Cursor mode to set. Can be:\n   * - A CSS cursor string (e.g., \'pointer\', \'grab\')\n   * - A key from the cursorStyles dictionary\n   * - null/undefined to reset to default\n   * @example\n   * ```ts\n   * // Using predefined cursor styles\n   * app.renderer.events.setCursor(\'pointer\');    // Set standard pointer cursor\n   * app.renderer.events.setCursor(\'grab\');       // Set grab cursor\n   * app.renderer.events.setCursor(null);         // Reset to default\n   *\n   * // Using custom cursor styles\n   * app.renderer.events.cursorStyles.custom = \'url("cursor.png"), auto\';\n   * app.renderer.events.setCursor(\'custom\');     // Apply custom cursor\n   *\n   * // Using callback-based cursor\n   * app.renderer.events.cursorStyles.dynamic = (mode) => {\n   *     document.body.style.cursor = mode === \'hover\' ? \'pointer\' : \'default\';\n   * };\n   * app.renderer.events.setCursor(\'dynamic\');    // Trigger cursor callback\n   * ```\n   * @remarks\n   * - Has no effect on OffscreenCanvas except for callback-based cursors\n   * - Caches current cursor to avoid unnecessary DOM updates\n   * - Supports CSS cursor values, style objects, and callback functions\n   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n   */\n  setCursor(mode) {\n    mode || (mode = "default");\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this._currentCursor === mode) {\n      return;\n    }\n    this._currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case "string":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case "function":\n          style(mode);\n          break;\n        case "object":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  /**\n   * The global pointer event instance containing the most recent pointer state.\n   * This is useful for accessing pointer information without listening to events.\n   * @example\n   * ```ts\n   * // Access current pointer position at any time\n   * const eventSystem = app.renderer.events;\n   * const pointer = eventSystem.pointer;\n   *\n   * // Get global coordinates\n   * console.log(\'Position:\', pointer.global.x, pointer.global.y);\n   *\n   * // Check button state\n   * console.log(\'Buttons pressed:\', pointer.buttons);\n   *\n   * // Get pointer type and pressure\n   * console.log(\'Type:\', pointer.pointerType);\n   * console.log(\'Pressure:\', pointer.pressure);\n   * ```\n   * @readonly\n   * @since 7.2.0\n   * @see {@link FederatedPointerEvent} For all available pointer properties\n   */\n  get pointer() {\n    return this._rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this._normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  _onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? "outside" : "";\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   * This method manages the DOM event bindings for the event system, allowing you to\n   * change or remove the target element that receives input events.\n   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n   * > should not need to call this unless you are using a custom element.\n   * @param element - The new DOM element to bind events to, or null to remove all event bindings\n   * @example\n   * ```ts\n   * // Set a new canvas element as the target\n   * const canvas = document.createElement(\'canvas\');\n   * app.renderer.events.setTargetElement(canvas);\n   *\n   * // Remove all event bindings\n   * app.renderer.events.setTargetElement(null);\n   *\n   * // Switch to a different canvas\n   * const newCanvas = document.querySelector(\'#game-canvas\');\n   * app.renderer.events.setTargetElement(newCanvas);\n   * ```\n   * @remarks\n   * - Automatically removes event listeners from previous element\n   * - Required for the event system to function\n   * - Safe to call multiple times\n   * @see {@link EventSystem#domElement} The current DOM element\n   * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n   */\n  setTargetElement(element) {\n    this._removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this._addEvents();\n  }\n  /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n  _addEvents() {\n    if (this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "none";\n        style.msTouchAction = "none";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "none";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener("pointermove", this._onPointerMove, true);\n      this.domElement.addEventListener("pointerdown", this._onPointerDown, true);\n      this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);\n      this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);\n      globalThis.addEventListener("pointerup", this._onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener("mousemove", this._onPointerMove, true);\n      this.domElement.addEventListener("mousedown", this._onPointerDown, true);\n      this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);\n      this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);\n      globalThis.addEventListener("mouseup", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener("touchstart", this._onPointerDown, true);\n        this.domElement.addEventListener("touchend", this._onPointerUp, true);\n        this.domElement.addEventListener("touchmove", this._onPointerMove, true);\n      }\n    }\n    this.domElement.addEventListener("wheel", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this._eventsAdded = true;\n  }\n  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n  _removeEvents() {\n    if (!this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "";\n        style.msTouchAction = "";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);\n      this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);\n      this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);\n      this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);\n      globalThis.removeEventListener("pointerup", this._onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);\n      this.domElement.removeEventListener("mousedown", this._onPointerDown, true);\n      this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);\n      this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);\n      globalThis.removeEventListener("mouseup", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener("touchstart", this._onPointerDown, true);\n        this.domElement.removeEventListener("touchend", this._onPointerUp, true);\n        this.domElement.removeEventListener("touchmove", this._onPointerMove, true);\n      }\n    }\n    this.domElement.removeEventListener("wheel", this.onWheel, true);\n    this.domElement = null;\n    this._eventsAdded = false;\n  }\n  /**\n   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n   * This takes into account the current scale, position, and resolution of the DOM element.\n   * @param point - The point to store the mapped coordinates in\n   * @param x - The x coordinate in DOM/client space\n   * @param y - The y coordinate in DOM/client space\n   * @example\n   * ```ts\n   * // Map mouse coordinates to PixiJS space\n   * const point = new Point();\n   * app.renderer.events.mapPositionToPoint(\n   *     point,\n   *     event.clientX,\n   *     event.clientY\n   * );\n   * console.log(\'Mapped position:\', point.x, point.y);\n   *\n   * // Using with pointer events\n   * sprite.on(\'pointermove\', (event) => {\n   *     // event.global already contains mapped coordinates\n   *     console.log(\'Global:\', event.global.x, event.global.y);\n   *\n   *     // Map to local coordinates\n   *     const local = event.getLocalPosition(sprite);\n   *     console.log(\'Local:\', local.x, local.y);\n   * });\n   * ```\n   * @remarks\n   * - Accounts for element scaling and positioning\n   * - Adjusts for device pixel ratio/resolution\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    };\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  _normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === "undefined")\n          touch.button = 0;\n        if (typeof touch.buttons === "undefined")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === "undefined") {\n          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";\n        }\n        if (typeof touch.width === "undefined")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === "undefined")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === "undefined")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === "undefined")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === "undefined")\n          touch.pointerType = "touch";\n        if (typeof touch.pointerId === "undefined")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === "undefined")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === "undefined")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === "undefined")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === "undefined")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === "undefined")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === "undefined")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === "undefined")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === "undefined")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === "undefined")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === "undefined")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === "undefined")\n        tempEvent.pointerType = "mouse";\n      if (typeof tempEvent.pointerId === "undefined")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === "undefined")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === "undefined")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === "undefined")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this._rootWheelEvent;\n    this._transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  _bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this._transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === "pointerleave") {\n      event.type = "pointerout";\n    }\n    if (event.type.startsWith("mouse")) {\n      event.type = event.type.replace("mouse", "pointer");\n    }\n    if (event.type.startsWith("touch")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  /**\n   * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  _transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n/** @ignore */\n_EventSystem.extension = {\n  name: "events",\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * @since 7.2.0\n * @example\n * ```ts\n * import { EventSystem, EventSystemFeatures } from \'pixi.js\';\n * // Access the default event features\n * EventSystem.defaultEventFeatures = {\n *     // Enable pointer movement events\n *     move: true,\n *     // Enable global pointer move events\n *     globalMove: true,\n *     // Enable click events\n *     click: true,\n *     // Enable wheel events\n *     wheel: true,\n * };\n * ```\n */\n_EventSystem.defaultEventFeatures = {\n  /** Enables pointer events associated with pointer movement. */\n  move: true,\n  /** Enables global pointer move events. */\n  globalMove: true,\n  /** Enables pointer events associated with clicking. */\n  click: true,\n  /** Enables wheel events. */\n  wheel: true\n};\nlet EventSystem = _EventSystem;\n\n\n//# sourceMappingURL=EventSystem.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/FederatedEventTarget.mjs\n\n\n\n"use strict";\nconst FederatedContainer = {\n  onclick: null,\n  onmousedown: null,\n  onmouseenter: null,\n  onmouseleave: null,\n  onmousemove: null,\n  onglobalmousemove: null,\n  onmouseout: null,\n  onmouseover: null,\n  onmouseup: null,\n  onmouseupoutside: null,\n  onpointercancel: null,\n  onpointerdown: null,\n  onpointerenter: null,\n  onpointerleave: null,\n  onpointermove: null,\n  onglobalpointermove: null,\n  onpointerout: null,\n  onpointerover: null,\n  onpointertap: null,\n  onpointerup: null,\n  onpointerupoutside: null,\n  onrightclick: null,\n  onrightdown: null,\n  onrightup: null,\n  onrightupoutside: null,\n  ontap: null,\n  ontouchcancel: null,\n  ontouchend: null,\n  ontouchendoutside: null,\n  ontouchmove: null,\n  onglobaltouchmove: null,\n  ontouchstart: null,\n  onwheel: null,\n  get interactive() {\n    return this.eventMode === "dynamic" || this.eventMode === "static";\n  },\n  set interactive(value) {\n    this.eventMode = value ? "static" : "passive";\n  },\n  _internalEventMode: void 0,\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalEventMode = value;\n  },\n  isInteractive() {\n    return this.eventMode === "static" || this.eventMode === "dynamic";\n  },\n  interactiveChildren: true,\n  hitArea: null,\n  addEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const signal = typeof options === "object" ? options.signal : void 0;\n    const once = typeof options === "object" ? options.once === true : false;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;\n    const emitter = this;\n    if (signal) {\n      signal.addEventListener("abort", () => {\n        emitter.off(type, listenerFn, context);\n      });\n    }\n    if (once) {\n      emitter.once(type, listenerFn, context);\n    } else {\n      emitter.on(type, listenerFn, context);\n    }\n  },\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent)) {\n      throw new Error("Container cannot propagate events outside of the Federated Events API");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\n\n\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n\n;// ./node_modules/pixi.js/lib/events/init.mjs\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.XO.add(EventSystem);\nExtensions/* extensions */.XO.mixin(Container/* Container */.mc, FederatedContainer);\n//# sourceMappingURL=init.mjs.map\n\n;// ./node_modules/pixi.js/lib/dom/DOMPipe.mjs\n\n\n\n"use strict";\nclass DOMPipe {\n  /**\n   * Constructor for the DOMPipe class.\n   * @param renderer - The renderer instance that this DOMPipe will be associated with.\n   */\n  constructor(renderer) {\n    /** Array to keep track of attached DOM elements */\n    this._attachedDomElements = [];\n    this._renderer = renderer;\n    this._renderer.runners.postrender.add(this);\n    this._renderer.runners.init.add(this);\n    this._domElement = document.createElement("div");\n    this._domElement.style.position = "absolute";\n    this._domElement.style.top = "0";\n    this._domElement.style.left = "0";\n    this._domElement.style.pointerEvents = "none";\n    this._domElement.style.zIndex = "1000";\n  }\n  /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */\n  init() {\n    this._canvasObserver = new CanvasObserver({\n      domElement: this._domElement,\n      renderer: this._renderer\n    });\n  }\n  /**\n   * Adds a renderable DOM container to the list of attached elements.\n   * @param domContainer - The DOM container to be added.\n   * @param _instructionSet - The instruction set (unused).\n   */\n  addRenderable(domContainer, _instructionSet) {\n    if (!this._attachedDomElements.includes(domContainer)) {\n      this._attachedDomElements.push(domContainer);\n    }\n  }\n  /**\n   * Updates a renderable DOM container.\n   * @param _domContainer - The DOM container to be updated (unused).\n   */\n  updateRenderable(_domContainer) {\n  }\n  /**\n   * Validates a renderable DOM container.\n   * @param _domContainer - The DOM container to be validated (unused).\n   * @returns Always returns true as validation is not required.\n   */\n  validateRenderable(_domContainer) {\n    return true;\n  }\n  /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n  postrender() {\n    const attachedDomElements = this._attachedDomElements;\n    if (attachedDomElements.length === 0) {\n      this._domElement.remove();\n      return;\n    }\n    this._canvasObserver.ensureAttached();\n    for (let i = 0; i < attachedDomElements.length; i++) {\n      const domContainer = attachedDomElements[i];\n      const element = domContainer.element;\n      if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {\n        element?.remove();\n        attachedDomElements.splice(i, 1);\n        i--;\n      } else {\n        if (!this._domElement.contains(element)) {\n          element.style.position = "absolute";\n          element.style.pointerEvents = "auto";\n          this._domElement.appendChild(element);\n        }\n        const wt = domContainer.worldTransform;\n        const anchor = domContainer._anchor;\n        const ax = domContainer.width * anchor.x;\n        const ay = domContainer.height * anchor.y;\n        element.style.transformOrigin = `${ax}px ${ay}px`;\n        element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n        element.style.opacity = domContainer.groupAlpha.toString();\n      }\n    }\n  }\n  /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n  destroy() {\n    this._renderer.runners.postrender.remove(this);\n    for (let i = 0; i < this._attachedDomElements.length; i++) {\n      const domContainer = this._attachedDomElements[i];\n      domContainer.element?.remove();\n    }\n    this._attachedDomElements.length = 0;\n    this._domElement.remove();\n    this._canvasObserver.destroy();\n    this._renderer = null;\n  }\n}\n/**\n * Static property defining the extension type and name for the DOMPipe.\n * This is used to register the DOMPipe with different rendering pipelines.\n */\nDOMPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "dom"\n};\n\n\n//# sourceMappingURL=DOMPipe.mjs.map\n\n;// ./node_modules/pixi.js/lib/dom/init.mjs\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.XO.add(DOMPipe);\n\n\n//# sourceMappingURL=init.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs + 2 modules\nvar spritesheet_init = __webpack_require__(9010);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs + 5 modules\nvar rendering_init = __webpack_require__(8480);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs + 1 modules\nvar graphics_init = __webpack_require__(8928);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs + 1 modules\nvar mesh_init = __webpack_require__(5285);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/particle-container/init.mjs + 12 modules\nvar particle_container_init = __webpack_require__(9305);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs + 3 modules\nvar text_init = __webpack_require__(2206);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs + 4 modules\nvar text_bitmap_init = __webpack_require__(6444);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs + 13 modules\nvar text_html_init = __webpack_require__(2623);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs + 7 modules\nvar sprite_tiling_init = __webpack_require__(8723);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs + 3 modules\nvar sprite_nine_slice_init = __webpack_require__(7252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/init.mjs + 7 modules\nvar filters_init = __webpack_require__(3859);\n;// ./node_modules/pixi.js/lib/environment-browser/browserAll.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\n//# sourceMappingURL=browserAll.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNEO0FBQ1I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRyxNQUFNLEdBQUcsWUFBWSxHQUFHLElBQUksR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixNQUFNLG9CQUFNLDBDQUEwQyxtQ0FBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLG9CQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCOzs7OztBQ2xHaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBSztBQUMxQjtBQUNBLG9CQUFvQixrQkFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9DQUFvQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCOzs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7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QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNFQUFzRTtBQUNsRztBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkI7OztBQy9HMEQ7QUFDbEI7QUFDbkI7QUFDaUM7QUFDSjs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLE9BQU87O0FBRUg7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWbUM7QUFDVjtBQUNHO0FBQ0g7QUFDUTtBQUNGO0FBQ0s7QUFDSjtBQUNjO0FBQ2Q7QUFDTztBQUNGO0FBQ0k7QUFDSTtBQUNoQjs7QUFFN0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9kb20vQ2FudmFzT2JzZXJ2ZXIubWpzPzIzNGQiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9GZWRlcmF0ZWRFdmVudC5tanM/NjBhNiIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaXNNb2JpbGUuanM/OWNiZSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc01vYmlsZS5tanM/YjVmMiIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9BY2Nlc3NpYmlsaXR5U3lzdGVtLm1qcz8yNmRlIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hY2Nlc3NpYmlsaXR5L2FjY2Vzc2liaWxpdHlUYXJnZXQubWpzP2EwOTkiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FjY2Vzc2liaWxpdHkvaW5pdC5tanM/NzE3NSIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0V2ZW50VGlja2VyLm1qcz8yODViIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9ldmVudHMvRmVkZXJhdGVkTW91c2VFdmVudC5tanM/NWMwZiIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanM/MzNmMCIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzP2Q0ODQiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9FdmVudEJvdW5kYXJ5Lm1qcz81MGVmIiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9ldmVudHMvRXZlbnRTeXN0ZW0ubWpzP2Q3MjQiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9GZWRlcmF0ZWRFdmVudFRhcmdldC5tanM/YmVlYyIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL2luaXQubWpzPzBhZGMiLCJ3ZWJwYWNrOi8vbmV1cmFsLXJhY2VyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2RvbS9ET01QaXBlLm1qcz8xZTU3Iiwid2VicGFjazovL25ldXJhbC1yYWNlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9kb20vaW5pdC5tanM/ODZhNyIsIndlYnBhY2s6Ly9uZXVyYWwtcmFjZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZW52aXJvbm1lbnQtYnJvd3Nlci9icm93c2VyQWxsLm1qcz84ZWZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVQREFURV9QUklPUklUWSB9IGZyb20gJy4uL3RpY2tlci9jb25zdC5tanMnO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAnLi4vdGlja2VyL1RpY2tlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc09ic2VydmVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKiBBIGNhY2hlZCB2YWx1ZSBvZiB0aGUgbGFzdCB0cmFuc2Zvcm0gYXBwbGllZCB0byB0aGUgRE9NIGVsZW1lbnQuICovXG4gICAgdGhpcy5fbGFzdFRyYW5zZm9ybSA9IFwiXCI7XG4gICAgLyoqIEEgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2UgdG8gb2JzZXJ2ZSBjaGFuZ2VzIGluIHRoZSBjYW52YXMgc2l6ZS4gKi9cbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBvYnNlcnZlciBpcyBhdHRhY2hlZCB0byB0aGUgVGlja2VyIGZvciBjb250aW51b3VzIHVwZGF0ZXMuICovXG4gICAgdGhpcy5fdGlja2VyQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIERPTSBlbGVtZW50IGJhc2VkIG9uIHRoZSBjYW52YXMgc2l6ZSBhbmQgcG9zaXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgc2NhbGUgYW5kIHRyYW5zbGF0aW9uIG5lZWRlZCB0byBrZWVwIHRoZSBET00gZWxlbWVudCBpbiBzeW5jIHdpdGggdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZVRyYW5zbGF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jYW52YXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gdGhpcy5fY2FudmFzLmhlaWdodDtcbiAgICAgIGNvbnN0IHN4ID0gcmVjdC53aWR0aCAvIGNvbnRlbnRXaWR0aCAqIHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBjb25zdCBzeSA9IHJlY3QuaGVpZ2h0IC8gY29udGVudEhlaWdodCAqIHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICBjb25zdCB0eCA9IHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHR5ID0gcmVjdC50b3A7XG4gICAgICBjb25zdCBuZXdUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHh9cHgsICR7dHl9cHgpIHNjYWxlKCR7c3h9LCAke3N5fSlgO1xuICAgICAgaWYgKG5ld1RyYW5zZm9ybSAhPT0gdGhpcy5fbGFzdFRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLl9kb21FbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IG5ld1RyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5fbGFzdFRyYW5zZm9ybSA9IG5ld1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2RvbUVsZW1lbnQgPSBvcHRpb25zLmRvbUVsZW1lbnQ7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgIGlmIChnbG9iYWxUaGlzLk9mZnNjcmVlbkNhbnZhcyAmJiB0aGlzLl9yZW5kZXJlci5jYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuY2FudmFzO1xuICAgIHRoaXMuX2F0dGFjaE9ic2VydmVyKCk7XG4gIH1cbiAgLyoqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHRoaXMgQ2FudmFzT2JzZXJ2ZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH1cbiAgLyoqIEF0dGFjaGVzIHRoZSBET00gZWxlbWVudCB0byB0aGUgY2FudmFzIHBhcmVudCBpZiBpdCBpcyBub3QgYWxyZWFkeSBhdHRhY2hlZC4gKi9cbiAgZW5zdXJlQXR0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9kb21FbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2RvbUVsZW1lbnQpO1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2xhdGlvbigpO1xuICAgIH1cbiAgfVxuICAvKiogU2V0cyB1cCBhIFJlc2l6ZU9ic2VydmVyIGlmIGF2YWlsYWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIERPTSBlbGVtZW50IGlzIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBjYW52YXMgc2l6ZSAuICovXG4gIF9hdHRhY2hPYnNlcnZlcigpIHtcbiAgICBpZiAoXCJSZXNpemVPYnNlcnZlclwiIGluIGdsb2JhbFRoaXMpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQgIT09IHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgY29uc3Qgc3ggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aCAvIGNvbnRlbnRXaWR0aCAqIHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgY29uc3Qgc3kgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQgLyBjb250ZW50SGVpZ2h0ICogdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICBjb25zdCBuZWVkc1VwZGF0ZSA9IHRoaXMuX2xhc3RTY2FsZVggIT09IHN4IHx8IHRoaXMuX2xhc3RTY2FsZVkgIT09IHN5O1xuICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2xhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IHN4O1xuICAgICAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHN5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2NhbnZhcyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fdGlja2VyQXR0YWNoZWQpIHtcbiAgICAgIFRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlVHJhbnNsYXRpb24sIHRoaXMsIFVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBDYW52YXNPYnNlcnZlciBpbnN0YW5jZSwgY2xlYW5pbmcgdXAgb2JzZXJ2ZXJzIGFuZCBUaWNrZXIuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90aWNrZXJBdHRhY2hlZCkge1xuICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGVUcmFuc2xhdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2RvbUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tlckF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFRyYW5zZm9ybSA9IFwiXCI7XG4gICAgdGhpcy5fbGFzdFNjYWxlWCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFNjYWxlWSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQ2FudmFzT2JzZXJ2ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc09ic2VydmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGZWRlcmF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbWFuYWdlciAtIFRoZSBldmVudCBib3VuZGFyeSB3aGljaCBtYW5hZ2VzIHRoaXMgZXZlbnQuIFByb3BhZ2F0aW9uIGNhbiBvbmx5IG9jY3VyXG4gICAqICB3aXRoaW4gdGhlIGJvdW5kYXJ5J3MganVyaXNkaWN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHRoaXMgZXZlbnQgYnViYmxlcy4gVGhpcyB3aWxsIHRha2UgZWZmZWN0IG9ubHkgaWYgaXQgaXMgc2V0IGJlZm9yZSBwcm9wYWdhdGlvbi4gKi9cbiAgICB0aGlzLmJ1YmJsZXMgPSB0cnVlO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMCAqL1xuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGVkIHVzaW5nIHtAbGluayBGZWRlcmF0ZWRFdmVudC5wcmV2ZW50RGVmYXVsdH0uIFRoaXMgaXMgYWx3YXlzXG4gICAgICogZmFsc2UgKGZvciBub3cpLlxuICAgICAqL1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEZsYWcgYWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBET00gYEV2ZW50YC4gSXQgaXMgbm90IHVzZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHNcbiAgICAgKiBBUEkuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jb21wb3NlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmNvbXBvc2VkID0gZmFsc2U7XG4gICAgLyoqIEZsYWdzIHdoZXRoZXIgdGhlIGRlZmF1bHQgcmVzcG9uc2Ugb2YgdGhlIHVzZXIgYWdlbnQgd2FzIHByZXZlbnQgdGhyb3VnaCB0aGlzIGV2ZW50LiAqL1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9wYWdhdGlvbiBwaGFzZS5cbiAgICAgKiBAZGVmYXVsdCB7QGxpbmsgRmVkZXJhdGVkRXZlbnQuTk9ORX1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50UGhhc2UgPSBGZWRlcmF0ZWRFdmVudC5wcm90b3R5cGUuTk9ORTtcbiAgICAvKiogRmxhZ3Mgd2hldGhlciBwcm9wYWdhdGlvbiB3YXMgc3RvcHBlZC4gKi9cbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHByb3BhZ2F0aW9uIHdhcyBpbW1lZGlhdGVseSBzdG9wcGVkLiAqL1xuICAgIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSBmYWxzZTtcbiAgICAvKiogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB0aGUgbmVhcmVzdCBET00gbGF5ZXIuIFRoaXMgaXMgYSBub24tc3RhbmRhcmQgcHJvcGVydHkuICovXG4gICAgdGhpcy5sYXllciA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBET00gZG9jdW1lbnQuIFRoaXMgaXMgYSBub24tc3RhbmRhcmQgcHJvcGVydHkuICovXG4gICAgdGhpcy5wYWdlID0gbmV3IFBvaW50KCk7XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHByb3BhZ2F0aW9uIHBoYXNlIE5PTkUgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaXMgbm90IGluIGFueSBwaGFzZS5cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQGFkdmFuY2VkXG4gICAgICovXG4gICAgdGhpcy5OT05FID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgcHJvcGFnYXRpb24gcGhhc2UgQ0FQVFVSSU5HX1BIQVNFIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGlzIGluIHRoZSBjYXB0dXJpbmcgcGhhc2UuXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBhZHZhbmNlZFxuICAgICAqL1xuICAgIHRoaXMuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgcHJvcGFnYXRpb24gcGhhc2UgQVRfVEFSR0VUIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGlzIGF0IHRoZSB0YXJnZXQuXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqIEBhZHZhbmNlZFxuICAgICAqL1xuICAgIHRoaXMuQVRfVEFSR0VUID0gMjtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgcHJvcGFnYXRpb24gcGhhc2UgQlVCQkxJTkdfUEhBU0UgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaXMgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAqIEBkZWZhdWx0IDNcbiAgICAgKiBAYWR2YW5jZWRcbiAgICAgKi9cbiAgICB0aGlzLkJVQkJMSU5HX1BIQVNFID0gMztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IHBhZ2VYKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBwYWdlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnk7XG4gIH1cbiAgLyoqXG4gICAqIEZhbGxiYWNrIGZvciB0aGUgZGVwcmVjYXRlZCBgSW50ZXJhY3Rpb25FdmVudC5kYXRhYC5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJvcGFnYXRpb24gcGF0aCBmb3IgdGhpcyBldmVudC4gQWxpYXMgZm9yIHtAbGluayBFdmVudEJvdW5kYXJ5LnByb3BhZ2F0aW9uUGF0aH0uXG4gICAqIEBhZHZhbmNlZFxuICAgKi9cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIGlmICh0aGlzLm1hbmFnZXIgJiYgKCF0aGlzLnBhdGggfHwgdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSAhPT0gdGhpcy50YXJnZXQpKSB7XG4gICAgICB0aGlzLnBhdGggPSB0aGlzLnRhcmdldCA/IHRoaXMubWFuYWdlci5wcm9wYWdhdGlvblBhdGgodGhpcy50YXJnZXQpIDogW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW1wbGVtZW50ZWQgbWV0aG9kIGluY2x1ZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIERPTSBpbnRlcmZhY2UgYEV2ZW50YC4gSXQgd2lsbCB0aHJvdyBhbiBgRXJyb3JgLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSBfdHlwZVxuICAgKiBAcGFyYW0gX2J1YmJsZXNcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlXG4gICAqL1xuICBpbml0RXZlbnQoX3R5cGUsIF9idWJibGVzLCBfY2FuY2VsYWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXRFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBVbmltcGxlbWVudGVkIG1ldGhvZCBpbmNsdWRlZCBmb3IgaW1wbGVtZW50aW5nIHRoZSBET00gaW50ZXJmYWNlIGBVSUV2ZW50YC4gSXQgd2lsbCB0aHJvdyBhbiBgRXJyb3JgLlxuICAgKiBAaWdub3JlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBfdHlwZUFyZ1xuICAgKiBAcGFyYW0gX2J1YmJsZXNBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKi9cbiAgaW5pdFVJRXZlbnQoX3R5cGVBcmcsIF9idWJibGVzQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0VUlFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgYm90aCBQaXhpSlMgYW5kIHRoZSB1c2VyIGFnZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBzcHJpdGUub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAqICAgICAvLyBQcmV2ZW50IGJvdGggYnJvd3NlcidzIGRlZmF1bHQgY2xpY2sgYmVoYXZpb3JcbiAgICogICAgIC8vIGFuZCBQaXhpSlMncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAqICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgKlxuICAgKiAgICAgLy8gQ3VzdG9tIGhhbmRsaW5nXG4gICAqICAgICBjdXN0b21DbGlja0hhbmRsZXIoKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcmVtYXJrc1xuICAgKiAtIE9ubHkgd29ya3MgaWYgdGhlIG5hdGl2ZSBldmVudCBpcyBjYW5jZWxhYmxlXG4gICAqIC0gRG9lcyBub3Qgc3RvcCBldmVudCBwcm9wYWdhdGlvblxuICAgKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBFdmVudCAmJiB0aGlzLm5hdGl2ZUV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGlzIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gYW55IGFkZGl0aW9uYWwgbGlzdGVuZXJzLCBpbmNsdWRpbmcgdGhvc2VcbiAgICogb24gdGhlIGN1cnJlbnQgdGFyZ2V0IGFuZCBhbnkgZm9sbG93aW5nIHRhcmdldHMgaW4gdGhlIHByb3BhZ2F0aW9uIHBhdGguXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnRhaW5lci5vbigncG9pbnRlcmRvd24nLCAoZXZlbnQpID0+IHtcbiAgICogICAgIC8vIFN0b3AgYWxsIGZ1cnRoZXIgZXZlbnQgaGFuZGxpbmdcbiAgICogICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgKlxuICAgKiAgICAgLy8gVGhlc2UgaGFuZGxlcnMgd29uJ3QgYmUgY2FsbGVkOlxuICAgKiAgICAgLy8gLSBPdGhlciBwb2ludGVyZG93biBsaXN0ZW5lcnMgb24gdGhpcyBjb250YWluZXJcbiAgICogICAgIC8vIC0gQW55IHBvaW50ZXJkb3duIGxpc3RlbmVycyBvbiBwYXJlbnQgY29udGFpbmVyc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEByZW1hcmtzXG4gICAqIC0gSW1tZWRpYXRlbHkgc3RvcHMgYWxsIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAqIC0gUHJldmVudHMgb3RoZXIgbGlzdGVuZXJzIG9uIHNhbWUgdGFyZ2V0IGZyb20gYmVpbmcgY2FsbGVkXG4gICAqIC0gTW9yZSBhZ2dyZXNzaXZlIHRoYW4gc3RvcFByb3BhZ2F0aW9uKClcbiAgICovXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGlzIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gdGhlIG5leHQgdGFyZ2V0IGluIHRoZSBwcm9wYWdhdGlvbiBwYXRoLlxuICAgKiBUaGUgcmVzdCBvZiB0aGUgbGlzdGVuZXJzIG9uIHRoZSBjdXJyZW50IHRhcmdldCB3aWxsIHN0aWxsIGJlIG5vdGlmaWVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjaGlsZC5vbigncG9pbnRlcm1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICogICAgIC8vIEhhbmRsZSBldmVudCBvbiBjaGlsZFxuICAgKiAgICAgdXBkYXRlQ2hpbGQoKTtcbiAgICpcbiAgICogICAgIC8vIFByZXZlbnQgcGFyZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgY2FsbGVkXG4gICAqICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFRoaXMgd29uJ3QgYmUgY2FsbGVkIGlmIGNoaWxkIGhhbmRsZXMgdGhlIGV2ZW50XG4gICAqIHBhcmVudC5vbigncG9pbnRlcm1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICogICAgIHVwZGF0ZVBhcmVudCgpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEByZW1hcmtzXG4gICAqIC0gU3RvcHMgZXZlbnQgYnViYmxpbmcgdG8gcGFyZW50IGNvbnRhaW5lcnNcbiAgICogLSBEb2VzIG5vdCBwcmV2ZW50IG90aGVyIGxpc3RlbmVycyBvbiBzYW1lIHRhcmdldFxuICAgKiAtIExlc3MgYWdncmVzc2l2ZSB0aGFuIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudC5tanMubWFwXG4iLCJ2YXIgYXBwbGVJcGhvbmUgPSAvaVBob25lL2k7XG52YXIgYXBwbGVJcG9kID0gL2lQb2QvaTtcbnZhciBhcHBsZVRhYmxldCA9IC9pUGFkL2k7XG52YXIgYXBwbGVVbml2ZXJzYWwgPSAvXFxiaU9TLXVuaXZlcnNhbCg/Oi4rKU1hY1xcYi9pO1xudmFyIGFuZHJvaWRQaG9uZSA9IC9cXGJBbmRyb2lkKD86LispTW9iaWxlXFxiL2k7XG52YXIgYW5kcm9pZFRhYmxldCA9IC9BbmRyb2lkL2k7XG52YXIgYW1hem9uUGhvbmUgPSAvKD86U0Q0OTMwVVJ8XFxiU2lsayg/Oi4rKU1vYmlsZVxcYikvaTtcbnZhciBhbWF6b25UYWJsZXQgPSAvU2lsay9pO1xudmFyIHdpbmRvd3NQaG9uZSA9IC9XaW5kb3dzIFBob25lL2k7XG52YXIgd2luZG93c1RhYmxldCA9IC9cXGJXaW5kb3dzKD86LispQVJNXFxiL2k7XG52YXIgb3RoZXJCbGFja0JlcnJ5ID0gL0JsYWNrQmVycnkvaTtcbnZhciBvdGhlckJsYWNrQmVycnkxMCA9IC9CQjEwL2k7XG52YXIgb3RoZXJPcGVyYSA9IC9PcGVyYSBNaW5pL2k7XG52YXIgb3RoZXJDaHJvbWUgPSAvXFxiKENyaU9TfENocm9tZSkoPzouKylNb2JpbGUvaTtcbnZhciBvdGhlckZpcmVmb3ggPSAvTW9iaWxlKD86LispRmlyZWZveFxcYi9pO1xudmFyIGlzQXBwbGVUYWJsZXRPbklvczEzID0gZnVuY3Rpb24gKG5hdmlnYXRvcikge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEgJiZcbiAgICAgICAgdHlwZW9mIE1TU3RyZWFtID09PSAndW5kZWZpbmVkJyk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTWF0Y2godXNlckFnZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWdleCkgeyByZXR1cm4gcmVnZXgudGVzdCh1c2VyQWdlbnQpOyB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2JpbGUocGFyYW0pIHtcbiAgICB2YXIgbmF2ID0ge1xuICAgICAgICB1c2VyQWdlbnQ6ICcnLFxuICAgICAgICBwbGF0Zm9ybTogJycsXG4gICAgICAgIG1heFRvdWNoUG9pbnRzOiAwXG4gICAgfTtcbiAgICBpZiAoIXBhcmFtICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5hdiA9IHtcbiAgICAgICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBuYXZpZ2F0b3IucGxhdGZvcm0sXG4gICAgICAgICAgICBtYXhUb3VjaFBvaW50czogbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYXYudXNlckFnZW50ID0gcGFyYW07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmFtICYmIHBhcmFtLnVzZXJBZ2VudCkge1xuICAgICAgICBuYXYgPSB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IHBhcmFtLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBwYXJhbS5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG1heFRvdWNoUG9pbnRzOiBwYXJhbS5tYXhUb3VjaFBvaW50cyB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50O1xuICAgIHZhciB0bXAgPSB1c2VyQWdlbnQuc3BsaXQoJ1tGQkFOJyk7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHVzZXJBZ2VudCA9IHRtcFswXTtcbiAgICB9XG4gICAgdG1wID0gdXNlckFnZW50LnNwbGl0KCdUd2l0dGVyJyk7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHVzZXJBZ2VudCA9IHRtcFswXTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gY3JlYXRlTWF0Y2godXNlckFnZW50KTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBhcHBsZToge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKGFwcGxlSXBob25lKSAmJiAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgICAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlSXBvZCksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaChhcHBsZUlwaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAobWF0Y2goYXBwbGVUYWJsZXQpIHx8IGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICAgICAgICB1bml2ZXJzYWw6IG1hdGNoKGFwcGxlVW5pdmVyc2FsKSxcbiAgICAgICAgICAgIGRldmljZTogKG1hdGNoKGFwcGxlSXBob25lKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKGFwcGxlSXBvZCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZVRhYmxldCkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChhcHBsZVVuaXZlcnNhbCkgfHxcbiAgICAgICAgICAgICAgICBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpXG4gICAgICAgIH0sXG4gICAgICAgIGFtYXpvbjoge1xuICAgICAgICAgICAgcGhvbmU6IG1hdGNoKGFtYXpvblBob25lKSxcbiAgICAgICAgICAgIHRhYmxldDogIW1hdGNoKGFtYXpvblBob25lKSAmJiBtYXRjaChhbWF6b25UYWJsZXQpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaChhbWF6b25QaG9uZSkgfHwgbWF0Y2goYW1hem9uVGFibGV0KVxuICAgICAgICB9LFxuICAgICAgICBhbmRyb2lkOiB7XG4gICAgICAgICAgICBwaG9uZTogKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFtYXpvblBob25lKSkgfHxcbiAgICAgICAgICAgICAgICAoIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiYgbWF0Y2goYW5kcm9pZFBob25lKSksXG4gICAgICAgICAgICB0YWJsZXQ6ICFtYXRjaCh3aW5kb3dzUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKGFtYXpvblBob25lKSAmJlxuICAgICAgICAgICAgICAgICFtYXRjaChhbmRyb2lkUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoKGFtYXpvblRhYmxldCkgfHwgbWF0Y2goYW5kcm9pZFRhYmxldCkpLFxuICAgICAgICAgICAgZGV2aWNlOiAoIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAobWF0Y2goYW1hem9uUGhvbmUpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKGFtYXpvblRhYmxldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFBob25lKSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXRjaChhbmRyb2lkVGFibGV0KSkpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goL1xcYm9raHR0cFxcYi9pKVxuICAgICAgICB9LFxuICAgICAgICB3aW5kb3dzOiB7XG4gICAgICAgICAgICBwaG9uZTogbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgICAgICAgIHRhYmxldDogbWF0Y2god2luZG93c1RhYmxldCksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKHdpbmRvd3NQaG9uZSkgfHwgbWF0Y2god2luZG93c1RhYmxldClcbiAgICAgICAgfSxcbiAgICAgICAgb3RoZXI6IHtcbiAgICAgICAgICAgIGJsYWNrYmVycnk6IG1hdGNoKG90aGVyQmxhY2tCZXJyeSksXG4gICAgICAgICAgICBibGFja2JlcnJ5MTA6IG1hdGNoKG90aGVyQmxhY2tCZXJyeTEwKSxcbiAgICAgICAgICAgIG9wZXJhOiBtYXRjaChvdGhlck9wZXJhKSxcbiAgICAgICAgICAgIGZpcmVmb3g6IG1hdGNoKG90aGVyRmlyZWZveCksXG4gICAgICAgICAgICBjaHJvbWU6IG1hdGNoKG90aGVyQ2hyb21lKSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2gob3RoZXJCbGFja0JlcnJ5KSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyQmxhY2tCZXJyeTEwKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyT3BlcmEpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2gob3RoZXJGaXJlZm94KSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKG90aGVyQ2hyb21lKVxuICAgICAgICB9LFxuICAgICAgICBhbnk6IGZhbHNlLFxuICAgICAgICBwaG9uZTogZmFsc2UsXG4gICAgICAgIHRhYmxldDogZmFsc2VcbiAgICB9O1xuICAgIHJlc3VsdC5hbnkgPVxuICAgICAgICByZXN1bHQuYXBwbGUuZGV2aWNlIHx8XG4gICAgICAgICAgICByZXN1bHQuYW5kcm9pZC5kZXZpY2UgfHxcbiAgICAgICAgICAgIHJlc3VsdC53aW5kb3dzLmRldmljZSB8fFxuICAgICAgICAgICAgcmVzdWx0Lm90aGVyLmRldmljZTtcbiAgICByZXN1bHQucGhvbmUgPVxuICAgICAgICByZXN1bHQuYXBwbGUucGhvbmUgfHwgcmVzdWx0LmFuZHJvaWQucGhvbmUgfHwgcmVzdWx0LndpbmRvd3MucGhvbmU7XG4gICAgcmVzdWx0LnRhYmxldCA9XG4gICAgICAgIHJlc3VsdC5hcHBsZS50YWJsZXQgfHwgcmVzdWx0LmFuZHJvaWQudGFibGV0IHx8IHJlc3VsdC53aW5kb3dzLnRhYmxldDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNb2JpbGUuanMubWFwIiwiaW1wb3J0IGlzTW9iaWxlSnMgZnJvbSAnaXNtb2JpbGVqcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNNb2JpbGVDYWxsID0gaXNNb2JpbGVKcy5kZWZhdWx0ID8/IGlzTW9iaWxlSnM7XG5jb25zdCBpc01vYmlsZSA9IGlzTW9iaWxlQ2FsbChnbG9iYWxUaGlzLm5hdmlnYXRvcik7XG5cbmV4cG9ydCB7IGlzTW9iaWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDYW52YXNPYnNlcnZlciB9IGZyb20gJy4uL2RvbS9DYW52YXNPYnNlcnZlci5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3Nlci9pc01vYmlsZS5tanMnO1xuaW1wb3J0IHsgcmVtb3ZlSXRlbXMgfSBmcm9tICcuLi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgS0VZX0NPREVfVEFCID0gOTtcbmNvbnN0IERJVl9UT1VDSF9TSVpFID0gMTAwO1xuY29uc3QgRElWX1RPVUNIX1BPU19YID0gMDtcbmNvbnN0IERJVl9UT1VDSF9QT1NfWSA9IDA7XG5jb25zdCBESVZfVE9VQ0hfWklOREVYID0gMjtcbmNvbnN0IERJVl9IT09LX1NJWkUgPSAxO1xuY29uc3QgRElWX0hPT0tfUE9TX1ggPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfUE9TX1kgPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfWklOREVYID0gMjtcbmNvbnN0IF9BY2Nlc3NpYmlsaXR5U3lzdGVtID0gY2xhc3MgX0FjY2Vzc2liaWxpdHlTeXN0ZW0ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1wYXJhbVxuICAvKipcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfFdlYkdQVVJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgX21vYmlsZUluZm8gPSBpc01vYmlsZSkge1xuICAgIHRoaXMuX21vYmlsZUluZm8gPSBfbW9iaWxlSW5mbztcbiAgICAvKiogV2hldGhlciBhY2Nlc3NpYmlsaXR5IGRpdnMgYXJlIHZpc2libGUgZm9yIGRlYnVnZ2luZyAqL1xuICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICAvKiogV2hldGhlciB0byBhY3RpdmF0ZSBvbiB0YWIga2V5IHByZXNzICovXG4gICAgdGhpcy5fYWN0aXZhdGVPblRhYiA9IHRydWU7XG4gICAgLyoqIFdoZXRoZXIgdG8gZGVhY3RpdmF0ZSBhY2Nlc3NpYmlsaXR5IHdoZW4gbW91c2UgbW92ZXMgKi9cbiAgICB0aGlzLl9kZWFjdGl2YXRlT25Nb3VzZU1vdmUgPSB0cnVlO1xuICAgIC8qKiBJbnRlcm5hbCB2YXJpYWJsZSwgc2VlIGlzQWN0aXZlIGdldHRlci4gKi9cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIC8qKiBJbnRlcm5hbCB2YXJpYWJsZSwgc2VlIGlzTW9iaWxlQWNjZXNzaWJpbGl0eSBnZXR0ZXIuICovXG4gICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XG4gICAgLyoqIFRoaXMgaXMgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLiAqL1xuICAgIHRoaXMuX2RpdiA9IG51bGw7XG4gICAgLyoqIEEgc2ltcGxlIHBvb2wgZm9yIHN0b3JpbmcgZGl2cy4gKi9cbiAgICB0aGlzLl9wb29scyA9IHt9O1xuICAgIC8qKiBUaGlzIGlzIGEgdGljayB1c2VkIHRvIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBubyBsb25nZXIgYmVpbmcgcmVuZGVyZWQuICovXG4gICAgdGhpcy5fcmVuZGVySWQgPSAwO1xuICAgIC8qKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IGFjdGl2ZSBhY2Nlc3NpYmxlIGl0ZW1zLiAqL1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgLyoqIENvdW50IHRvIHRocm90dGxlIGRpdiB1cGRhdGVzIG9uIGFuZHJvaWQgZGV2aWNlcy4gKi9cbiAgICB0aGlzLl9hbmRyb2lkVXBkYXRlQ291bnQgPSAwO1xuICAgIC8qKiAgVGhlIGZyZXF1ZW5jeSB0byB1cGRhdGUgdGhlIGRpdiBlbGVtZW50cy4gKi9cbiAgICB0aGlzLl9hbmRyb2lkVXBkYXRlRnJlcXVlbmN5ID0gNTAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXJlYWRvbmx5XG4gICAgdGhpcy5faXNSdW5uaW5nVGVzdHMgPSBmYWxzZTtcbiAgICAvKiogQm91bmQgZnVuY3Rpb24gcmVmZXJlbmNlcyBmb3IgcHJvcGVyIGV2ZW50IGxpc3RlbmVyIHJlbW92YWwgKi9cbiAgICB0aGlzLl9ib3VuZE9uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hvb2tEaXYgPSBudWxsO1xuICAgIGlmIChfbW9iaWxlSW5mby50YWJsZXQgfHwgX21vYmlsZUluZm8ucGhvbmUpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVRvdWNoSG9vaygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBWYWx1ZSBvZiBgdHJ1ZWAgaWYgYWNjZXNzaWJpbGl0eSBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCBhY2Nlc3NpYmlsaXR5IGxheWVycyBhcmUgc2hvd2luZy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVmFsdWUgb2YgYHRydWVgIGlmIGFjY2Vzc2liaWxpdHkgaXMgZW5hYmxlZCBmb3IgdG91Y2ggZGV2aWNlcy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzTW9iaWxlQWNjZXNzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5O1xuICB9XG4gIC8qKlxuICAgKiBCdXR0b24gZWxlbWVudCBmb3IgaGFuZGxpbmcgdG91Y2ggaG9va3MuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhvb2tEaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvb2tEaXY7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBET00gZWxlbWVudCB0aGF0IHdpbGwgc2l0IG92ZXIgdGhlIFBpeGlKUyBlbGVtZW50LiBUaGlzIGlzIHdoZXJlIHRoZSBkaXYgb3ZlcmxheXMgd2lsbCBnby5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXY7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHRvdWNoIGhvb2tzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRvdWNoSG9vaygpIHtcbiAgICBjb25zdCBob29rRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBob29rRGl2LnN0eWxlLndpZHRoID0gYCR7RElWX0hPT0tfU0laRX1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfSE9PS19TSVpFfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGhvb2tEaXYuc3R5bGUudG9wID0gYCR7RElWX0hPT0tfUE9TX1h9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUubGVmdCA9IGAke0RJVl9IT09LX1BPU19ZfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLnpJbmRleCA9IERJVl9IT09LX1pJTkRFWC50b1N0cmluZygpO1xuICAgIGhvb2tEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgaG9va0Rpdi50aXRsZSA9IFwic2VsZWN0IHRvIGVuYWJsZSBhY2Nlc3NpYmlsaXR5IGZvciB0aGlzIGNvbnRlbnRcIjtcbiAgICBob29rRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYWN0aXZhdGUoKTtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvb2tEaXYpO1xuICAgIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdG91Y2ggaG9va3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzdHJveVRvdWNoSG9vaygpIHtcbiAgICBpZiAoIXRoaXMuX2hvb2tEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9ob29rRGl2KTtcbiAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIHNob3duLlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZSB0YWIga2V5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9kaXYpIHtcbiAgICAgIHRoaXMuX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLl9kaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICB0aGlzLl9kaXYuc3R5bGUudG9wID0gYCR7RElWX1RPVUNIX1BPU19YfXB4YDtcbiAgICAgIHRoaXMuX2Rpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX1RPVUNIX1BPU19ZfXB4YDtcbiAgICAgIHRoaXMuX2Rpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICB0aGlzLl9kaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xuICAgICAgdGhpcy5fY2FudmFzT2JzZXJ2ZXIgPSBuZXcgQ2FudmFzT2JzZXJ2ZXIoe1xuICAgICAgICBkb21FbGVtZW50OiB0aGlzLl9kaXYsXG4gICAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmF0ZU9uVGFiKSB7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2JvdW5kT25LZXlEb3duLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWFjdGl2YXRlT25Nb3VzZU1vdmUpIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9ib3VuZE9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIudmlldy5jYW52YXM7XG4gICAgaWYgKCFjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9jYW52YXNPYnNlcnZlci5lbnN1cmVBdHRhY2hlZCgpO1xuICAgICAgICAgIHRoaXMuX2luaXRBY2Nlc3NpYmlsaXR5U2V0dXAoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jYW52YXNPYnNlcnZlci5lbnN1cmVBdHRhY2hlZCgpO1xuICAgICAgdGhpcy5faW5pdEFjY2Vzc2liaWxpdHlTZXR1cCgpO1xuICAgIH1cbiAgfVxuICAvLyBOZXcgbWV0aG9kIHRvIGhhbmRsZSBpbml0aWFsaXphdGlvbiBhZnRlciBkaXYgaXMgcmVhZHlcbiAgX2luaXRBY2Nlc3NpYmlsaXR5U2V0dXAoKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLmFkZCh0aGlzKTtcbiAgICBpZiAodGhpcy5fcmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyh0aGlzLl9yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGFjY2Vzc2liaWxpdHkgc3lzdGVtLiBSZW1vdmVzIGxpc3RlbmVycyBhbmQgYWNjZXNzaWJpbGl0eSBlbGVtZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWFjdGl2YXRlKCkge1xuICAgIGlmICghdGhpcy5faXNBY3RpdmUgfHwgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2JvdW5kT25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIGlmICh0aGlzLl9hY3RpdmF0ZU9uVGFiKSB7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2JvdW5kT25LZXlEb3duLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJ1bm5lcnMucG9zdHJlbmRlci5yZW1vdmUodGhpcyk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkLl9hY2Nlc3NpYmxlRGl2Py5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZURpdiA9IG51bGw7XG4gICAgICB9XG4gICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFjY2Vzc2libGVUeXBlIGluIHRoaXMuX3Bvb2xzKSB7XG4gICAgICBjb25zdCBwb29sID0gdGhpcy5fcG9vbHNbYWNjZXNzaWJsZVR5cGVdO1xuICAgICAgcG9vbC5mb3JFYWNoKChkaXYpID0+IHtcbiAgICAgICAgaWYgKGRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fcG9vbHNbYWNjZXNzaWJsZVR5cGVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGl2Py5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9kaXYpO1xuICAgIH1cbiAgICB0aGlzLl9wb29scyA9IHt9O1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlIGZ1bmN0aW9uIHdpbGwgcnVuIHRocm91Z2ggdGhlIHNjZW5lIGdyYXBoIGFuZCBhZGQgYW55IG5ldyBhY2Nlc3NpYmxlIG9iamVjdHMgdG8gdGhlIERPTSBsYXllci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBDb250YWluZXIgdG8gY2hlY2suXG4gICAqL1xuICBfdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY29udGFpbmVyKSB7XG4gICAgaWYgKCFjb250YWluZXIudmlzaWJsZSB8fCAhY29udGFpbmVyLmFjY2Vzc2libGVDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmFjY2Vzc2libGUpIHtcbiAgICAgIGlmICghY29udGFpbmVyLl9hY2Nlc3NpYmxlQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBjb250YWluZXIuX3JlbmRlcklkID0gdGhpcy5fcmVuZGVySWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl91cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyhjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSdW5uZXIgaW5pdCBjYWxsZWQsIHZpZXcgaXMgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRPcHRzID0gX0FjY2Vzc2liaWxpdHlTeXN0ZW0uZGVmYXVsdE9wdGlvbnM7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc2liaWxpdHlPcHRpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRzLFxuICAgICAgICAuLi5vcHRpb25zPy5hY2Nlc3NpYmlsaXR5T3B0aW9ucyB8fCB7fVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kZWJ1ZyA9IG1lcmdlZE9wdGlvbnMuYWNjZXNzaWJpbGl0eU9wdGlvbnMuZGVidWc7XG4gICAgdGhpcy5fYWN0aXZhdGVPblRhYiA9IG1lcmdlZE9wdGlvbnMuYWNjZXNzaWJpbGl0eU9wdGlvbnMuYWN0aXZhdGVPblRhYjtcbiAgICB0aGlzLl9kZWFjdGl2YXRlT25Nb3VzZU1vdmUgPSBtZXJnZWRPcHRpb25zLmFjY2Vzc2liaWxpdHlPcHRpb25zLmRlYWN0aXZhdGVPbk1vdXNlTW92ZTtcbiAgICBpZiAobWVyZ2VkT3B0aW9ucy5hY2Nlc3NpYmlsaXR5T3B0aW9ucy5lbmFibGVkQnlEZWZhdWx0KSB7XG4gICAgICB0aGlzLl9hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5ydW5uZXJzLnBvc3RyZW5kZXIucmVtb3ZlKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBhY2Nlc3NpYmlsaXR5IGxheWVyIGR1cmluZyByZW5kZXJpbmcuXG4gICAqIC0gUmVtb3ZlcyBkaXZzIGZvciBjb250YWluZXJzIG5vIGxvbmdlciBpbiB0aGUgc2NlbmVcbiAgICogLSBVcGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucyBvZiB0aGUgcm9vdCBkaXZcbiAgICogLSBVcGRhdGVzIHBvc2l0aW9ucyBvZiBhY3RpdmUgYWNjZXNzaWJpbGl0eSBkaXZzXG4gICAqIE9ubHkgZmlyZXMgd2hpbGUgdGhlIGFjY2Vzc2liaWxpdHkgc3lzdGVtIGlzIGFjdGl2ZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcG9zdHJlbmRlcigpIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodGhpcy5fbW9iaWxlSW5mby5hbmRyb2lkLmRldmljZSAmJiBub3cgPCB0aGlzLl9hbmRyb2lkVXBkYXRlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYW5kcm9pZFVwZGF0ZUNvdW50ID0gbm93ICsgdGhpcy5fYW5kcm9pZFVwZGF0ZUZyZXF1ZW5jeTtcbiAgICBpZiAoKCF0aGlzLl9yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbiB8fCAhdGhpcy5fcmVuZGVyZXIudmlldy5jYW52YXMpICYmICF0aGlzLl9pc1J1bm5pbmdUZXN0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmICh0aGlzLl9yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjY2Vzc2libGVPYmplY3RzKHRoaXMuX3JlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCk7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fcmVuZGVySWQgPT09IHRoaXMuX3JlbmRlcklkKSB7XG4gICAgICAgICAgYWN0aXZlSWRzLmFkZCh0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgaWYgKCFhY3RpdmVJZHMuaGFzKGkpKSB7XG4gICAgICAgIGlmIChjaGlsZC5fYWNjZXNzaWJsZURpdiAmJiBjaGlsZC5fYWNjZXNzaWJsZURpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgICAgY29uc3QgcG9vbCA9IHRoaXMuX2dldFBvb2woY2hpbGQuYWNjZXNzaWJsZVR5cGUpO1xuICAgICAgICAgIHBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVEaXYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZUl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XG4gICAgICB0aGlzLl9jYW52YXNPYnNlcnZlci5lbnN1cmVBdHRhY2hlZCgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgaWYgKCFjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSB8fCAhY2hpbGQuX2FjY2Vzc2libGVEaXYpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXYgPSBjaGlsZC5fYWNjZXNzaWJsZURpdjtcbiAgICAgIGNvbnN0IGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhIHx8IGNoaWxkLmdldEJvdW5kcygpLnJlY3RhbmdsZTtcbiAgICAgIGlmIChjaGlsZC5oaXRBcmVhKSB7XG4gICAgICAgIGNvbnN0IHd0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7d3QudHggKyBoaXRBcmVhLnggKiB3dC5hfXB4YDtcbiAgICAgICAgZGl2LnN0eWxlLnRvcCA9IGAke3d0LnR5ICsgaGl0QXJlYS55ICogd3QuZH1weGA7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiB3dC5hfXB4YDtcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0ICogd3QuZH1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYXBIaXRBcmVhKGhpdEFyZWEpO1xuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAke2hpdEFyZWEueH1weGA7XG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSBgJHtoaXRBcmVhLnl9cHhgO1xuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRofXB4YDtcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVuZGVySWQrKztcbiAgfVxuICAvKipcbiAgICogcHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHdpbGwgdmlzdWFsbHkgYWRkIHRoZSBpbmZvcm1hdGlvbiB0byB0aGVcbiAgICogYWNjZXNzaWJpbGl0eSBkaXZcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2IC1cbiAgICovXG4gIF91cGRhdGVEZWJ1Z0hUTUwoZGl2KSB7XG4gICAgZGl2LmlubmVySFRNTCA9IGB0eXBlOiAke2Rpdi50eXBlfTwvYnI+IHRpdGxlIDogJHtkaXYudGl0bGV9PC9icj4gdGFiSW5kZXg6ICR7ZGl2LnRhYkluZGV4fWA7XG4gIH1cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgaGl0IGFyZWEgYmFzZWQgb24gdGhlIGJvdW5kcyBvZiBhIGRpc3BsYXkgb2JqZWN0XG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBoaXRBcmVhIC0gQm91bmRzIG9mIHRoZSBjaGlsZFxuICAgKi9cbiAgX2NhcEhpdEFyZWEoaGl0QXJlYSkge1xuICAgIGlmIChoaXRBcmVhLnggPCAwKSB7XG4gICAgICBoaXRBcmVhLndpZHRoICs9IGhpdEFyZWEueDtcbiAgICAgIGhpdEFyZWEueCA9IDA7XG4gICAgfVxuICAgIGlmIChoaXRBcmVhLnkgPCAwKSB7XG4gICAgICBoaXRBcmVhLmhlaWdodCArPSBoaXRBcmVhLnk7XG4gICAgICBoaXRBcmVhLnkgPSAwO1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRoOiB2aWV3V2lkdGgsIGhlaWdodDogdmlld0hlaWdodCB9ID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgaWYgKGhpdEFyZWEueCArIGhpdEFyZWEud2lkdGggPiB2aWV3V2lkdGgpIHtcbiAgICAgIGhpdEFyZWEud2lkdGggPSB2aWV3V2lkdGggLSBoaXRBcmVhLng7XG4gICAgfVxuICAgIGlmIChoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdmlld0hlaWdodCAtIGhpdEFyZWEueTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgcmV1c2VzIGEgZGl2IGVsZW1lbnQgZm9yIGEgQ29udGFpbmVyIGFuZCBhZGRzIGl0IHRvIHRoZSBhY2Nlc3NpYmlsaXR5IGxheWVyLlxuICAgKiBTZXRzIHVwIEFSSUEgYXR0cmlidXRlcywgZXZlbnQgbGlzdGVuZXJzLCBhbmQgcG9zaXRpb25pbmcgYmFzZWQgb24gdGhlIGNvbnRhaW5lcidzIHByb3BlcnRpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY2hpbGQgdG8gbWFrZSBhY2Nlc3NpYmxlLlxuICAgKi9cbiAgX2FkZENoaWxkKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLl9nZXRQb29sKGNvbnRhaW5lci5hY2Nlc3NpYmxlVHlwZSk7XG4gICAgbGV0IGRpdiA9IHBvb2wucG9wKCk7XG4gICAgaWYgKGRpdikge1xuICAgICAgZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBkaXYucmVtb3ZlQXR0cmlidXRlKFwidGl0bGVcIik7XG4gICAgICBkaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcbiAgICAgIGRpdi50YWJJbmRleCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250YWluZXIuYWNjZXNzaWJsZVR5cGUgPT09IFwiYnV0dG9uXCIpIHtcbiAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29udGFpbmVyLmFjY2Vzc2libGVUeXBlKTtcbiAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5hY2Nlc3NpYmxlVGV4dCkge1xuICAgICAgICAgIGRpdi5pbm5lclRleHQgPSBjb250YWluZXIuYWNjZXNzaWJsZVRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YDtcbiAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kZWJ1ZyA/IFwicmdiYSgyNTUsMjU1LDI1NSwwLjUpXCIgOiBcInRyYW5zcGFyZW50XCI7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBkaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xuICAgICAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gXCJub25lXCI7XG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiY2hyb21lXCIpKSB7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJvZmZcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2Oi4qR2Vja29cXC8vKSkge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcImFkZGl0aW9uc1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlbGV2YW50XCIsIFwidGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5fb25Gb2N1c091dC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBjb250YWluZXIuYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM7XG4gICAgZGl2LnR5cGUgPSBjb250YWluZXIuYWNjZXNzaWJsZVR5cGU7XG4gICAgaWYgKGNvbnRhaW5lci5hY2Nlc3NpYmxlVGl0bGUgJiYgY29udGFpbmVyLmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgZGl2LnRpdGxlID0gY29udGFpbmVyLmFjY2Vzc2libGVUaXRsZTtcbiAgICB9IGVsc2UgaWYgKCFjb250YWluZXIuYWNjZXNzaWJsZUhpbnQgfHwgY29udGFpbmVyLmFjY2Vzc2libGVIaW50ID09PSBudWxsKSB7XG4gICAgICBkaXYudGl0bGUgPSBgY29udGFpbmVyICR7Y29udGFpbmVyLnRhYkluZGV4fWA7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIuYWNjZXNzaWJsZUhpbnQgJiYgY29udGFpbmVyLmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBjb250YWluZXIuYWNjZXNzaWJsZUhpbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmludGVyYWN0aXZlKSB7XG4gICAgICBkaXYudGFiSW5kZXggPSBjb250YWluZXIudGFiSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZWJ1Z0hUTUwoZGl2KTtcbiAgICB9XG4gICAgY29udGFpbmVyLl9hY2Nlc3NpYmxlQWN0aXZlID0gdHJ1ZTtcbiAgICBjb250YWluZXIuX2FjY2Vzc2libGVEaXYgPSBkaXY7XG4gICAgZGl2LmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XG4gICAgdGhpcy5fZGl2LmFwcGVuZENoaWxkKGNvbnRhaW5lci5fYWNjZXNzaWJsZURpdik7XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50cyB3aXRoIHRoZSBFdmVudFN5c3RlbS5cbiAgICogQHBhcmFtIGVcbiAgICogQHBhcmFtIHR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNwYXRjaEV2ZW50KGUsIHR5cGUpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lcjogdGFyZ2V0IH0gPSBlLnRhcmdldDtcbiAgICBjb25zdCBib3VuZGFyeSA9IHRoaXMuX3JlbmRlcmVyLmV2ZW50cy5yb290Qm91bmRhcnk7XG4gICAgY29uc3QgZXZlbnQgPSBPYmplY3QuYXNzaWduKG5ldyBGZWRlcmF0ZWRFdmVudChib3VuZGFyeSksIHsgdGFyZ2V0IH0pO1xuICAgIGJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgdHlwZS5mb3JFYWNoKCh0eXBlMikgPT4gYm91bmRhcnkuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZTIpKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZGl2IGJ1dHRvbiBwcmVzcyB0byBwaXhpJ3MgRXZlbnRTeXN0ZW0gKGNsaWNrKVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBUaGUgY2xpY2sgZXZlbnQuXG4gICAqL1xuICBfb25DbGljayhlKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJjbGlja1wiLCBcInBvaW50ZXJ0YXBcIiwgXCJ0YXBcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyBFdmVudFN5c3RlbSAobW91c2VvdmVyKVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXMgZXZlbnQuXG4gICAqL1xuICBfb25Gb2N1cyhlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIikpIHtcbiAgICAgIGUudGFyZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcImFzc2VydGl2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJtb3VzZW92ZXJcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyBFdmVudFN5c3RlbSAobW91c2VvdXQpXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZSAtIFRoZSBmb2N1c291dCBldmVudC5cbiAgICovXG4gIF9vbkZvY3VzT3V0KGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSkge1xuICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcIm1vdXNlb3V0XCJdKTtcbiAgfVxuICAvKipcbiAgICogSXMgY2FsbGVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBUaGUga2V5ZG93biBldmVudC5cbiAgICovXG4gIF9vbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9DT0RFX1RBQiB8fCAhdGhpcy5fYWN0aXZhdGVPblRhYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICovXG4gIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgaWYgKGUubW92ZW1lbnRYID09PSAwICYmIGUubW92ZW1lbnRZID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgc3lzdGVtLiBSZW1vdmVzIGFsbCBlbGVtZW50cyBhbmQgbGlzdGVuZXJzLlxuICAgKiA+IFshSU1QT1JUQU5UXSBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB7QGxpbmsgQXBwbGljYXRpb259IGlzIGRlc3Ryb3llZC5cbiAgICogPiBBIHR5cGljYWxseSB1c2VyIHNob3VsZCBub3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5fZGVzdHJveVRvdWNoSG9vaygpO1xuICAgIHRoaXMuX2NhbnZhc09ic2VydmVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fY2FudmFzT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX2RpdiA9IG51bGw7XG4gICAgdGhpcy5fcG9vbHMgPSBudWxsO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9ib3VuZE9uS2V5RG93bik7XG4gICAgdGhpcy5fYm91bmRPbktleURvd24gPSBudWxsO1xuICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9ib3VuZE9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICB0aGlzLl9ib3VuZE9uTW91c2VNb3ZlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYWNjZXNzaWJpbGl0eSBzeXN0ZW0uXG4gICAqIEBwYXJhbSBlbmFibGVkIC0gV2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBhY2Nlc3NpYmlsaXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhcHAucmVuZGVyZXIuYWNjZXNzaWJpbGl0eS5zZXRBY2Nlc3NpYmlsaXR5RW5hYmxlZCh0cnVlKTsgLy8gRW5hYmxlIGFjY2Vzc2liaWxpdHlcbiAgICogYXBwLnJlbmRlcmVyLmFjY2Vzc2liaWxpdHkuc2V0QWNjZXNzaWJpbGl0eUVuYWJsZWQoZmFsc2UpOyAvLyBEaXNhYmxlIGFjY2Vzc2liaWxpdHlcbiAgICogYGBgXG4gICAqL1xuICBzZXRBY2Nlc3NpYmlsaXR5RW5hYmxlZChlbmFibGVkKSB7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cbiAgX2dldFBvb2woYWNjZXNzaWJsZVR5cGUpIHtcbiAgICBpZiAoIXRoaXMuX3Bvb2xzW2FjY2Vzc2libGVUeXBlXSkge1xuICAgICAgdGhpcy5fcG9vbHNbYWNjZXNzaWJsZVR5cGVdID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb29sc1thY2Nlc3NpYmxlVHlwZV07XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0FjY2Vzc2liaWxpdHlTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImFjY2Vzc2liaWxpdHlcIlxufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyB1c2VkIGJ5IHRoZSBzeXN0ZW0uXG4gKiBZb3UgY2FuIHNldCB0aGVzZSBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSB7QGxpbmsgQXBwbGljYXRpb259IHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgQWNjZXNzaWJpbGl0eVN5c3RlbSB9IGZyb20gJ3BpeGkuanMnO1xuICpcbiAqIEFjY2Vzc2liaWxpdHlTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuZW5hYmxlZEJ5RGVmYXVsdCA9IHRydWU7XG4gKlxuICogY29uc3QgYXBwID0gbmV3IEFwcGxpY2F0aW9uKClcbiAqIGFwcC5pbml0KClcbiAqIGBgYFxuICovXG5fQWNjZXNzaWJpbGl0eVN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGFjY2Vzc2liaWxpdHkgZmVhdHVyZXMgb24gaW5pdGlhbGl6YXRpb25cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVuYWJsZWRCeURlZmF1bHQ6IGZhbHNlLFxuICAvKipcbiAgICogV2hldGhlciB0byB2aXN1YWxseSBzaG93IHRoZSBhY2Nlc3NpYmlsaXR5IGRpdnMgZm9yIGRlYnVnZ2luZ1xuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVidWc6IGZhbHNlLFxuICAvKipcbiAgICogV2hldGhlciB0byBhY3RpdmF0ZSBhY2Nlc3NpYmlsaXR5IHdoZW4gdGFiIGtleSBpcyBwcmVzc2VkXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGFjdGl2YXRlT25UYWI6IHRydWUsXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRlYWN0aXZhdGUgYWNjZXNzaWJpbGl0eSB3aGVuIG1vdXNlIG1vdmVzXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGRlYWN0aXZhdGVPbk1vdXNlTW92ZTogdHJ1ZVxufTtcbmxldCBBY2Nlc3NpYmlsaXR5U3lzdGVtID0gX0FjY2Vzc2liaWxpdHlTeXN0ZW07XG5cbmV4cG9ydCB7IEFjY2Vzc2liaWxpdHlTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY2Vzc2liaWxpdHlTeXN0ZW0ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBhY2Nlc3NpYmlsaXR5VGFyZ2V0ID0ge1xuICBhY2Nlc3NpYmxlOiBmYWxzZSxcbiAgYWNjZXNzaWJsZVRpdGxlOiBudWxsLFxuICBhY2Nlc3NpYmxlSGludDogbnVsbCxcbiAgdGFiSW5kZXg6IDAsXG4gIGFjY2Vzc2libGVUeXBlOiBcImJ1dHRvblwiLFxuICBhY2Nlc3NpYmxlVGV4dDogbnVsbCxcbiAgYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICBhY2Nlc3NpYmxlQ2hpbGRyZW46IHRydWUsXG4gIF9hY2Nlc3NpYmxlQWN0aXZlOiBmYWxzZSxcbiAgX2FjY2Vzc2libGVEaXY6IG51bGwsXG4gIF9yZW5kZXJJZDogLTFcbn07XG5cbmV4cG9ydCB7IGFjY2Vzc2liaWxpdHlUYXJnZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2liaWxpdHlUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgQWNjZXNzaWJpbGl0eVN5c3RlbSB9IGZyb20gJy4vQWNjZXNzaWJpbGl0eVN5c3RlbS5tanMnO1xuaW1wb3J0IHsgYWNjZXNzaWJpbGl0eVRhcmdldCB9IGZyb20gJy4vYWNjZXNzaWJpbGl0eVRhcmdldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEFjY2Vzc2liaWxpdHlTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5taXhpbihDb250YWluZXIsIGFjY2Vzc2liaWxpdHlUYXJnZXQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iLCJpbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuLi90aWNrZXIvY29uc3QubWpzJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJy4uL3RpY2tlci9UaWNrZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBFdmVudHNUaWNrZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBUaGUgZnJlcXVlbmN5IHRoYXQgZmFrZSBldmVudHMgd2lsbCBiZSBmaXJlZC4gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgdGhpcy5fdGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBldmVudCB0aWNrZXIuXG4gICAqIEBwYXJhbSBldmVudHMgLSBUaGUgZXZlbnQgc3lzdGVtLlxuICAgKi9cbiAgaW5pdChldmVudHMpIHtcbiAgICB0aGlzLnJlbW92ZVRpY2tlckxpc3RlbmVyKCk7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IDEwO1xuICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XG4gICAgdGhpcy5fZGlkTW92ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3RpY2tlckFkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKiBXaGV0aGVyIHRvIHBhdXNlIHRoZSB1cGRhdGUgY2hlY2tzIG9yIG5vdC4gKi9cbiAgZ2V0IHBhdXNlVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZVVwZGF0ZTtcbiAgfVxuICBzZXQgcGF1c2VVcGRhdGUocGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSBwYXVzZWQ7XG4gIH1cbiAgLyoqIEFkZHMgdGhlIHRpY2tlciBsaXN0ZW5lci4gKi9cbiAgYWRkVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlckFkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgVGlja2VyLnN5c3RlbS5hZGQodGhpcy5fdGlja2VyVXBkYXRlLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuSU5URVJBQ1RJT04pO1xuICAgIHRoaXMuX3RpY2tlckFkZGVkID0gdHJ1ZTtcbiAgfVxuICAvKiogUmVtb3ZlcyB0aGUgdGlja2VyIGxpc3RlbmVyLiAqL1xuICByZW1vdmVUaWNrZXJMaXN0ZW5lcigpIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tlckFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMuX3RpY2tlclVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgfVxuICAvKiogU2V0cyBmbGFnIHRvIG5vdCBmaXJlIGV4dHJhIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGhhcyBhbHJlYWR5IG1vdmVkIHRoZXJlIG1vdXNlICovXG4gIHBvaW50ZXJNb3ZlZCgpIHtcbiAgICB0aGlzLl9kaWRNb3ZlID0gdHJ1ZTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0cy4gKi9cbiAgX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tRWxlbWVudCB8fCB0aGlzLl9wYXVzZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlkTW92ZSkge1xuICAgICAgdGhpcy5fZGlkTW92ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290UG9pbnRlckV2ZW50ID0gdGhpcy5ldmVudHNbXCJfcm9vdFBvaW50ZXJFdmVudFwiXTtcbiAgICBpZiAodGhpcy5ldmVudHMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA/IG5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVybW92ZVwiLCB7XG4gICAgICBjbGllbnRYOiByb290UG9pbnRlckV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiByb290UG9pbnRlckV2ZW50LmNsaWVudFksXG4gICAgICBwb2ludGVyVHlwZTogcm9vdFBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSxcbiAgICAgIHBvaW50ZXJJZDogcm9vdFBvaW50ZXJFdmVudC5wb2ludGVySWRcbiAgICB9KSA6IG5ldyBNb3VzZUV2ZW50KFwibW91c2Vtb3ZlXCIsIHtcbiAgICAgIGNsaWVudFg6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0cyBpZiBhdCBsZWFzdCB7QGxpbmsgaW50ZXJhY3Rpb25GcmVxdWVuY3l9XG4gICAqIG1pbGxpc2Vjb25kcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBpbnZvY2F0aW9uLlxuICAgKlxuICAgKiBJbnZva2VkIGJ5IGEgdGhyb3R0bGVkIHRpY2tlciB1cGRhdGUgZnJvbSB7QGxpbmsgVGlja2VyLnN5c3RlbX0uXG4gICAqIEBwYXJhbSB0aWNrZXIgLSBUaGUgdGhyb3R0bGVkIHRpY2tlci5cbiAgICovXG4gIF90aWNrZXJVcGRhdGUodGlja2VyKSB7XG4gICAgdGhpcy5fZGVsdGFUaW1lICs9IHRpY2tlci5kZWx0YVRpbWU7XG4gICAgaWYgKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIGV2ZW50IHRpY2tlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVRpY2tlckxpc3RlbmVyKCk7XG4gICAgdGhpcy5ldmVudHMgPSBudWxsO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgdGhpcy5fdGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHRydWU7XG4gIH1cbn1cbmNvbnN0IEV2ZW50c1RpY2tlciA9IG5ldyBFdmVudHNUaWNrZXJDbGFzcygpO1xuXG5leHBvcnQgeyBFdmVudHNUaWNrZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VGlja2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRFdmVudC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZlZGVyYXRlZE1vdXNlRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcy4gKi9cbiAgICB0aGlzLmNsaWVudCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgbW92ZW1lbnQgaW4gdGhpcyBwb2ludGVyIHJlbGF0aXZlIHRvIHRoZSBsYXN0IGBtb3VzZW1vdmVgIGV2ZW50LiAqL1xuICAgIHRoaXMubW92ZW1lbnQgPSBuZXcgUG9pbnQoKTtcbiAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgcG9pbnRlciBjb29yZGluYXRlcyB3LnIudC4gdGFyZ2V0IENvbnRhaW5lciBpbiB3b3JsZCBzcGFjZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQuICovXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgUG9pbnQoKTtcbiAgICAvKiogVGhlIHBvaW50ZXIgY29vcmRpbmF0ZXMgaW4gd29ybGQgc3BhY2UuICovXG4gICAgdGhpcy5nbG9iYWwgPSBuZXcgUG9pbnQoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9pbnRlciBjb29yZGluYXRlcyBpbiB0aGUgcmVuZGVyZXIncyB7QGxpbmsgQWJzdHJhY3RSZW5kZXJlci5zY3JlZW4gc2NyZWVufS4gVGhpcyBoYXMgc2xpZ2h0bHlcbiAgICAgKiBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gbmF0aXZlIFBvaW50ZXJFdmVudCBzY3JlZW5YL3NjcmVlblkuXG4gICAgICovXG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgUG9pbnQoKTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGNsaWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lnk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgRmVkZXJhdGVkTW91c2VFdmVudC5jbGllbnRYIHRoaXMuY2xpZW50WH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WDtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBGZWRlcmF0ZWRNb3VzZUV2ZW50LmNsaWVudFkgdGhpcy5jbGllbnRZfS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRZO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgb2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGdsb2JhbFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIGBzY3JlZW4ueGAuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIGBzY3JlZW4ueWAuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGdsb2JhbCBjb29yZGluYXRlcyBpbnRvIGNvbnRhaW5lci1sb2NhbCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgdHJhbnNmb3JtcyBjb29yZGluYXRlcyBmcm9tIHdvcmxkIHNwYWNlIHRvIGEgY29udGFpbmVyJ3MgbG9jYWwgc3BhY2UsXG4gICAqIHVzZWZ1bCBmb3IgcHJlY2lzZSBwb3NpdGlvbmluZyBhbmQgaGl0IHRlc3RpbmcuXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgQ29udGFpbmVyIHRvIGdldCBsb2NhbCBjb29yZGluYXRlcyBmb3JcbiAgICogQHBhcmFtIHBvaW50IC0gT3B0aW9uYWwgUG9pbnQgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQuIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgUG9pbnQgd2lsbCBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSBnbG9iYWxQb3MgLSBPcHRpb25hbCBjdXN0b20gZ2xvYmFsIGNvb3JkaW5hdGVzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBldmVudCdzIGdsb2JhbCBwb3NpdGlvbiBpcyB1c2VkXG4gICAqIEByZXR1cm5zIFRoZSBsb2NhbCBjb29yZGluYXRlcyBhcyBhIFBvaW50IG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyB1c2FnZSAtIGdldCBsb2NhbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBhIGNvbnRhaW5lclxuICAgKiBzcHJpdGUub24oJ3BvaW50ZXJtb3ZlJywgKGV2ZW50OiBGZWRlcmF0ZWRNb3VzZUV2ZW50KSA9PiB7XG4gICAqICAgICAvLyBHZXQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHNwcml0ZVxuICAgKiAgICAgY29uc3QgbG9jYWxQb3MgPSBldmVudC5nZXRMb2NhbFBvc2l0aW9uKHNwcml0ZSk7XG4gICAqICAgICBjb25zb2xlLmxvZygnTG9jYWwgcG9zaXRpb246JywgbG9jYWxQb3MueCwgbG9jYWxQb3MueSk7XG4gICAqIH0pO1xuICAgKiAvLyBVc2luZyBjdXN0b20gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAqIGNvbnN0IGN1c3RvbUdsb2JhbCA9IG5ldyBQb2ludCgxMDAsIDEwMCk7XG4gICAqIHNwcml0ZS5vbigncG9pbnRlcm1vdmUnLCAoZXZlbnQ6IEZlZGVyYXRlZE1vdXNlRXZlbnQpID0+IHtcbiAgICogICAgIC8vIFRyYW5zZm9ybSBjdXN0b20gY29vcmRpbmF0ZXNcbiAgICogICAgIGNvbnN0IGxvY2FsUG9zID0gZXZlbnQuZ2V0TG9jYWxQb3NpdGlvbihzcHJpdGUsIHVuZGVmaW5lZCwgY3VzdG9tR2xvYmFsKTtcbiAgICogICAgIGNvbnNvbGUubG9nKCdDdXN0b20gbG9jYWwgcG9zaXRpb246JywgbG9jYWxQb3MueCwgbG9jYWxQb3MueSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQHNlZSB7QGxpbmsgQ29udGFpbmVyLndvcmxkVHJhbnNmb3JtfSBGb3IgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKiBAc2VlIHtAbGluayBQb2ludH0gRm9yIHRoZSBwb2ludCBjbGFzcyB1c2VkIHRvIHN0b3JlIGNvb3JkaW5hdGVzXG4gICAqL1xuICBnZXRMb2NhbFBvc2l0aW9uKGNvbnRhaW5lciwgcG9pbnQsIGdsb2JhbFBvcykge1xuICAgIHJldHVybiBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGdsb2JhbFBvcyB8fCB0aGlzLmdsb2JhbCwgcG9pbnQpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBtb2RpZmllciBrZXkgd2FzIHByZXNzZWQgd2hlbiB0aGlzIGV2ZW50IG5hdGl2ZWx5IG9jY3VycmVkLlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIG1vZGlmaWVyIGtleS5cbiAgICovXG4gIGdldE1vZGlmaWVyU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIFwiZ2V0TW9kaWZpZXJTdGF0ZVwiIGluIHRoaXMubmF0aXZlRXZlbnQgJiYgdGhpcy5uYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIE5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSBfdHlwZUFyZ1xuICAgKiBAcGFyYW0gX2NhbkJ1YmJsZUFyZ1xuICAgKiBAcGFyYW0gX2NhbmNlbGFibGVBcmdcbiAgICogQHBhcmFtIF92aWV3QXJnXG4gICAqIEBwYXJhbSBfZGV0YWlsQXJnXG4gICAqIEBwYXJhbSBfc2NyZWVuWEFyZ1xuICAgKiBAcGFyYW0gX3NjcmVlbllBcmdcbiAgICogQHBhcmFtIF9jbGllbnRYQXJnXG4gICAqIEBwYXJhbSBfY2xpZW50WUFyZ1xuICAgKiBAcGFyYW0gX2N0cmxLZXlBcmdcbiAgICogQHBhcmFtIF9hbHRLZXlBcmdcbiAgICogQHBhcmFtIF9zaGlmdEtleUFyZ1xuICAgKiBAcGFyYW0gX21ldGFLZXlBcmdcbiAgICogQHBhcmFtIF9idXR0b25BcmdcbiAgICogQHBhcmFtIF9yZWxhdGVkVGFyZ2V0QXJnXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMC4wXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gIGluaXRNb3VzZUV2ZW50KF90eXBlQXJnLCBfY2FuQnViYmxlQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcsIF9zY3JlZW5YQXJnLCBfc2NyZWVuWUFyZywgX2NsaWVudFhBcmcsIF9jbGllbnRZQXJnLCBfY3RybEtleUFyZywgX2FsdEtleUFyZywgX3NoaWZ0S2V5QXJnLCBfbWV0YUtleUFyZywgX2J1dHRvbkFyZywgX3JlbGF0ZWRUYXJnZXRBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IEZlZGVyYXRlZE1vdXNlRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZE1vdXNlRXZlbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRNb3VzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHBvaW50ZXIncyBjb250YWN0IGFsb25nIHRoZSB4LWF4aXMsIG1lYXN1cmVkIGluIENTUyBwaXhlbHMuXG4gICAgICogcmFkaXVzWCBvZiBUb3VjaEV2ZW50cyB3aWxsIGJlIHJlcHJlc2VudGVkIGJ5IHRoaXMgdmFsdWUuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3dpZHRoXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcG9pbnRlcidzIGNvbnRhY3QgYWxvbmcgdGhlIHktYXhpcywgbWVhc3VyZWQgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiByYWRpdXNZIG9mIFRvdWNoRXZlbnRzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvaGVpZ2h0XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgcG9pbnRlciBkZXZpY2UgdGhhdCBjcmVhdGVkIHRoZSBldmVudCBpcyB0aGUgcHJpbWFyeSBwb2ludGVyLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC9pc1ByaW1hcnlcbiAgICAgKi9cbiAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBPbmx5IGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MgZm9yIG5vd1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXRDb2FsZXNjZWRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gXCJwb2ludGVybW92ZVwiIHx8IHRoaXMudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogT25seSBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzIGZvciBub3dcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZ2V0UHJlZGljdGVkRXZlbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFByZWRpY3RlZEV2ZW50cyBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRmVkZXJhdGVkV2hlZWxFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFVuaXRzIHNwZWNpZmllZCBpbiBwaXhlbHMuXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX1BJWEVMID0gMDtcbiAgICAvKipcbiAgICAgKiBVbml0cyBzcGVjaWZpZWQgaW4gbGluZXMuXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX0xJTkUgPSAxO1xuICAgIC8qKlxuICAgICAqIFVuaXRzIHNwZWNpZmllZCBpbiBwYWdlcy5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDI7XG4gIH1cbn1cbi8qKlxuICogVW5pdHMgc3BlY2lmaWVkIGluIHBpeGVscy5cbiAqIEBpZ25vcmVcbiAqL1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwgPSAwO1xuLyoqXG4gKiBVbml0cyBzcGVjaWZpZWQgaW4gbGluZXMuXG4gKiBAaWdub3JlXG4gKi9cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPSAxO1xuLyoqXG4gKiBVbml0cyBzcGVjaWZpZWQgaW4gcGFnZXMuXG4gKiBAaWdub3JlXG4gKi9cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UgPSAyO1xuXG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBFdmVudHNUaWNrZXIgfSBmcm9tICcuL0V2ZW50VGlja2VyLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFBST1BBR0FUSU9OX0xJTUlUID0gMjA0ODtcbmNvbnN0IHRlbXBIaXRMb2NhdGlvbiA9IG5ldyBQb2ludCgpO1xuY29uc3QgdGVtcExvY2FsTWFwcGluZyA9IG5ldyBQb2ludCgpO1xuY2xhc3MgRXZlbnRCb3VuZGFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcm9vdFRhcmdldCAtIFRoZSBob2xkZXIgb2YgdGhlIGV2ZW50IGJvdW5kYXJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdFRhcmdldCkge1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGV2ZW50cyBhZnRlciB0aGV5IHdlcmUgZGlzcGF0Y2hlZCBpbnRvIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGdsb2JhbCBldmVudHMgbGlzdGVuaW5nLCByZWdhcmRsZXNzIG9mIHRoZSBzY2VuZSBncmFwaCBiZWluZyB1c2VkLiBJdCBzaG91bGRcbiAgICAgKiBub3QgYmUgdXNlZCBieSBpbnRlcmFjdGl2ZSBsaWJyYXJpZXMgZm9yIG5vcm1hbCB1c2UuXG4gICAgICpcbiAgICAgKiBTcGVjaWFsIGV2ZW50cyB0aGF0IGRvIG5vdCBidWJibGUgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QgdGFyZ2V0IGFyZSBub3QgZW1pdHRlZCBmcm9tIGhlcmUsXG4gICAgICogZS5nLiBwb2ludGVyZW50ZXIsIHBvaW50ZXJsZWF2ZSwgY2xpY2suXG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgd291bGQgZW1pdCBgcG9pbnRlcm1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZW1vdmVgIGV2ZW50cyBvbiBhbGwgQ29udGFpbmVycy5cbiAgICAgKlxuICAgICAqIFRoZSBgbW92ZU9uQWxsYCBzZW1hbnRpY3MgbWlycm9yIHRob3NlIG9mIGVhcmxpZXIgdmVyc2lvbnMgb2YgUGl4aUpTLiBUaGlzIHdhcyBkaXNhYmxlZCBpbiBmYXZvciBvZlxuICAgICAqIHRoZSBQb2ludGVyIEV2ZW50IEFQSSdzIGFwcHJvYWNoLlxuICAgICAqL1xuICAgIHRoaXMubW92ZU9uQWxsID0gZmFsc2U7XG4gICAgLyoqIEVuYWJsZXMgdGhlIGdsb2JhbCBtb3ZlIGV2ZW50cy4gYGdsb2JhbHBvaW50ZXJtb3ZlYCwgYGdsb2JhbHRvdWNobW92ZWAsIGFuZCBgZ2xvYmFsbW91c2Vtb3ZlYCAqL1xuICAgIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU3RhdGUgb2JqZWN0IGZvciBtYXBwaW5nIG1ldGhvZHMuXG4gICAgICogQHNlZSBFdmVudEJvdW5kYXJ5I3RyYWNraW5nRGF0YVxuICAgICAqL1xuICAgIHRoaXMubWFwcGluZ1N0YXRlID0ge1xuICAgICAgdHJhY2tpbmdEYXRhOiB7fVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHBvb2wgbWFwcyBldmVudCBjb25zdHJ1Y3RvcnMgdG8gYW4gZnJlZSBwb29sIG9mIGluc3RhbmNlcyBvZiB0aG9zZSBzcGVjaWZpYyBldmVudHMuXG4gICAgICogQHNlZSBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnRcbiAgICAgKiBAc2VlIEV2ZW50Qm91bmRhcnkjZnJlZUV2ZW50XG4gICAgICovXG4gICAgdGhpcy5ldmVudFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8qKiBFdmVyeSBpbnRlcmFjdGl2ZSBlbGVtZW50IGdhdGhlcmVkIGZyb20gdGhlIHNjZW5lLiBPbmx5IHVzZWQgaW4gYHBvaW50ZXJtb3ZlYCAqL1xuICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICAvKiogRXZlcnkgZWxlbWVudCB0aGF0IHBhc3NlZCB0aGUgaGl0IHRlc3QuIE9ubHkgdXNlZCBpbiBgcG9pbnRlcm1vdmVgICovXG4gICAgdGhpcy5faGl0RWxlbWVudHMgPSBbXTtcbiAgICAvKiogV2hldGhlciBvciBub3QgdG8gY29sbGVjdCBhbGwgdGhlIGludGVyYWN0aXZlIGVsZW1lbnRzIGZyb20gdGhlIHNjZW5lLiBFbmFibGVkIGluIGBwb2ludGVybW92ZWAgKi9cbiAgICB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RUYXJnZXQgPSByb290VGFyZ2V0O1xuICAgIHRoaXMuaGl0UHJ1bmVGbiA9IHRoaXMuaGl0UHJ1bmVGbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGl0VGVzdEZuID0gdGhpcy5oaXRUZXN0Rm4uYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJEb3duID0gdGhpcy5tYXBQb2ludGVyRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlck1vdmUgPSB0aGlzLm1hcFBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3V0ID0gdGhpcy5tYXBQb2ludGVyT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3ZlciA9IHRoaXMubWFwUG9pbnRlck92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJVcCA9IHRoaXMubWFwUG9pbnRlclVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlID0gdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBXaGVlbCA9IHRoaXMubWFwV2hlZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9O1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcmRvd25cIiwgdGhpcy5tYXBQb2ludGVyRG93bik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybW92ZVwiLCB0aGlzLm1hcFBvaW50ZXJNb3ZlKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdXRcIiwgdGhpcy5tYXBQb2ludGVyT3V0KTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLm1hcFBvaW50ZXJPdXQpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5tYXBQb2ludGVyT3Zlcik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBcIiwgdGhpcy5tYXBQb2ludGVyVXApO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcnVwb3V0c2lkZVwiLCB0aGlzLm1hcFBvaW50ZXJVcE91dHNpZGUpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwid2hlZWxcIiwgdGhpcy5tYXBXaGVlbCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbWFwcGluZyBmb3IgdGhlIGV2ZW50IGB0eXBlYCBoYW5kbGVkIGJ5IGBmbmAuXG4gICAqXG4gICAqIEV2ZW50IG1hcHBpbmdzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBhZGRpdGlvbmFsIG9yIGN1c3RvbSBldmVudHMuIFRoZXkgdGFrZSBhbiBldmVudFxuICAgKiBjb21pbmcgZnJvbSB0aGUgdXBzdHJlYW0gc2NlbmUgKG9yIGRpcmVjdGx5IGZyb20gdGhlIHtAbGluayBFdmVudFN5c3RlbX0pIGFuZCBkaXNwYXRjaCBuZXcgZG93bnN0cmVhbSBldmVudHNcbiAgICogZ2VuZXJhbGx5IHRyaWNrbGluZyBkb3duIGFuZCBidWJibGluZyB1cCB0byB7QGxpbmsgRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0uXG4gICAqXG4gICAqIFRvIG1vZGlmeSB0aGUgc2VtYW50aWNzIG9mIGV4aXN0aW5nIGV2ZW50cywgdGhlIGJ1aWx0LWluIG1hcHBpbmcgbWV0aG9kcyBvZiBFdmVudEJvdW5kYXJ5IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdXBzdHJlYW0gZXZlbnQgdG8gbWFwLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbWFwcGluZyBtZXRob2QuIFRoZSBjb250ZXh0IG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBib3VuZCBtYW51YWxseSwgaWYgZGVzaXJlZC5cbiAgICovXG4gIGFkZEV2ZW50TWFwcGluZyh0eXBlLCBmbikge1xuICAgIGlmICghdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0pIHtcbiAgICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnB1c2goe1xuICAgICAgZm4sXG4gICAgICBwcmlvcml0eTogMFxuICAgIH0pO1xuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgZ2l2ZW4gZXZlbnRcbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gZGlzcGF0Y2guIERlZmF1bHRzIHRvIGBlLnR5cGVgLlxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wYWdhdGUoZSwgdHlwZSk7XG4gICAgdGhpcy5kaXNwYXRjaC5lbWl0KHR5cGUgfHwgZS50eXBlLCBlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZ2l2ZW4gdXBzdHJlYW0gZXZlbnQgdGhyb3VnaCB0aGUgZXZlbnQgYm91bmRhcnkgYW5kIHByb3BhZ2F0ZXMgaXQgZG93bnN0cmVhbS5cbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gbWFwLlxuICAgKi9cbiAgbWFwRXZlbnQoZSkge1xuICAgIGlmICghdGhpcy5yb290VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlcnMgPSB0aGlzLm1hcHBpbmdUYWJsZVtlLnR5cGVdO1xuICAgIGlmIChtYXBwZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG1hcHBlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIG1hcHBlcnNbaV0uZm4oZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oYFtFdmVudEJvdW5kYXJ5XTogRXZlbnQgbWFwcGluZyBub3QgZGVmaW5lZCBmb3IgJHtlLnR5cGV9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgQ29udGFpbmVyIHRoYXQgaXMgdGhlIHRhcmdldCBvZiBhIGV2ZW50IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICpcbiAgICogVGhlIHBhc3NlZCAoeCx5KSBjb29yZGluYXRlcyBhcmUgaW4gdGhlIHdvcmxkIHNwYWNlIGFib3ZlIHRoaXMgZXZlbnQgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBoaXRUZXN0KHgsIHkpIHtcbiAgICBFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IHVzZU1vdmUgPSB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgJiYgdGhpcy5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzO1xuICAgIGNvbnN0IGZuID0gdXNlTW92ZSA/IFwiaGl0VGVzdE1vdmVSZWN1cnNpdmVcIiA6IFwiaGl0VGVzdFJlY3Vyc2l2ZVwiO1xuICAgIGNvbnN0IGludmVydGVkUGF0aCA9IHRoaXNbZm5dKFxuICAgICAgdGhpcy5yb290VGFyZ2V0LFxuICAgICAgdGhpcy5yb290VGFyZ2V0LmV2ZW50TW9kZSxcbiAgICAgIHRlbXBIaXRMb2NhdGlvbi5zZXQoeCwgeSksXG4gICAgICB0aGlzLmhpdFRlc3RGbixcbiAgICAgIHRoaXMuaGl0UHJ1bmVGblxuICAgICk7XG4gICAgcmV0dXJuIGludmVydGVkUGF0aCAmJiBpbnZlcnRlZFBhdGhbMF07XG4gIH1cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZSB0aGUgcGFzc2VkIGV2ZW50IGZyb20gZnJvbSB7QGxpbmsgRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0gdG8gaXRzXG4gICAqIHRhcmdldCBgZS50YXJnZXRgLlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCB0byBwcm9wYWdhdGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gcHJvcGFnYXRlLiBEZWZhdWx0cyB0byBgZS50eXBlYC5cbiAgICovXG4gIHByb3BhZ2F0ZShlLCB0eXBlKSB7XG4gICAgaWYgKCFlLnRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb21wb3NlZFBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQ0FQVFVSSU5HX1BIQVNFO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyspIHtcbiAgICAgIGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXTtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5ldmVudFBoYXNlID0gZS5BVF9UQVJHRVQ7XG4gICAgZS5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICByZXR1cm47XG4gICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgZXZlbnQgYGVgIHRvIGFsbCBpbnRlcmFjdGl2ZSBjb250YWluZXJzLiBUaGUgZXZlbnQgaXMgcHJvcGFnYXRlZCBpbiB0aGUgYnViYmxpbmcgcGhhc2UgYWx3YXlzLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIGBnbG9iYWxwb2ludGVybW92ZWAgZXZlbnQuXG4gICAqIEBwYXJhbSBlIC0gVGhlIGVtaXR0ZWQgZXZlbnQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIGxpc3RlbmVycyB0byBub3RpZnkuXG4gICAqIEBwYXJhbSB0YXJnZXRzIC0gVGhlIHRhcmdldHMgdG8gbm90aWZ5LlxuICAgKi9cbiAgYWxsKGUsIHR5cGUsIHRhcmdldHMgPSB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQlVCQkxJTkdfUEhBU0U7XG4gICAgY29uc3QgZXZlbnRzID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBwcm9wYWdhdGlvbiBwYXRoIGZyb20ge0BsaW5rIEV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fSB0byB0aGUgcGFzc2VkXG4gICAqIGB0YXJnZXRgLiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIGB0YXJnZXRgLlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiBwYXRoIHRvLlxuICAgKi9cbiAgcHJvcGFnYXRpb25QYXRoKHRhcmdldCkge1xuICAgIGNvbnN0IHByb3BhZ2F0aW9uUGF0aCA9IFt0YXJnZXRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPUEFHQVRJT05fTElNSVQgJiYgKHRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0ICYmIHRhcmdldC5wYXJlbnQpOyBpKyspIHtcbiAgICAgIGlmICghdGFyZ2V0LnBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBwcm9wYWdhdGlvbiBwYXRoIHRvIGRpc2Nvbm5lY3RlZCB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICBwcm9wYWdhdGlvblBhdGgucHVzaCh0YXJnZXQucGFyZW50KTtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgfVxuICAgIHByb3BhZ2F0aW9uUGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uUGF0aDtcbiAgfVxuICBoaXRUZXN0TW92ZVJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4sIGlnbm9yZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNob3VsZFJldHVybiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZVBydW5lKGN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICBFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0TW92ZVJlY3Vyc2l2ZShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSkgPyBldmVudE1vZGUgOiBjaGlsZC5ldmVudE1vZGUsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgdGVzdEZuLFxuICAgICAgICAgIHBydW5lRm4sXG4gICAgICAgICAgaWdub3JlIHx8IHBydW5lRm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXN0ZWRIaXQpIHtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgJiYgIW5lc3RlZEhpdFtuZXN0ZWRIaXQubGVuZ3RoIC0gMV0ucGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZSA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgICAgICAgIGlmIChuZXN0ZWRIaXQubGVuZ3RoID4gMCB8fCBpc0ludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgbmVzdGVkSGl0LnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aGlzLl9oaXRFbGVtZW50cyA9IG5lc3RlZEhpdDtcbiAgICAgICAgICBzaG91bGRSZXR1cm4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVNb2RlID0gdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpO1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZVRhcmdldCAmJiBpc0ludGVyYWN0aXZlVGFyZ2V0KVxuICAgICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgIGlmIChpZ25vcmUgfHwgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChzaG91bGRSZXR1cm4pXG4gICAgICByZXR1cm4gdGhpcy5faGl0RWxlbWVudHM7XG4gICAgaWYgKGlzSW50ZXJhY3RpdmVNb2RlICYmICghcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkpIHtcbiAgICAgIHJldHVybiBpc0ludGVyYWN0aXZlVGFyZ2V0ID8gW2N1cnJlbnRUYXJnZXRdIDogW107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBFdmVudEJvdW5kYXJ5LmhpdFRlc3QgaGl0VGVzdH0uXG4gICAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IC0gVGhlIENvbnRhaW5lciB0aGF0IGlzIHRvIGJlIGhpdCB0ZXN0ZWQuXG4gICAqIEBwYXJhbSBldmVudE1vZGUgLSBUaGUgZXZlbnQgbW9kZSBmb3IgdGhlIGBjdXJyZW50VGFyZ2V0YCBvciBvbmUgb2YgaXRzIHBhcmVudHMuXG4gICAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0aGF0IGlzIGJlaW5nIHRlc3RlZCBmb3Igb3ZlcmxhcC5cbiAgICogQHBhcmFtIHRlc3RGbiAtIENhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0YXJnZXQgcGFzc2VzIGhpdCB0ZXN0aW5nLiBUaGlzIGNhbGxiYWNrXG4gICAqICBjYW4gYXNzdW1lIHRoYXQgYHBydW5lRm5gIGZhaWxlZCB0byBwcnVuZSB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gcHJ1bmVGbiAtIENhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lc3Mgd2hldGhlciB0aGUgdGFyZ2V0IGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuXG4gICAqICBjYW5ub3QgcGFzcyB0aGUgaGl0IHRlc3QuIEl0IGlzIHVzZWQgYXMgYSBwcmVsaW1pbmFyeSBvcHRpbWl6YXRpb24gdG8gcHJ1bmUgZW50aXJlIHN1YnRyZWVzXG4gICAqICBvZiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IGhvbGRpbmcgdGhlIGhpdCB0ZXN0aW5nIHRhcmdldCBhbmQgYWxsIGl0cyBhbmNlc3RvcnMgaW4gb3JkZXIuIFRoZSBmaXJzdCBlbGVtZW50XG4gICAqICBpcyB0aGUgdGFyZ2V0IGl0c2VsZiBhbmQgdGhlIGxhc3QgaXMge0BsaW5rIEV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fS4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICogIG9yZGVyIHcuci50LiB0aGUgcHJvcGFnYXRpb24gcGF0aC4gSWYgbm8gaGl0IHRlc3RpbmcgdGFyZ2V0IGlzIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKi9cbiAgaGl0VGVzdFJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgY29uc3QgcmVsYXRpdmVMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdFJlY3Vyc2l2ZShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSkgPyBldmVudE1vZGUgOiBjaGlsZC5ldmVudE1vZGUsXG4gICAgICAgICAgcmVsYXRpdmVMb2NhdGlvbixcbiAgICAgICAgICB0ZXN0Rm4sXG4gICAgICAgICAgcHJ1bmVGblxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIHJldHVybiBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSk7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIGlmIChpc0ludGVyYWN0aXZlTW9kZSAmJiB0ZXN0Rm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKSB7XG4gICAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZVRhcmdldCA/IFtjdXJyZW50VGFyZ2V0XSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaXNJbnRlcmFjdGl2ZShpbnQpIHtcbiAgICByZXR1cm4gaW50ID09PSBcInN0YXRpY1wiIHx8IGludCA9PT0gXCJkeW5hbWljXCI7XG4gIH1cbiAgX2ludGVyYWN0aXZlUHJ1bmUoY29udGFpbmVyKSB7XG4gICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci52aXNpYmxlIHx8ICFjb250YWluZXIucmVuZGVyYWJsZSB8fCAhY29udGFpbmVyLm1lYXN1cmFibGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmV2ZW50TW9kZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmV2ZW50TW9kZSA9PT0gXCJwYXNzaXZlXCIgJiYgIWNvbnRhaW5lci5pbnRlcmFjdGl2ZUNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgY29udGFpbmVyIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4gY2Fubm90IHBhc3MgdGhlIGhpdCB0ZXN0IGF0IGFsbC5cbiAgICpcbiAgICoge0BsaW5rIEV2ZW50Qm91bmRhcnl9J3MgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUge0BsaW5rIENvbnRhaW5lci5oaXRBcmVhIGhpdEFyZWF9XG4gICAqIGFuZCB7QGxpbmsgQ29udGFpbmVyLl9tYXNrRWZmZWN0fSBmb3IgcHJ1bmluZy5cbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcHJ1bmUuXG4gICAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byB0ZXN0IGZvciBvdmVybGFwLlxuICAgKi9cbiAgaGl0UHJ1bmVGbihjb250YWluZXIsIGxvY2F0aW9uKSB7XG4gICAgaWYgKGNvbnRhaW5lci5oaXRBcmVhKSB7XG4gICAgICBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGxvY2F0aW9uLCB0ZW1wTG9jYWxNYXBwaW5nKTtcbiAgICAgIGlmICghY29udGFpbmVyLmhpdEFyZWEuY29udGFpbnModGVtcExvY2FsTWFwcGluZy54LCB0ZW1wTG9jYWxNYXBwaW5nLnkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmVmZmVjdHMgJiYgY29udGFpbmVyLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lci5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGNvbnRhaW5lci5lZmZlY3RzW2ldO1xuICAgICAgICBpZiAoZWZmZWN0LmNvbnRhaW5zUG9pbnQpIHtcbiAgICAgICAgICBjb25zdCBlZmZlY3RDb250YWluc1BvaW50ID0gZWZmZWN0LmNvbnRhaW5zUG9pbnQobG9jYXRpb24sIHRoaXMuaGl0VGVzdEZuKTtcbiAgICAgICAgICBpZiAoIWVmZmVjdENvbnRhaW5zUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjb250YWluZXIgcGFzc2VzIGhpdCB0ZXN0aW5nIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHRlc3QuXG4gICAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byB0ZXN0IGZvciBvdmVybGFwLlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgYGNvbnRhaW5lcmAgcGFzc2VzIGhpdCB0ZXN0aW5nIGZvciBgbG9jYXRpb25gLlxuICAgKi9cbiAgaGl0VGVzdEZuKGNvbnRhaW5lciwgbG9jYXRpb24pIHtcbiAgICBpZiAoY29udGFpbmVyLmhpdEFyZWEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyPy5jb250YWluc1BvaW50KSB7XG4gICAgICBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGxvY2F0aW9uLCB0ZW1wTG9jYWxNYXBwaW5nKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnNQb2ludCh0ZW1wTG9jYWxNYXBwaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBOb3RpZnkgYWxsIHRoZSBsaXN0ZW5lcnMgdG8gdGhlIGV2ZW50J3MgYGN1cnJlbnRUYXJnZXRgLlxuICAgKlxuICAgKiBJZiB0aGUgYGN1cnJlbnRUYXJnZXRgIGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgb248dHlwZT5gLCB0aGVuIGl0IGlzIGNhbGxlZCBoZXJlLFxuICAgKiBzaW11bGF0aW5nIHRoZSBiZWhhdmlvciBmcm9tIHZlcnNpb24gNi54IGFuZCBwcmlvci5cbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgcGFzc2VkIHRvIHRoZSB0YXJnZXQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gbm90aWZ5LiBEZWZhdWx0cyB0byBgZS50eXBlYC5cbiAgICovXG4gIG5vdGlmeVRhcmdldChlLCB0eXBlKSB7XG4gICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHR5cGUgPz8gKHR5cGUgPSBlLnR5cGUpO1xuICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBgb24ke3R5cGV9YDtcbiAgICBlLmN1cnJlbnRUYXJnZXRbaGFuZGxlcktleV0/LihlKTtcbiAgICBjb25zdCBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBgJHt0eXBlfWNhcHR1cmVgIDogdHlwZTtcbiAgICB0aGlzLl9ub3RpZnlMaXN0ZW5lcnMoZSwga2V5KTtcbiAgICBpZiAoZS5ldmVudFBoYXNlID09PSBlLkFUX1RBUkdFVCkge1xuICAgICAgdGhpcy5fbm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJkb3duYCBldmVudHMgdG8gYSBkb3duc3RyZWFtIGBwb2ludGVyZG93bmAgZXZlbnQuXG4gICAqXG4gICAqIGB0b3VjaHN0YXJ0YCwgYHJpZ2h0ZG93bmAsIGBtb3VzZWRvd25gIGV2ZW50cyBhcmUgYWxzbyBkaXNwYXRjaGVkIGZvciBzcGVjaWZpYyBwb2ludGVyIHR5cGVzLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcmRvd25gIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlckRvd24oZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcmRvd25cIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hzdGFydFwiKTtcbiAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRkb3duXCIgOiBcIm1vdXNlZG93blwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm1vdmVgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdXRgLCBgcG9pbnRlcm92ZXJgLCBhbmQgYHBvaW50ZXJtb3ZlYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBoYXMgYW4gdXBkYXRlZCBgb3ZlclRhcmdldGAuIGBtb3VzZW91dGAsIGBtb3VzZW92ZXJgLFxuICAgKiBgbW91c2Vtb3ZlYCwgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlciB0eXBlcy5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJNb3ZlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gZmFsc2U7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cz8ubGVuZ3RoID4gMCAmJiBvdXRUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICBjb25zdCBvdXRUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW91dFwiIDogXCJwb2ludGVyb3V0XCI7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIG91dFR5cGUsIG91dFRhcmdldCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwicG9pbnRlcm91dFwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBpZiAoIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMob3V0VGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgICAgbGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhsZWF2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW92ZXJcIiA6IFwicG9pbnRlcm92ZXJcIjtcbiAgICAgIGNvbnN0IG92ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgb3ZlclR5cGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG92ZXJFdmVudCwgXCJwb2ludGVyb3ZlclwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIGxldCBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdXRUYXJnZXQ/LnBhcmVudDtcbiAgICAgIHdoaWxlIChvdmVyVGFyZ2V0QW5jZXN0b3IgJiYgb3ZlclRhcmdldEFuY2VzdG9yICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGlmIChvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IGUudGFyZ2V0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdmVyVGFyZ2V0QW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGlkUG9pbnRlckVudGVyID0gIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7XG4gICAgICBpZiAoZGlkUG9pbnRlckVudGVyKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgICAgICBlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDtcbiAgICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgICAgICBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG92ZXJFdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGhvZHMgPSBbXTtcbiAgICBjb25zdCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgPSB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPz8gdHJ1ZTtcbiAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMucHVzaChcInBvaW50ZXJtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm1vdmVcIik7XG4gICAgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbHBvaW50ZXJtb3ZlXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5zcGxpY2UoMSwgMCwgXCJ0b3VjaG1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJ0b3VjaG1vdmVcIik7XG4gICAgICBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFsdG91Y2htb3ZlXCIpO1xuICAgIH1cbiAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcIm1vdXNlbW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlbW92ZVwiKTtcbiAgICAgIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxtb3VzZW1vdmVcIik7XG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgfVxuICAgIGlmIChhbGxNZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWxsKGUsIGFsbE1ldGhvZHMpO1xuICAgIH1cbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm92ZXJgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdmVyYCBhbmQgYHBvaW50ZXJlbnRlcmAgZXZlbnRzLCBpbiB0aGF0IG9yZGVyLlxuICAgKlxuICAgKiBUaGUgdHJhY2tpbmcgZGF0YSBmb3IgdGhlIHNwZWNpZmljIHBvaW50ZXIgZ2V0cyBhIG5ldyBgb3ZlclRhcmdldGAuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVyb3ZlcmAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyT3Zlcihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHdhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJvdmVyXCIpO1xuICAgIGlmIChpc01vdXNlKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2VvdmVyXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpXG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgZW50ZXJFdmVudC5ldmVudFBoYXNlID0gZW50ZXJFdmVudC5BVF9UQVJHRVQ7XG4gICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpO1xuICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm91dGAgdG8gZG93bnN0cmVhbSBgcG9pbnRlcm91dGAsIGBwb2ludGVybGVhdmVgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGlzIGNsZWFyZWQgb2YgYSBgb3ZlclRhcmdldGAuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVyb3V0YCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJPdXQoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cykge1xuICAgICAgY29uc3QgaXNNb3VzZSA9IGZyb20ucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBmcm9tLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgICAgY29uc3Qgb3V0VGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpO1xuICAgICAgY29uc3Qgb3V0RXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBcInBvaW50ZXJvdXRcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCk7XG4gICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50LCBcIm1vdXNlb3V0XCIpO1xuICAgICAgY29uc3QgbGVhdmVFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcmxlYXZlXCIsIG91dFRhcmdldCk7XG4gICAgICBsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDtcbiAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiBsZWF2ZUV2ZW50LnRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCkge1xuICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCk7XG4gICAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBudWxsO1xuICAgICAgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgICAgdGhpcy5mcmVlRXZlbnQobGVhdmVFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJ1cGAgZXZlbnQgdG8gZG93bnN0cmVhbSBgcG9pbnRlcnVwYCwgYHBvaW50ZXJ1cG91dHNpZGVgLFxuICAgKiBhbmQgYGNsaWNrYC9gcmlnaHRjbGlja2AvYHBvaW50ZXJ0YXBgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIGBwb2ludGVydXBvdXRzaWRlYCBldmVudCBidWJibGVzIGZyb20gdGhlIG9yaWdpbmFsIGBwb2ludGVyZG93bmAgdGFyZ2V0IHRvIHRoZSBtb3N0IHNwZWNpZmljXG4gICAqIGFuY2VzdG9yIG9mIHRoZSBgcG9pbnRlcmRvd25gIGFuZCBgcG9pbnRlcnVwYCB0YXJnZXRzLCB3aGljaCBpcyBhbHNvIHRoZSBgY2xpY2tgIGV2ZW50J3MgdGFyZ2V0LiBgdG91Y2hlbmRgLFxuICAgKiBgcmlnaHR1cGAsIGBtb3VzZXVwYCwgYHRvdWNoZW5kb3V0c2lkZWAsIGByaWdodHVwb3V0c2lkZWAsIGBtb3VzZXVwb3V0c2lkZWAsIGFuZCBgdGFwYCBhcmUgZmlyZWQgYXMgd2VsbCBmb3JcbiAgICogc3BlY2lmaWMgcG9pbnRlciB0eXBlcy5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJ1cGAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyVXAoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcnVwXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNoZW5kXCIpO1xuICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodHVwXCIgOiBcIm1vdXNldXBcIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBwcmVzc1RhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSk7XG4gICAgbGV0IGNsaWNrVGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgaWYgKHByZXNzVGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHByZXNzVGFyZ2V0KSkge1xuICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICAgIHdoaWxlIChjdXJyZW50VGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwicG9pbnRlcnVwb3V0c2lkZVwiKTtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwidG91Y2hlbmRvdXRzaWRlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0dXBvdXRzaWRlXCIgOiBcIm1vdXNldXBvdXRzaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgICAgY2xpY2tUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoY2xpY2tUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGNsaWNrRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwiY2xpY2tcIik7XG4gICAgICBjbGlja0V2ZW50LnRhcmdldCA9IGNsaWNrVGFyZ2V0O1xuICAgICAgY2xpY2tFdmVudC5wYXRoID0gbnVsbDtcbiAgICAgIGlmICghdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSkge1xuICAgICAgICB0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dID0ge1xuICAgICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgICAgdGFyZ2V0OiBjbGlja0V2ZW50LnRhcmdldCxcbiAgICAgICAgICB0aW1lU3RhbXA6IG5vd1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY2xpY2tIaXN0b3J5ID0gdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICAgIGlmIChjbGlja0hpc3RvcnkudGFyZ2V0ID09PSBjbGlja0V2ZW50LnRhcmdldCAmJiBub3cgLSBjbGlja0hpc3RvcnkudGltZVN0YW1wIDwgMjAwKSB7XG4gICAgICAgICsrY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlja0hpc3RvcnkuY2xpY2tDb3VudCA9IDE7XG4gICAgICB9XG4gICAgICBjbGlja0hpc3RvcnkudGFyZ2V0ID0gY2xpY2tFdmVudC50YXJnZXQ7XG4gICAgICBjbGlja0hpc3RvcnkudGltZVN0YW1wID0gbm93O1xuICAgICAgY2xpY2tFdmVudC5kZXRhaWwgPSBjbGlja0hpc3RvcnkuY2xpY2tDb3VudDtcbiAgICAgIGlmIChjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGNsaWNrRXZlbnQuYnV0dG9uID09PSAyO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRjbGlja1wiIDogXCJjbGlja1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInRhcFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInBvaW50ZXJ0YXBcIik7XG4gICAgICB0aGlzLmZyZWVFdmVudChjbGlja0V2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5mcmVlRXZlbnQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIHVwc3RyZWFtIGBwb2ludGVydXBvdXRzaWRlYCBldmVudCB0byBhIGRvd25zdHJlYW0gYHBvaW50ZXJ1cG91dHNpZGVgIGV2ZW50LCBidWJibGluZyBmcm9tIHRoZSBvcmlnaW5hbFxuICAgKiBgcG9pbnRlcmRvd25gIHRhcmdldCB0byBgcm9vdFRhcmdldGAuXG4gICAqXG4gICAqIChUaGUgbW9zdCBzcGVjaWZpYyBhbmNlc3RvciBvZiB0aGUgYHBvaW50ZXJkb3duYCBldmVudCBhbmQgdGhlIGBwb2ludGVydXBgIGV2ZW50IG11c3QgdGhlXG4gICAqIGB7QGxpbmsgRXZlbnRCb3VuZGFyeX0ncyByb290IGJlY2F1c2UgdGhlIGBwb2ludGVydXBgIGV2ZW50IG9jY3VycmVkIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJ5LilcbiAgICpcbiAgICogYHRvdWNoZW5kb3V0c2lkZWAsIGBtb3VzZXVwb3V0c2lkZWAsIGFuZCBgcmlnaHR1cG91dHNpZGVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlclxuICAgKiB0eXBlcy4gVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGlzIGNsZWFyZWQgb2YgYSBgcHJlc3NUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyVXBPdXRzaWRlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgaWYgKHByZXNzVGFyZ2V0KSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBlLmJ1dHRvbiA9PT0gMiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgfVxuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgd2hlZWxgIGV2ZW50IHRvIGEgZG93bnN0cmVhbSBgd2hlZWxgIGV2ZW50LlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgd2hlZWxgIGV2ZW50LlxuICAgKi9cbiAgbWFwV2hlZWwoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRXaGVlbEV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi13aGVlbCBldmVudCBhcyBhIHdoZWVsIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aGVlbEV2ZW50ID0gdGhpcy5jcmVhdGVXaGVlbEV2ZW50KGZyb20pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh3aGVlbEV2ZW50KTtcbiAgICB0aGlzLmZyZWVFdmVudCh3aGVlbEV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIG1vc3Qgc3BlY2lmaWMgZXZlbnQtdGFyZ2V0IGluIHRoZSBnaXZlbiBwcm9wYWdhdGlvbiBwYXRoIHRoYXQgaXMgc3RpbGwgbW91bnRlZCBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IGBwb2ludGVydXBgIGFuZCBgcG9pbnRlcm91dGAgdGFyZ2V0IGluIHRoZSBjYXNlIHRoYXQgdGhlIG9yaWdpbmFsIGBwb2ludGVyZG93bmBcbiAgICogb3IgYHBvaW50ZXJvdmVyYCB0YXJnZXQgd2FzIHVubW91bnRlZCBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAgICogQHBhcmFtIHByb3BhZ2F0aW9uUGF0aCAtIFRoZSBwcm9wYWdhdGlvbiBwYXRoIHdhcyB2YWxpZCBpbiB0aGUgcGFzdC5cbiAgICogQHJldHVybnMgLSBUaGUgbW9zdCBzcGVjaWZpYyBldmVudC10YXJnZXQgc3RpbGwgbW91bnRlZCBhdCB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqL1xuICBmaW5kTW91bnRlZFRhcmdldChwcm9wYWdhdGlvblBhdGgpIHtcbiAgICBpZiAoIXByb3BhZ2F0aW9uUGF0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcGFnYXRpb25QYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcGFnYXRpb25QYXRoW2ldLnBhcmVudCA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV2ZW50IHdob3NlIGBvcmlnaW5hbEV2ZW50YCBpcyBgZnJvbWAsIHdpdGggYW4gb3B0aW9uYWwgYHR5cGVgIGFuZCBgdGFyZ2V0YCBvdmVycmlkZS5cbiAgICpcbiAgICogVGhlIGV2ZW50IGlzIGFsbG9jYXRlZCB1c2luZyB7QGxpbmsgRXZlbnRCb3VuZGFyeSNhbGxvY2F0ZUV2ZW50IHRoaXMuYWxsb2NhdGVFdmVudH0uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIGBvcmlnaW5hbEV2ZW50YCBmb3IgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gW3R5cGU9ZnJvbS50eXBlXSAtIFRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBldmVudC5cbiAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHR5cGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldCA/PyB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSA/PyB0aGlzLl9oaXRFbGVtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3aGVlbCBldmVudCB3aG9zZSBgb3JpZ2luYWxFdmVudGAgaXMgYGZyb21gLlxuICAgKlxuICAgKiBUaGUgZXZlbnQgaXMgYWxsb2NhdGVkIHVzaW5nIHtAbGluayBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gd2hlZWwgZXZlbnQuXG4gICAqL1xuICBjcmVhdGVXaGVlbEV2ZW50KGZyb20pIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuYWxsb2NhdGVFdmVudChGZWRlcmF0ZWRXaGVlbEV2ZW50KTtcbiAgICB0aGlzLmNvcHlXaGVlbERhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRoaXMuaGl0VGVzdChldmVudC5nbG9iYWwueCwgZXZlbnQuZ2xvYmFsLnkpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBldmVudCBgZnJvbWAsIHdpdGggYW4gb3B0aW9uYWwgYHR5cGVgIG92ZXJyaWRlLlxuICAgKlxuICAgKiBUaGUgZXZlbnQgaXMgYWxsb2NhdGVkIHVzaW5nIHtAbGluayBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgZXZlbnQgdG8gY2xvbmUuXG4gICAqIEBwYXJhbSBbdHlwZT1mcm9tLnR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY2xvbmVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tLm9yaWdpbmFsRXZlbnQ7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQudGFyZ2V0ID0gZnJvbS50YXJnZXQ7XG4gICAgZXZlbnQucGF0aCA9IGZyb20uY29tcG9zZWRQYXRoKCkuc2xpY2UoKTtcbiAgICBldmVudC50eXBlID0gdHlwZSA/PyBldmVudC50eXBlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHdoZWVsIHtAbGluayBGZWRlcmF0ZWRXaGVlbEV2ZW50fSBkYXRhIGZyb20gYGZyb21gIGludG8gYHRvYC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQ6XG4gICAqICsgZGVsdGFNb2RlXG4gICAqICsgZGVsdGFYXG4gICAqICsgZGVsdGFZXG4gICAqICsgZGVsdGFaXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZXZlbnQgdG8gY29weSBkYXRhIGludG8uXG4gICAqL1xuICBjb3B5V2hlZWxEYXRhKGZyb20sIHRvKSB7XG4gICAgdG8uZGVsdGFNb2RlID0gZnJvbS5kZWx0YU1vZGU7XG4gICAgdG8uZGVsdGFYID0gZnJvbS5kZWx0YVg7XG4gICAgdG8uZGVsdGFZID0gZnJvbS5kZWx0YVk7XG4gICAgdG8uZGVsdGFaID0gZnJvbS5kZWx0YVo7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBwb2ludGVyIHtAbGluayBGZWRlcmF0ZWRQb2ludGVyRXZlbnR9IGRhdGEgZnJvbSBgZnJvbWAgaW50byBgdG9gLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBwb2ludGVySWRcbiAgICogKyB3aWR0aFxuICAgKiArIGhlaWdodFxuICAgKiArIGlzUHJpbWFyeVxuICAgKiArIHBvaW50ZXJUeXBlXG4gICAqICsgcHJlc3N1cmVcbiAgICogKyB0YW5nZW50aWFsUHJlc3N1cmVcbiAgICogKyB0aWx0WFxuICAgKiArIHRpbHRZXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZXZlbnQgdG8gY29weSBkYXRhIGludG8uXG4gICAqL1xuICBjb3B5UG9pbnRlckRhdGEoZnJvbSwgdG8pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSlcbiAgICAgIHJldHVybjtcbiAgICB0by5wb2ludGVySWQgPSBmcm9tLnBvaW50ZXJJZDtcbiAgICB0by53aWR0aCA9IGZyb20ud2lkdGg7XG4gICAgdG8uaGVpZ2h0ID0gZnJvbS5oZWlnaHQ7XG4gICAgdG8uaXNQcmltYXJ5ID0gZnJvbS5pc1ByaW1hcnk7XG4gICAgdG8ucG9pbnRlclR5cGUgPSBmcm9tLnBvaW50ZXJUeXBlO1xuICAgIHRvLnByZXNzdXJlID0gZnJvbS5wcmVzc3VyZTtcbiAgICB0by50YW5nZW50aWFsUHJlc3N1cmUgPSBmcm9tLnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICB0by50aWx0WCA9IGZyb20udGlsdFg7XG4gICAgdG8udGlsdFkgPSBmcm9tLnRpbHRZO1xuICAgIHRvLnR3aXN0ID0gZnJvbS50d2lzdDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIG1vdXNlIHtAbGluayBGZWRlcmF0ZWRNb3VzZUV2ZW50fSBkYXRhIGZyb20gYGZyb21gIHRvIGB0b2AuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgY29waWVkOlxuICAgKiArIGFsdEtleVxuICAgKiArIGJ1dHRvblxuICAgKiArIGJ1dHRvbnNcbiAgICogKyBjbGllbnRYXG4gICAqICsgY2xpZW50WVxuICAgKiArIG1ldGFLZXlcbiAgICogKyBtb3ZlbWVudFhcbiAgICogKyBtb3ZlbWVudFlcbiAgICogKyBwYWdlWFxuICAgKiArIHBhZ2VZXG4gICAqICsgeFxuICAgKiArIHlcbiAgICogKyBzY3JlZW5cbiAgICogKyBzaGlmdEtleVxuICAgKiArIGdsb2JhbFxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weU1vdXNlRGF0YShmcm9tLCB0bykge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkTW91c2VFdmVudCkpXG4gICAgICByZXR1cm47XG4gICAgdG8uYWx0S2V5ID0gZnJvbS5hbHRLZXk7XG4gICAgdG8uYnV0dG9uID0gZnJvbS5idXR0b247XG4gICAgdG8uYnV0dG9ucyA9IGZyb20uYnV0dG9ucztcbiAgICB0by5jbGllbnQuY29weUZyb20oZnJvbS5jbGllbnQpO1xuICAgIHRvLmN0cmxLZXkgPSBmcm9tLmN0cmxLZXk7XG4gICAgdG8ubWV0YUtleSA9IGZyb20ubWV0YUtleTtcbiAgICB0by5tb3ZlbWVudC5jb3B5RnJvbShmcm9tLm1vdmVtZW50KTtcbiAgICB0by5zY3JlZW4uY29weUZyb20oZnJvbS5zY3JlZW4pO1xuICAgIHRvLnNoaWZ0S2V5ID0gZnJvbS5zaGlmdEtleTtcbiAgICB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYmFzZSB7QGxpbmsgRmVkZXJhdGVkRXZlbnR9IGRhdGEgZnJvbSBgZnJvbWAgaW50byBgdG9gLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBpc1RydXN0ZWRcbiAgICogKyBzcmNFbGVtZW50XG4gICAqICsgdGltZVN0YW1wXG4gICAqICsgdHlwZVxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5pc1RydXN0ZWQgPSBmcm9tLmlzVHJ1c3RlZDtcbiAgICB0by5zcmNFbGVtZW50ID0gZnJvbS5zcmNFbGVtZW50O1xuICAgIHRvLnRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRvLnR5cGUgPSBmcm9tLnR5cGU7XG4gICAgdG8uZGV0YWlsID0gZnJvbS5kZXRhaWw7XG4gICAgdG8udmlldyA9IGZyb20udmlldztcbiAgICB0by53aGljaCA9IGZyb20ud2hpY2g7XG4gICAgdG8ubGF5ZXIuY29weUZyb20oZnJvbS5sYXllcik7XG4gICAgdG8ucGFnZS5jb3B5RnJvbShmcm9tLnBhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgcG9pbnRlciBJRC5cbiAgICogQHJldHVybnMgVGhlIHRyYWNraW5nIGRhdGEgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlci4gSWYgbm8gZGF0YSBleGlzdHMsIGEgYmxhbmtcbiAgICogIHN0YXRlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRyYWNraW5nRGF0YShpZCkge1xuICAgIGlmICghdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSkge1xuICAgICAgdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSA9IHtcbiAgICAgICAgcHJlc3NUYXJnZXRzQnlCdXR0b246IHt9LFxuICAgICAgICBjbGlja3NCeUJ1dHRvbjoge30sXG4gICAgICAgIG92ZXJUYXJnZXQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBhIHNwZWNpZmljIHR5cGUgb2YgZXZlbnQgZnJvbSB7QGxpbmsgRXZlbnRCb3VuZGFyeSNldmVudFBvb2wgdGhpcy5ldmVudFBvb2x9LlxuICAgKlxuICAgKiBUaGlzIGFsbG9jYXRpb24gaXMgY29uc3RydWN0b3ItYWdub3N0aWMsIGFzIGxvbmcgYXMgaXQgb25seSB0YWtlcyBvbmUgYXJndW1lbnQgLSB0aGlzIGV2ZW50XG4gICAqIGJvdW5kYXJ5LlxuICAgKiBAcGFyYW0gY29uc3RydWN0b3IgLSBUaGUgZXZlbnQncyBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybnMgQW4gZXZlbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqL1xuICBhbGxvY2F0ZUV2ZW50KGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50UG9vbC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmV2ZW50UG9vbC5nZXQoY29uc3RydWN0b3IpLnBvcCgpIHx8IG5ldyBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICBldmVudC5ldmVudFBoYXNlID0gZXZlbnQuTk9ORTtcbiAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgZXZlbnQucGF0aCA9IG51bGw7XG4gICAgZXZlbnQudGFyZ2V0ID0gbnVsbDtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEZyZWVzIHRoZSBldmVudCBhbmQgcHV0cyBpdCBiYWNrIGludG8gdGhlIGV2ZW50IHBvb2wuXG4gICAqXG4gICAqIEl0IGlzIGlsbGVnYWwgdG8gcmV1c2UgdGhlIGV2ZW50IHVudGlsIGl0IGlzIGFsbG9jYXRlZCBhZ2FpbiwgdXNpbmcgYHRoaXMuYWxsb2NhdGVFdmVudGAuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gYWR2aXNlZCB0aGF0IGV2ZW50cyBub3QgYWxsb2NhdGVkIGZyb20ge0BsaW5rIEV2ZW50Qm91bmRhcnkjYWxsb2NhdGVFdmVudCB0aGlzLmFsbG9jYXRlRXZlbnR9XG4gICAqIG5vdCBiZSBmcmVlZC4gVGhpcyBpcyBiZWNhdXNlIG9mIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSBzYW1lIGV2ZW50IGlzIGZyZWVkIHR3aWNlLCB3aGljaCBjYW4gY2F1c2VcbiAgICogaXQgdG8gYmUgYWxsb2NhdGVkIHR3aWNlICYgcmVzdWx0IGluIG92ZXJ3cml0aW5nLlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gYmUgZnJlZWQuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGV2ZW50IGlzIG1hbmFnZWQgYnkgYW5vdGhlciBldmVudCBib3VuZGFyeS5cbiAgICovXG4gIGZyZWVFdmVudChldmVudCkge1xuICAgIGlmIChldmVudC5tYW5hZ2VyICE9PSB0aGlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgaXMgaWxsZWdhbCB0byBmcmVlIGFuIGV2ZW50IG5vdCBtYW5hZ2VkIGJ5IHRoaXMgRXZlbnRCb3VuZGFyeSFcIik7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBldmVudC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIXRoaXMuZXZlbnRQb29sLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRoaXMuZXZlbnRQb29sLnNldChjb25zdHJ1Y3RvciwgW10pO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50UG9vbC5nZXQoY29uc3RydWN0b3IpLnB1c2goZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBFdmVudEVtaXR0ZXIuZW1pdH0sIGV4Y2VwdCBpdCBzdG9wcyBpZiB0aGUgYHByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkYCBmbGFnXG4gICAqIGlzIHNldCBvbiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50IHRvIGNhbGwgZWFjaCBsaXN0ZW5lciB3aXRoLlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBldmVudCBrZXkuXG4gICAqL1xuICBfbm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBlLmN1cnJlbnRUYXJnZXQuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoXCJmblwiIGluIGxpc3RlbmVycykge1xuICAgICAgaWYgKGxpc3RlbmVycy5vbmNlKVxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzLmZuLCB2b2lkIDAsIHRydWUpO1xuICAgICAgbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBqICYmICFlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKVxuICAgICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0uZm4sIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRXZlbnRCb3VuZGFyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRCb3VuZGFyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9FdmVudEJvdW5kYXJ5Lm1qcyc7XG5pbXBvcnQgeyBFdmVudHNUaWNrZXIgfSBmcm9tICcuL0V2ZW50VGlja2VyLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IE1PVVNFX1BPSU5URVJfSUQgPSAxO1xuY29uc3QgVE9VQ0hfVE9fUE9JTlRFUiA9IHtcbiAgdG91Y2hzdGFydDogXCJwb2ludGVyZG93blwiLFxuICB0b3VjaGVuZDogXCJwb2ludGVydXBcIixcbiAgdG91Y2hlbmRvdXRzaWRlOiBcInBvaW50ZXJ1cG91dHNpZGVcIixcbiAgdG91Y2htb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gIHRvdWNoY2FuY2VsOiBcInBvaW50ZXJjYW5jZWxcIlxufTtcbmNvbnN0IF9FdmVudFN5c3RlbSA9IGNsYXNzIF9FdmVudFN5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBkZXZpY2Ugc3VwcG9ydHMgdG91Y2ggZXZlbnRzIGFjY29yZGluZyB0byB0aGUgVzNDIFRvdWNoIEV2ZW50cyBzcGVjLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGV2ZW50IGhhbmRsaW5nIHN0cmF0ZWd5LlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvfSBXM0MgVG91Y2ggRXZlbnRzIFNwZWNpZmljYXRpb25cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAZGVmYXVsdCAnb250b3VjaHN0YXJ0JyBpbiBnbG9iYWxUaGlzXG4gICAgICovXG4gICAgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBnbG9iYWxUaGlzO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjdXJyZW50IGRldmljZSBzdXBwb3J0cyBwb2ludGVyIGV2ZW50cyBhY2NvcmRpbmcgdG8gdGhlIFczQyBQb2ludGVyIEV2ZW50cyBzcGVjLlxuICAgICAqIFVzZWQgdG8gb3B0aW1pemUgZXZlbnQgaGFuZGxpbmcgYW5kIHByb3ZpZGUgbW9yZSBjb25zaXN0ZW50IGNyb3NzLWRldmljZSBpbnRlcmFjdGlvbi5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy99IFczQyBQb2ludGVyIEV2ZW50cyBTcGVjaWZpY2F0aW9uXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGRlZmF1bHQgISFnbG9iYWxUaGlzLlBvaW50ZXJFdmVudFxuICAgICAqL1xuICAgIHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gISFnbG9iYWxUaGlzLlBvaW50ZXJFdmVudDtcbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHJvb3QgZXZlbnQgbGlzdGVuZXJzIGFyZSBib3VuZC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0b1xuICAgICAqIHRoZSByZW5kZXJlcidzIHtAbGluayBSZW5kZXJlciN2aWV3IHZpZXd9LlxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgLyoqIFRoZSByZXNvbHV0aW9uIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIHRoZSBET00gY2xpZW50IHNwYWNlIGludG8gd29ybGQgc3BhY2UuICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5yb290Qm91bmRhcnkgPSBuZXcgRXZlbnRCb3VuZGFyeShudWxsKTtcbiAgICBFdmVudHNUaWNrZXIuaW5pdCh0aGlzKTtcbiAgICB0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgdGhpcy5fZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yb290UG9pbnRlckV2ZW50ID0gbmV3IEZlZGVyYXRlZFBvaW50ZXJFdmVudChudWxsKTtcbiAgICB0aGlzLl9yb290V2hlZWxFdmVudCA9IG5ldyBGZWRlcmF0ZWRXaGVlbEV2ZW50KG51bGwpO1xuICAgIHRoaXMuY3Vyc29yU3R5bGVzID0ge1xuICAgICAgZGVmYXVsdDogXCJpbmhlcml0XCIsXG4gICAgICBwb2ludGVyOiBcInBvaW50ZXJcIlxuICAgIH07XG4gICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBQcm94eSh7IC4uLl9FdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRGZWF0dXJlcyB9LCB7XG4gICAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJnbG9iYWxNb3ZlXCIpIHtcbiAgICAgICAgICB0aGlzLnJvb3RCb3VuZGFyeS5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fb25Qb2ludGVyRG93biA9IHRoaXMuX29uUG9pbnRlckRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJNb3ZlID0gdGhpcy5fb25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUG9pbnRlclVwID0gdGhpcy5fb25Qb2ludGVyVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJPdmVyT3V0ID0gdGhpcy5fb25Qb2ludGVyT3Zlck91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25XaGVlbCA9IHRoaXMub25XaGVlbC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlIGZvciBhbGwgZGlzcGxheSBvYmplY3RzLlxuICAgKiBAc2VlIENvbnRhaW5lci5ldmVudE1vZGVcbiAgICogQHR5cGUge0V2ZW50TW9kZX1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0RXZlbnRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXZlbnRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSdW5uZXIgaW5pdCBjYWxsZWQsIHZpZXcgaXMgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2FudmFzLCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudChjYW52YXMpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgX0V2ZW50U3lzdGVtLl9kZWZhdWx0RXZlbnRNb2RlID0gb3B0aW9ucy5ldmVudE1vZGUgPz8gXCJwYXNzaXZlXCI7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmZlYXR1cmVzLCBvcHRpb25zLmV2ZW50RmVhdHVyZXMgPz8ge30pO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB0aGlzLmZlYXR1cmVzLmdsb2JhbE1vdmU7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2luZyByZXNvbHV0aW9uLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZXNvbHV0aW9uQ2hhbmdlKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBkZXRhY2hlcyB0aGUgcmVuZGVyZXIuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRzVGlja2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNldFRhcmdldEVsZW1lbnQobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudEN1cnNvciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgY3Vyc29yIG1vZGUsIGhhbmRsaW5nIGFueSBjYWxsYmFja3Mgb3IgQ1NTIHN0eWxlIGNoYW5nZXMuXG4gICAqIFRoZSBjdXJzb3IgY2FuIGJlIGEgQ1NTIGN1cnNvciBzdHJpbmcsIGEgY3VzdG9tIGNhbGxiYWNrIGZ1bmN0aW9uLCBvciBhIGtleSBmcm9tIHRoZSBjdXJzb3JTdHlsZXMgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIG1vZGUgLSBDdXJzb3IgbW9kZSB0byBzZXQuIENhbiBiZTpcbiAgICogLSBBIENTUyBjdXJzb3Igc3RyaW5nIChlLmcuLCAncG9pbnRlcicsICdncmFiJylcbiAgICogLSBBIGtleSBmcm9tIHRoZSBjdXJzb3JTdHlsZXMgZGljdGlvbmFyeVxuICAgKiAtIG51bGwvdW5kZWZpbmVkIHRvIHJlc2V0IHRvIGRlZmF1bHRcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gVXNpbmcgcHJlZGVmaW5lZCBjdXJzb3Igc3R5bGVzXG4gICAqIGFwcC5yZW5kZXJlci5ldmVudHMuc2V0Q3Vyc29yKCdwb2ludGVyJyk7ICAgIC8vIFNldCBzdGFuZGFyZCBwb2ludGVyIGN1cnNvclxuICAgKiBhcHAucmVuZGVyZXIuZXZlbnRzLnNldEN1cnNvcignZ3JhYicpOyAgICAgICAvLyBTZXQgZ3JhYiBjdXJzb3JcbiAgICogYXBwLnJlbmRlcmVyLmV2ZW50cy5zZXRDdXJzb3IobnVsbCk7ICAgICAgICAgLy8gUmVzZXQgdG8gZGVmYXVsdFxuICAgKlxuICAgKiAvLyBVc2luZyBjdXN0b20gY3Vyc29yIHN0eWxlc1xuICAgKiBhcHAucmVuZGVyZXIuZXZlbnRzLmN1cnNvclN0eWxlcy5jdXN0b20gPSAndXJsKFwiY3Vyc29yLnBuZ1wiKSwgYXV0byc7XG4gICAqIGFwcC5yZW5kZXJlci5ldmVudHMuc2V0Q3Vyc29yKCdjdXN0b20nKTsgICAgIC8vIEFwcGx5IGN1c3RvbSBjdXJzb3JcbiAgICpcbiAgICogLy8gVXNpbmcgY2FsbGJhY2stYmFzZWQgY3Vyc29yXG4gICAqIGFwcC5yZW5kZXJlci5ldmVudHMuY3Vyc29yU3R5bGVzLmR5bmFtaWMgPSAobW9kZSkgPT4ge1xuICAgKiAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBtb2RlID09PSAnaG92ZXInID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xuICAgKiB9O1xuICAgKiBhcHAucmVuZGVyZXIuZXZlbnRzLnNldEN1cnNvcignZHluYW1pYycpOyAgICAvLyBUcmlnZ2VyIGN1cnNvciBjYWxsYmFja1xuICAgKiBgYGBcbiAgICogQHJlbWFya3NcbiAgICogLSBIYXMgbm8gZWZmZWN0IG9uIE9mZnNjcmVlbkNhbnZhcyBleGNlcHQgZm9yIGNhbGxiYWNrLWJhc2VkIGN1cnNvcnNcbiAgICogLSBDYWNoZXMgY3VycmVudCBjdXJzb3IgdG8gYXZvaWQgdW5uZWNlc3NhcnkgRE9NIHVwZGF0ZXNcbiAgICogLSBTdXBwb3J0cyBDU1MgY3Vyc29yIHZhbHVlcywgc3R5bGUgb2JqZWN0cywgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiBAc2VlIHtAbGluayBFdmVudFN5c3RlbS5jdXJzb3JTdHlsZXN9IEZvciBkZWZpbmluZyBjdXN0b20gY3Vyc29yIHN0eWxlc1xuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY3Vyc29yfSBNRE4gQ3Vyc29yIFJlZmVyZW5jZVxuICAgKi9cbiAgc2V0Q3Vyc29yKG1vZGUpIHtcbiAgICBtb2RlIHx8IChtb2RlID0gXCJkZWZhdWx0XCIpO1xuICAgIGxldCBhcHBseVN0eWxlcyA9IHRydWU7XG4gICAgaWYgKGdsb2JhbFRoaXMuT2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMuZG9tRWxlbWVudCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgYXBwbHlTdHlsZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDdXJzb3IgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudEN1cnNvciA9IG1vZGU7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN1cnNvclN0eWxlc1ttb2RlXTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHN0eWxlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoYXBwbHlTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHN0eWxlKG1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGFwcGx5U3R5bGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwcGx5U3R5bGVzICYmIHR5cGVvZiBtb2RlID09PSBcInN0cmluZ1wiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbW9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnbG9iYWwgcG9pbnRlciBldmVudCBpbnN0YW5jZSBjb250YWluaW5nIHRoZSBtb3N0IHJlY2VudCBwb2ludGVyIHN0YXRlLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIHBvaW50ZXIgaW5mb3JtYXRpb24gd2l0aG91dCBsaXN0ZW5pbmcgdG8gZXZlbnRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBBY2Nlc3MgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGF0IGFueSB0aW1lXG4gICAqIGNvbnN0IGV2ZW50U3lzdGVtID0gYXBwLnJlbmRlcmVyLmV2ZW50cztcbiAgICogY29uc3QgcG9pbnRlciA9IGV2ZW50U3lzdGVtLnBvaW50ZXI7XG4gICAqXG4gICAqIC8vIEdldCBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICogY29uc29sZS5sb2coJ1Bvc2l0aW9uOicsIHBvaW50ZXIuZ2xvYmFsLngsIHBvaW50ZXIuZ2xvYmFsLnkpO1xuICAgKlxuICAgKiAvLyBDaGVjayBidXR0b24gc3RhdGVcbiAgICogY29uc29sZS5sb2coJ0J1dHRvbnMgcHJlc3NlZDonLCBwb2ludGVyLmJ1dHRvbnMpO1xuICAgKlxuICAgKiAvLyBHZXQgcG9pbnRlciB0eXBlIGFuZCBwcmVzc3VyZVxuICAgKiBjb25zb2xlLmxvZygnVHlwZTonLCBwb2ludGVyLnBvaW50ZXJUeXBlKTtcbiAgICogY29uc29sZS5sb2coJ1ByZXNzdXJlOicsIHBvaW50ZXIucHJlc3N1cmUpO1xuICAgKiBgYGBcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKiBAc2VlIHtAbGluayBGZWRlcmF0ZWRQb2ludGVyRXZlbnR9IEZvciBhbGwgYXZhaWxhYmxlIHBvaW50ZXIgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IHBvaW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RQb2ludGVyRXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgZG93biBldmVudHMgb24ge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50LlxuICAgKi9cbiAgX29uUG9pbnRlckRvd24obmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX25vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCAmJiBldmVudHNbMF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICBjb25zdCBjYW5jZWxhYmxlID0gbmF0aXZlRXZlbnQuY2FuY2VsYWJsZSB8fCAhKFwiY2FuY2VsYWJsZVwiIGluIG5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gZXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgbmF0aXZlRXZlbnQyID0gZXZlbnRzW2ldO1xuICAgICAgY29uc3QgZmVkZXJhdGVkRXZlbnQgPSB0aGlzLl9ib290c3RyYXBFdmVudCh0aGlzLl9yb290UG9pbnRlckV2ZW50LCBuYXRpdmVFdmVudDIpO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZmVkZXJhdGVkRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBwb2ludGVyIG1vdmUgZXZlbnRzIG9uIG9uIHtAbGluayBFdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudHMuXG4gICAqL1xuICBfb25Qb2ludGVyTW92ZShuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5tb3ZlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBFdmVudHNUaWNrZXIucG9pbnRlck1vdmVkKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMuX25vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fYm9vdHN0cmFwRXZlbnQodGhpcy5fcm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgdXAgZXZlbnRzIG9uIHtAbGluayBFdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudC5cbiAgICovXG4gIF9vblBvaW50ZXJVcChuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgbGV0IHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICBpZiAobmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoICYmIG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRhcmdldCA9IG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgIH1cbiAgICBjb25zdCBvdXRzaWRlID0gdGFyZ2V0ICE9PSB0aGlzLmRvbUVsZW1lbnQgPyBcIm91dHNpZGVcIiA6IFwiXCI7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMuX25vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fYm9vdHN0cmFwRXZlbnQodGhpcy5fcm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICBldmVudC50eXBlICs9IG91dHNpZGU7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgb3ZlciAmIG91dCBldmVudHMgb24ge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50LlxuICAgKi9cbiAgX29uUG9pbnRlck92ZXJPdXQobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLl9ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuX2Jvb3RzdHJhcEV2ZW50KHRoaXMuX3Jvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcih0aGlzLnJvb3RCb3VuZGFyeS5jdXJzb3IpO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzaXZlIGhhbmRsZXIgZm9yIGB3aGVlbGAgZXZlbnRzIG9uIHtAbGluayBFdmVudFN5c3RlbS5kb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQuXG4gICAqL1xuICBvbldoZWVsKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLndoZWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLm5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudCh3aGVlbEV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgZG9tRWxlbWVudH0gYW5kIGJpbmRzIGV2ZW50IGxpc3RlbmVycy5cbiAgICogVGhpcyBtZXRob2QgbWFuYWdlcyB0aGUgRE9NIGV2ZW50IGJpbmRpbmdzIGZvciB0aGUgZXZlbnQgc3lzdGVtLCBhbGxvd2luZyB5b3UgdG9cbiAgICogY2hhbmdlIG9yIHJlbW92ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgdGhhdCByZWNlaXZlcyBpbnB1dCBldmVudHMuXG4gICAqID4gWyFJTVBPUlRBTlRdIFRoaXMgd2lsbCBkZWZhdWx0IHRvIHRoZSBjYW52YXMgZWxlbWVudCBvZiB0aGUgcmVuZGVyZXIsIHNvIHlvdVxuICAgKiA+IHNob3VsZCBub3QgbmVlZCB0byBjYWxsIHRoaXMgdW5sZXNzIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gZWxlbWVudC5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgbmV3IERPTSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzIHRvLCBvciBudWxsIHRvIHJlbW92ZSBhbGwgZXZlbnQgYmluZGluZ3NcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gU2V0IGEgbmV3IGNhbnZhcyBlbGVtZW50IGFzIHRoZSB0YXJnZXRcbiAgICogY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAqIGFwcC5yZW5kZXJlci5ldmVudHMuc2V0VGFyZ2V0RWxlbWVudChjYW52YXMpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGV2ZW50IGJpbmRpbmdzXG4gICAqIGFwcC5yZW5kZXJlci5ldmVudHMuc2V0VGFyZ2V0RWxlbWVudChudWxsKTtcbiAgICpcbiAgICogLy8gU3dpdGNoIHRvIGEgZGlmZmVyZW50IGNhbnZhc1xuICAgKiBjb25zdCBuZXdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FtZS1jYW52YXMnKTtcbiAgICogYXBwLnJlbmRlcmVyLmV2ZW50cy5zZXRUYXJnZXRFbGVtZW50KG5ld0NhbnZhcyk7XG4gICAqIGBgYFxuICAgKiBAcmVtYXJrc1xuICAgKiAtIEF1dG9tYXRpY2FsbHkgcmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBwcmV2aW91cyBlbGVtZW50XG4gICAqIC0gUmVxdWlyZWQgZm9yIHRoZSBldmVudCBzeXN0ZW0gdG8gZnVuY3Rpb25cbiAgICogLSBTYWZlIHRvIGNhbGwgbXVsdGlwbGUgdGltZXNcbiAgICogQHNlZSB7QGxpbmsgRXZlbnRTeXN0ZW0jZG9tRWxlbWVudH0gVGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcbiAgICogQHNlZSB7QGxpbmsgRXZlbnRzVGlja2VyfSBGb3IgdGhlIHRpY2tlciBzeXN0ZW0gdGhhdCB0cmFja3MgcG9pbnRlciBtb3ZlbWVudFxuICAgKi9cbiAgc2V0VGFyZ2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRzKCk7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudDtcbiAgICBFdmVudHNUaWNrZXIuZG9tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fYWRkRXZlbnRzKCk7XG4gIH1cbiAgLyoqIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBvbiB7QGxpbmsgUmVuZGVyZXIjZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LiAqL1xuICBfYWRkRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLl9ldmVudHNBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEV2ZW50c1RpY2tlci5hZGRUaWNrZXJMaXN0ZW5lcigpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgaWYgKGdsb2JhbFRoaXMubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgc3R5bGUubXNDb250ZW50Wm9vbWluZyA9IFwibm9uZVwiO1xuICAgICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5fb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuX29uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdmVyXCIsIHRoaXMuX29uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuX29uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMuX29uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX29uUG9pbnRlclVwLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50c0FkZGVkID0gdHJ1ZTtcbiAgfVxuICAvKiogVW5yZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgb24ge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS4gKi9cbiAgX3JlbW92ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c0FkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRzVGlja2VyLnJlbW92ZVRpY2tlckxpc3RlbmVyKCk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICBzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJcIjtcbiAgICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHRydWUpO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogTWFwcyBjb29yZGluYXRlcyBmcm9tIERPTS9zY3JlZW4gc3BhY2UgaW50byBQaXhpSlMgbm9ybWFsaXplZCBjb29yZGluYXRlcy5cbiAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnQgc2NhbGUsIHBvc2l0aW9uLCBhbmQgcmVzb2x1dGlvbiBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBzdG9yZSB0aGUgbWFwcGVkIGNvb3JkaW5hdGVzIGluXG4gICAqIEBwYXJhbSB4IC0gVGhlIHggY29vcmRpbmF0ZSBpbiBET00vY2xpZW50IHNwYWNlXG4gICAqIEBwYXJhbSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBpbiBET00vY2xpZW50IHNwYWNlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIE1hcCBtb3VzZSBjb29yZGluYXRlcyB0byBQaXhpSlMgc3BhY2VcbiAgICogY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICogYXBwLnJlbmRlcmVyLmV2ZW50cy5tYXBQb3NpdGlvblRvUG9pbnQoXG4gICAqICAgICBwb2ludCxcbiAgICogICAgIGV2ZW50LmNsaWVudFgsXG4gICAqICAgICBldmVudC5jbGllbnRZXG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKCdNYXBwZWQgcG9zaXRpb246JywgcG9pbnQueCwgcG9pbnQueSk7XG4gICAqXG4gICAqIC8vIFVzaW5nIHdpdGggcG9pbnRlciBldmVudHNcbiAgICogc3ByaXRlLm9uKCdwb2ludGVybW92ZScsIChldmVudCkgPT4ge1xuICAgKiAgICAgLy8gZXZlbnQuZ2xvYmFsIGFscmVhZHkgY29udGFpbnMgbWFwcGVkIGNvb3JkaW5hdGVzXG4gICAqICAgICBjb25zb2xlLmxvZygnR2xvYmFsOicsIGV2ZW50Lmdsb2JhbC54LCBldmVudC5nbG9iYWwueSk7XG4gICAqXG4gICAqICAgICAvLyBNYXAgdG8gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICogICAgIGNvbnN0IGxvY2FsID0gZXZlbnQuZ2V0TG9jYWxQb3NpdGlvbihzcHJpdGUpO1xuICAgKiAgICAgY29uc29sZS5sb2coJ0xvY2FsOicsIGxvY2FsLngsIGxvY2FsLnkpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEByZW1hcmtzXG4gICAqIC0gQWNjb3VudHMgZm9yIGVsZW1lbnQgc2NhbGluZyBhbmQgcG9zaXRpb25pbmdcbiAgICogLSBBZGp1c3RzIGZvciBkZXZpY2UgcGl4ZWwgcmF0aW8vcmVzb2x1dGlvblxuICAgKi9cbiAgbWFwUG9zaXRpb25Ub1BvaW50KHBvaW50LCB4LCB5KSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZG9tRWxlbWVudC5pc0Nvbm5lY3RlZCA/IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHRoaXMuZG9tRWxlbWVudC53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5kb21FbGVtZW50LmhlaWdodCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdXRpb25NdWx0aXBsaWVyID0gMSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICBwb2ludC54ID0gKHggLSByZWN0LmxlZnQpICogKHRoaXMuZG9tRWxlbWVudC53aWR0aCAvIHJlY3Qud2lkdGgpICogcmVzb2x1dGlvbk11bHRpcGxpZXI7XG4gICAgcG9pbnQueSA9ICh5IC0gcmVjdC50b3ApICogKHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgLyByZWN0LmhlaWdodCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBhIHJlZ3VsYXIgcG9pbnRlciBldmVudCB3b3VsZCBoYXZlXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBkYXRhIGZyb20gYSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGEgc2luZ2xlIG5vcm1hbGl6ZWQgcG9pbnRlciBldmVudCwgaW4gdGhlIGNhc2Ugb2YgYSBwb2ludGVyXG4gICAqICBvciBtb3VzZSBldmVudCwgb3IgYSBtdWx0aXBsZSBub3JtYWxpemVkIHBvaW50ZXIgZXZlbnRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VkIHRvdWNoZXNcbiAgICovXG4gIF9ub3JtYWxpemVUb1BvaW50ZXJEYXRhKGV2ZW50KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IFtdO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9uID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmJ1dHRvbiA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9ucyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5idXR0b25zID0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5pc1ByaW1hcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0b3VjaC5pc1ByaW1hcnkgPSBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLndpZHRoID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLndpZHRoID0gdG91Y2gucmFkaXVzWCB8fCAxO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmhlaWdodCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5oZWlnaHQgPSB0b3VjaC5yYWRpdXNZIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGlsdFggPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRpbHRZID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnRpbHRZID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVyVHlwZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5wb2ludGVyVHlwZSA9IFwidG91Y2hcIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVySWQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gucG9pbnRlcklkID0gdG91Y2guaWRlbnRpZmllciB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnByZXNzdXJlID0gdG91Y2guZm9yY2UgfHwgMC41O1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnR3aXN0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnR3aXN0ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gubGF5ZXJYID0gdG91Y2gub2Zmc2V0WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJZID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmxheWVyWSA9IHRvdWNoLm9mZnNldFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICB0b3VjaC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0b3VjaC50eXBlID0gZXZlbnQudHlwZTtcbiAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFnbG9iYWxUaGlzLk1vdXNlRXZlbnQgfHwgZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmICghdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgfHwgIShldmVudCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUG9pbnRlckV2ZW50KSkpIHtcbiAgICAgIGNvbnN0IHRlbXBFdmVudCA9IGV2ZW50O1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQuaXNQcmltYXJ5ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LndpZHRoID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQud2lkdGggPSAxO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQuaGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQuaGVpZ2h0ID0gMTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnRpbHRYID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudGlsdFggPSAwO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGlsdFkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50aWx0WSA9IDA7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnBvaW50ZXJUeXBlID0gXCJtb3VzZVwiO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQucG9pbnRlcklkID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucG9pbnRlcklkID0gTU9VU0VfUE9JTlRFUl9JRDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucHJlc3N1cmUgPSAwLjU7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50d2lzdCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnR3aXN0ID0gMDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gICAgICB0ZW1wRXZlbnQuaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0ZW1wRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZEV2ZW50cztcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgbmF0aXZlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2ludGVyZmFjZS13aGVlbGV2ZW50IFdoZWVsRXZlbnR9LlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQge0BsaW5rIEZlZGVyYXRlZFdoZWVsRXZlbnR9IGlzIGEgc2hhcmVkIGluc3RhbmNlLiBJdCB3aWxsIG5vdCBwZXJzaXN0IGFjcm9zc1xuICAgKiBtdWx0aXBsZSBuYXRpdmUgd2hlZWwgZXZlbnRzLlxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnQgLSBUaGUgbmF0aXZlIHdoZWVsIGV2ZW50IHRoYXQgb2NjdXJyZWQgb24gdGhlIGNhbnZhcy5cbiAgICogQHJldHVybnMgQSBmZWRlcmF0ZWQgd2hlZWwgZXZlbnQuXG4gICAqL1xuICBub3JtYWxpemVXaGVlbEV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLl9yb290V2hlZWxFdmVudDtcbiAgICB0aGlzLl90cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpO1xuICAgIGV2ZW50LmRlbHRhWCA9IG5hdGl2ZUV2ZW50LmRlbHRhWDtcbiAgICBldmVudC5kZWx0YVkgPSBuYXRpdmVFdmVudC5kZWx0YVk7XG4gICAgZXZlbnQuZGVsdGFaID0gbmF0aXZlRXZlbnQuZGVsdGFaO1xuICAgIGV2ZW50LmRlbHRhTW9kZSA9IG5hdGl2ZUV2ZW50LmRlbHRhTW9kZTtcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpO1xuICAgIGV2ZW50Lmdsb2JhbC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm9mZnNldC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBgbmF0aXZlRXZlbnRgIGludG8gYSBmZWRlcmF0ZWVkIHtAbGluayBGZWRlcmF0ZWRQb2ludGVyRXZlbnR9LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICBfYm9vdHN0cmFwRXZlbnQoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgZXZlbnQub3JpZ2luYWxFdmVudCA9IG51bGw7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBldmVudC5wb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgZXZlbnQud2lkdGggPSBuYXRpdmVFdmVudC53aWR0aDtcbiAgICBldmVudC5oZWlnaHQgPSBuYXRpdmVFdmVudC5oZWlnaHQ7XG4gICAgZXZlbnQuaXNQcmltYXJ5ID0gbmF0aXZlRXZlbnQuaXNQcmltYXJ5O1xuICAgIGV2ZW50LnBvaW50ZXJUeXBlID0gbmF0aXZlRXZlbnQucG9pbnRlclR5cGU7XG4gICAgZXZlbnQucHJlc3N1cmUgPSBuYXRpdmVFdmVudC5wcmVzc3VyZTtcbiAgICBldmVudC50YW5nZW50aWFsUHJlc3N1cmUgPSBuYXRpdmVFdmVudC50YW5nZW50aWFsUHJlc3N1cmU7XG4gICAgZXZlbnQudGlsdFggPSBuYXRpdmVFdmVudC50aWx0WDtcbiAgICBldmVudC50aWx0WSA9IG5hdGl2ZUV2ZW50LnRpbHRZO1xuICAgIGV2ZW50LnR3aXN0ID0gbmF0aXZlRXZlbnQudHdpc3Q7XG4gICAgdGhpcy5fdHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KTtcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpO1xuICAgIGV2ZW50Lmdsb2JhbC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50Lm9mZnNldC5jb3B5RnJvbShldmVudC5zY3JlZW4pO1xuICAgIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZDtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJwb2ludGVybGVhdmVcIikge1xuICAgICAgZXZlbnQudHlwZSA9IFwicG9pbnRlcm91dFwiO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIikpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSBldmVudC50eXBlLnJlcGxhY2UoXCJtb3VzZVwiLCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSkge1xuICAgICAgZXZlbnQudHlwZSA9IFRPVUNIX1RPX1BPSU5URVJbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2ZlcnMgYmFzZSAmIG1vdXNlIGV2ZW50IGRhdGEgZnJvbSB0aGUgYG5hdGl2ZUV2ZW50YCB0byB0aGUgZmVkZXJhdGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICBfdHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgZXZlbnQuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgIGV2ZW50LnNyY0VsZW1lbnQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50O1xuICAgIGV2ZW50LnRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlO1xuICAgIGV2ZW50LmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleTtcbiAgICBldmVudC5idXR0b24gPSBuYXRpdmVFdmVudC5idXR0b247XG4gICAgZXZlbnQuYnV0dG9ucyA9IG5hdGl2ZUV2ZW50LmJ1dHRvbnM7XG4gICAgZXZlbnQuY2xpZW50LnggPSBuYXRpdmVFdmVudC5jbGllbnRYO1xuICAgIGV2ZW50LmNsaWVudC55ID0gbmF0aXZlRXZlbnQuY2xpZW50WTtcbiAgICBldmVudC5jdHJsS2V5ID0gbmF0aXZlRXZlbnQuY3RybEtleTtcbiAgICBldmVudC5tZXRhS2V5ID0gbmF0aXZlRXZlbnQubWV0YUtleTtcbiAgICBldmVudC5tb3ZlbWVudC54ID0gbmF0aXZlRXZlbnQubW92ZW1lbnRYO1xuICAgIGV2ZW50Lm1vdmVtZW50LnkgPSBuYXRpdmVFdmVudC5tb3ZlbWVudFk7XG4gICAgZXZlbnQucGFnZS54ID0gbmF0aXZlRXZlbnQucGFnZVg7XG4gICAgZXZlbnQucGFnZS55ID0gbmF0aXZlRXZlbnQucGFnZVk7XG4gICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgZXZlbnQuc2hpZnRLZXkgPSBuYXRpdmVFdmVudC5zaGlmdEtleTtcbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fRXZlbnRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImV2ZW50c1wiLFxuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBwcmlvcml0eTogLTFcbn07XG4vKipcbiAqIFRoZSBldmVudCBmZWF0dXJlcyB0aGF0IGFyZSBlbmFibGVkIGJ5IHRoZSBFdmVudFN5c3RlbVxuICogQHNpbmNlIDcuMi4wXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEV2ZW50U3lzdGVtLCBFdmVudFN5c3RlbUZlYXR1cmVzIH0gZnJvbSAncGl4aS5qcyc7XG4gKiAvLyBBY2Nlc3MgdGhlIGRlZmF1bHQgZXZlbnQgZmVhdHVyZXNcbiAqIEV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudEZlYXR1cmVzID0ge1xuICogICAgIC8vIEVuYWJsZSBwb2ludGVyIG1vdmVtZW50IGV2ZW50c1xuICogICAgIG1vdmU6IHRydWUsXG4gKiAgICAgLy8gRW5hYmxlIGdsb2JhbCBwb2ludGVyIG1vdmUgZXZlbnRzXG4gKiAgICAgZ2xvYmFsTW92ZTogdHJ1ZSxcbiAqICAgICAvLyBFbmFibGUgY2xpY2sgZXZlbnRzXG4gKiAgICAgY2xpY2s6IHRydWUsXG4gKiAgICAgLy8gRW5hYmxlIHdoZWVsIGV2ZW50c1xuICogICAgIHdoZWVsOiB0cnVlLFxuICogfTtcbiAqIGBgYFxuICovXG5fRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50RmVhdHVyZXMgPSB7XG4gIC8qKiBFbmFibGVzIHBvaW50ZXIgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aCBwb2ludGVyIG1vdmVtZW50LiAqL1xuICBtb3ZlOiB0cnVlLFxuICAvKiogRW5hYmxlcyBnbG9iYWwgcG9pbnRlciBtb3ZlIGV2ZW50cy4gKi9cbiAgZ2xvYmFsTW92ZTogdHJ1ZSxcbiAgLyoqIEVuYWJsZXMgcG9pbnRlciBldmVudHMgYXNzb2NpYXRlZCB3aXRoIGNsaWNraW5nLiAqL1xuICBjbGljazogdHJ1ZSxcbiAgLyoqIEVuYWJsZXMgd2hlZWwgZXZlbnRzLiAqL1xuICB3aGVlbDogdHJ1ZVxufTtcbmxldCBFdmVudFN5c3RlbSA9IF9FdmVudFN5c3RlbTtcblxuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSAnLi9FdmVudFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgRmVkZXJhdGVkQ29udGFpbmVyID0ge1xuICBvbmNsaWNrOiBudWxsLFxuICBvbm1vdXNlZG93bjogbnVsbCxcbiAgb25tb3VzZWVudGVyOiBudWxsLFxuICBvbm1vdXNlbGVhdmU6IG51bGwsXG4gIG9ubW91c2Vtb3ZlOiBudWxsLFxuICBvbmdsb2JhbG1vdXNlbW92ZTogbnVsbCxcbiAgb25tb3VzZW91dDogbnVsbCxcbiAgb25tb3VzZW92ZXI6IG51bGwsXG4gIG9ubW91c2V1cDogbnVsbCxcbiAgb25tb3VzZXVwb3V0c2lkZTogbnVsbCxcbiAgb25wb2ludGVyY2FuY2VsOiBudWxsLFxuICBvbnBvaW50ZXJkb3duOiBudWxsLFxuICBvbnBvaW50ZXJlbnRlcjogbnVsbCxcbiAgb25wb2ludGVybGVhdmU6IG51bGwsXG4gIG9ucG9pbnRlcm1vdmU6IG51bGwsXG4gIG9uZ2xvYmFscG9pbnRlcm1vdmU6IG51bGwsXG4gIG9ucG9pbnRlcm91dDogbnVsbCxcbiAgb25wb2ludGVyb3ZlcjogbnVsbCxcbiAgb25wb2ludGVydGFwOiBudWxsLFxuICBvbnBvaW50ZXJ1cDogbnVsbCxcbiAgb25wb2ludGVydXBvdXRzaWRlOiBudWxsLFxuICBvbnJpZ2h0Y2xpY2s6IG51bGwsXG4gIG9ucmlnaHRkb3duOiBudWxsLFxuICBvbnJpZ2h0dXA6IG51bGwsXG4gIG9ucmlnaHR1cG91dHNpZGU6IG51bGwsXG4gIG9udGFwOiBudWxsLFxuICBvbnRvdWNoY2FuY2VsOiBudWxsLFxuICBvbnRvdWNoZW5kOiBudWxsLFxuICBvbnRvdWNoZW5kb3V0c2lkZTogbnVsbCxcbiAgb250b3VjaG1vdmU6IG51bGwsXG4gIG9uZ2xvYmFsdG91Y2htb3ZlOiBudWxsLFxuICBvbnRvdWNoc3RhcnQ6IG51bGwsXG4gIG9ud2hlZWw6IG51bGwsXG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiIHx8IHRoaXMuZXZlbnRNb2RlID09PSBcInN0YXRpY1wiO1xuICB9LFxuICBzZXQgaW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICB0aGlzLmV2ZW50TW9kZSA9IHZhbHVlID8gXCJzdGF0aWNcIiA6IFwicGFzc2l2ZVwiO1xuICB9LFxuICBfaW50ZXJuYWxFdmVudE1vZGU6IHZvaWQgMCxcbiAgZ2V0IGV2ZW50TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPz8gRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50TW9kZTtcbiAgfSxcbiAgc2V0IGV2ZW50TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ludGVybmFsRXZlbnRNb2RlID0gdmFsdWU7XG4gIH0sXG4gIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRNb2RlID09PSBcInN0YXRpY1wiIHx8IHRoaXMuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIjtcbiAgfSxcbiAgaW50ZXJhY3RpdmVDaGlsZHJlbjogdHJ1ZSxcbiAgaGl0QXJlYTogbnVsbCxcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgJiYgb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmNhcHR1cmU7XG4gICAgY29uc3Qgc2lnbmFsID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLnNpZ25hbCA6IHZvaWQgMDtcbiAgICBjb25zdCBvbmNlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLm9uY2UgPT09IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGNvbnN0IGxpc3RlbmVyRm4gPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG4gICAgY29uc3QgZW1pdHRlciA9IHRoaXM7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGVtaXR0ZXIub2ZmKHR5cGUsIGxpc3RlbmVyRm4sIGNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UodHlwZSwgbGlzdGVuZXJGbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24odHlwZSwgbGlzdGVuZXJGbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgIHRoaXMub2ZmKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZlZGVyYXRlZEV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIGNhbm5vdCBwcm9wYWdhdGUgZXZlbnRzIG91dHNpZGUgb2YgdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJXCIpO1xuICAgIH1cbiAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICBlLnBhdGggPSBudWxsO1xuICAgIGUudGFyZ2V0ID0gdGhpcztcbiAgICBlLm1hbmFnZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICByZXR1cm4gIWUuZGVmYXVsdFByZXZlbnRlZDtcbiAgfVxufTtcblxuZXhwb3J0IHsgRmVkZXJhdGVkQ29udGFpbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudFRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBFdmVudFN5c3RlbSB9IGZyb20gJy4vRXZlbnRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZENvbnRhaW5lciB9IGZyb20gJy4vRmVkZXJhdGVkRXZlbnRUYXJnZXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChFdmVudFN5c3RlbSk7XG5leHRlbnNpb25zLm1peGluKENvbnRhaW5lciwgRmVkZXJhdGVkQ29udGFpbmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ2FudmFzT2JzZXJ2ZXIgfSBmcm9tICcuL0NhbnZhc09ic2VydmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRE9NUGlwZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIERPTVBpcGUgY2xhc3MuXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciBpbnN0YW5jZSB0aGF0IHRoaXMgRE9NUGlwZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgLyoqIEFycmF5IHRvIGtlZXAgdHJhY2sgb2YgYXR0YWNoZWQgRE9NIGVsZW1lbnRzICovXG4gICAgdGhpcy5fYXR0YWNoZWREb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLmFkZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci5ydW5uZXJzLmluaXQuYWRkKHRoaXMpO1xuICAgIHRoaXMuX2RvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuX2RvbUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGhpcy5fZG9tRWxlbWVudC5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICB0aGlzLl9kb21FbGVtZW50LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICB0aGlzLl9kb21FbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICB0aGlzLl9kb21FbGVtZW50LnN0eWxlLnpJbmRleCA9IFwiMTAwMFwiO1xuICB9XG4gIC8qKiBJbml0aWFsaXplcyB0aGUgRE9NUGlwZSwgc2V0dGluZyB1cCB0aGUgbWFpbiBET00gZWxlbWVudCBhbmQgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudCBib2R5LiAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuX2NhbnZhc09ic2VydmVyID0gbmV3IENhbnZhc09ic2VydmVyKHtcbiAgICAgIGRvbUVsZW1lbnQ6IHRoaXMuX2RvbUVsZW1lbnQsXG4gICAgICByZW5kZXJlcjogdGhpcy5fcmVuZGVyZXJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbmRlcmFibGUgRE9NIGNvbnRhaW5lciB0byB0aGUgbGlzdCBvZiBhdHRhY2hlZCBlbGVtZW50cy5cbiAgICogQHBhcmFtIGRvbUNvbnRhaW5lciAtIFRoZSBET00gY29udGFpbmVyIHRvIGJlIGFkZGVkLlxuICAgKiBAcGFyYW0gX2luc3RydWN0aW9uU2V0IC0gVGhlIGluc3RydWN0aW9uIHNldCAodW51c2VkKS5cbiAgICovXG4gIGFkZFJlbmRlcmFibGUoZG9tQ29udGFpbmVyLCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBpZiAoIXRoaXMuX2F0dGFjaGVkRG9tRWxlbWVudHMuaW5jbHVkZXMoZG9tQ29udGFpbmVyKSkge1xuICAgICAgdGhpcy5fYXR0YWNoZWREb21FbGVtZW50cy5wdXNoKGRvbUNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgcmVuZGVyYWJsZSBET00gY29udGFpbmVyLlxuICAgKiBAcGFyYW0gX2RvbUNvbnRhaW5lciAtIFRoZSBET00gY29udGFpbmVyIHRvIGJlIHVwZGF0ZWQgKHVudXNlZCkuXG4gICAqL1xuICB1cGRhdGVSZW5kZXJhYmxlKF9kb21Db250YWluZXIpIHtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgcmVuZGVyYWJsZSBET00gY29udGFpbmVyLlxuICAgKiBAcGFyYW0gX2RvbUNvbnRhaW5lciAtIFRoZSBET00gY29udGFpbmVyIHRvIGJlIHZhbGlkYXRlZCAodW51c2VkKS5cbiAgICogQHJldHVybnMgQWx3YXlzIHJldHVybnMgdHJ1ZSBhcyB2YWxpZGF0aW9uIGlzIG5vdCByZXF1aXJlZC5cbiAgICovXG4gIHZhbGlkYXRlUmVuZGVyYWJsZShfZG9tQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEhhbmRsZXMgdGhlIHBvc3QtcmVuZGVyaW5nIHByb2Nlc3MsIGVuc3VyaW5nIERPTSBlbGVtZW50cyBhcmUgY29ycmVjdGx5IHBvc2l0aW9uZWQgYW5kIHZpc2libGUuICovXG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgY29uc3QgYXR0YWNoZWREb21FbGVtZW50cyA9IHRoaXMuX2F0dGFjaGVkRG9tRWxlbWVudHM7XG4gICAgaWYgKGF0dGFjaGVkRG9tRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9kb21FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYW52YXNPYnNlcnZlci5lbnN1cmVBdHRhY2hlZCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0YWNoZWREb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZG9tQ29udGFpbmVyID0gYXR0YWNoZWREb21FbGVtZW50c1tpXTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb21Db250YWluZXIuZWxlbWVudDtcbiAgICAgIGlmICghZG9tQ29udGFpbmVyLnBhcmVudCB8fCBkb21Db250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cyA8IDcpIHtcbiAgICAgICAgZWxlbWVudD8ucmVtb3ZlKCk7XG4gICAgICAgIGF0dGFjaGVkRG9tRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX2RvbUVsZW1lbnQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICAgIHRoaXMuX2RvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3QgPSBkb21Db250YWluZXIud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGRvbUNvbnRhaW5lci5fYW5jaG9yO1xuICAgICAgICBjb25zdCBheCA9IGRvbUNvbnRhaW5lci53aWR0aCAqIGFuY2hvci54O1xuICAgICAgICBjb25zdCBheSA9IGRvbUNvbnRhaW5lci5oZWlnaHQgKiBhbmNob3IueTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBgJHtheH1weCAke2F5fXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4KCR7d3QuYX0sICR7d3QuYn0sICR7d3QuY30sICR7d3QuZH0sICR7d3QudHggLSBheH0sICR7d3QudHkgLSBheX0pYDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gZG9tQ29udGFpbmVyLmdyb3VwQWxwaGEudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBET01QaXBlLCByZW1vdmluZyBhbGwgYXR0YWNoZWQgRE9NIGVsZW1lbnRzIGFuZCBjbGVhbmluZyB1cCByZXNvdXJjZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLnJlbW92ZSh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dGFjaGVkRG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRvbUNvbnRhaW5lciA9IHRoaXMuX2F0dGFjaGVkRG9tRWxlbWVudHNbaV07XG4gICAgICBkb21Db250YWluZXIuZWxlbWVudD8ucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaGVkRG9tRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9kb21FbGVtZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuX2NhbnZhc09ic2VydmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKlxuICogU3RhdGljIHByb3BlcnR5IGRlZmluaW5nIHRoZSBleHRlbnNpb24gdHlwZSBhbmQgbmFtZSBmb3IgdGhlIERPTVBpcGUuXG4gKiBUaGlzIGlzIHVzZWQgdG8gcmVnaXN0ZXIgdGhlIERPTVBpcGUgd2l0aCBkaWZmZXJlbnQgcmVuZGVyaW5nIHBpcGVsaW5lcy5cbiAqL1xuRE9NUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiZG9tXCJcbn07XG5cbmV4cG9ydCB7IERPTVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURPTVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgRE9NUGlwZSB9IGZyb20gJy4vRE9NUGlwZS5tanMnO1xuaW1wb3J0ICcuL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBDYW52YXNPYnNlcnZlciB9IGZyb20gJy4vQ2FudmFzT2JzZXJ2ZXIubWpzJztcbmV4cG9ydCB7IERPTUNvbnRhaW5lciB9IGZyb20gJy4vRE9NQ29udGFpbmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoRE9NUGlwZSk7XG5cbmV4cG9ydCB7IERPTVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIiwiaW1wb3J0ICcuLi9hY2Nlc3NpYmlsaXR5L2luaXQubWpzJztcbmltcG9ydCAnLi4vYXBwL2luaXQubWpzJztcbmltcG9ydCAnLi4vZXZlbnRzL2luaXQubWpzJztcbmltcG9ydCAnLi4vZG9tL2luaXQubWpzJztcbmltcG9ydCAnLi4vc3ByaXRlc2hlZXQvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9yZW5kZXJpbmcvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS9ncmFwaGljcy9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL3NjZW5lL21lc2gvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS9wYXJ0aWNsZS1jb250YWluZXIvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS90ZXh0L2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvdGV4dC1iaXRtYXAvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS90ZXh0LWh0bWwvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS9zcHJpdGUtdGlsaW5nL2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9maWx0ZXJzL2luaXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyQWxsLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8397\n\n}')}}]);