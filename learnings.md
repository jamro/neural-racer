- **random jitter**: adding a random jitter to the start direction and position of the car help to make sure that the leader is stable
- **layered mutation**: mutating the hidden and output layers of the neural network separately helps to explore different action strategies. Applying more mutation to the output layer helps to explore different action strategies without losing the learned features from the hidden layer.
- **nine radar beams**: nine beams in the radar seams to be a good balance between providing enough information to the car and keeping the complexity low.
- **stading out leader**: when leader stands out from the other cars, focus on the rest of population to catch up. That should give you a new, improved leader.
- **svg track editro**: SVG is a convenient way to create and edit tracks. It is a XML that can be easily parsed and used in the code. Visual editors such as Inkscape are a good way quickly design tracks geometries.
- **crossover types**: blended crossover work better to preserve the learned features from the parent genomes while unifrom crossover work better to explore new action strategies. Hybrid approach allows to mix both approaches with different ratios.
- **curriculum learning**: starting with easy tracks and gradually increasing the difficulty helps to learn the basic driving skills and then apply them to more complex tracks.
- **catastrophic forgetting**: during the evolution process on a specific track, inject randomly one of past completed tracks and run a single epoch on it to prevent the catastrophic forgetting of the learned features.
- **Leaky ReLU > ReLU**: Leaky ReLU is better than ReLU in this setup because it prevents neurons from becoming permanently inactive, allowing all weights to keep influencing behavior and remain evolvable by the genetic algorithm
- **radar beam layout**: putting more beams in the center of the car and less beams on sides gives better results (higher resolution data). Longer beams in the front also help (achieved by by adjusting the decay rate of the radar beams in the neural network inputs).
- **extra input**: adding extra inputs calculated from the car's state helps to improve the performance of the neural network (e.g. time to collision, left right balance, etc.).
- **meaningful inputs**: to check if the inputs are meaningful, run tests race disabling selected inputs (e.g. by setting them to 0) and compare the results with the original race. Score difference will show if the inputs are helpful.
- **AI-generated graphics**: AI can be used to generate spritesheets with track tetrues and elements.
- **Less neurons is more**: GA does not handle well large NNs with many unused neurons. It leads to mutation of non significant parameters and slower evolution.
- **Too few neurons is also bad**: Too few neurons in the hidden layer can lead to slower learning and worse performance.
- **Flat Data Structures**: Avoid per-step allocations and pointer-heavy containers (Sets, small arrays, string keys) in tight physics loops; using flat, contiguous data with explicit indexing dramatically reduces GC pressure and improves cache locality, enabling many more simulations per second.
- **Compress genome data**: unoptimized genome data can easly take up to few MBs of memory for a whole population. When storing long population history, it can take up to few 100MBs of memory. To reduce the memory usage, we can compress the genome data using Int16 + scale quantization.
- **Visualizing Neural Network**: treat visualization as a readability pipeline, not “draw all weights”. Use robust per-layer scaling (e.g. P95) so outliers don’t wash out detail, then sparsify: keep top-K + above-threshold edges (incoming and outgoing). Reduce crossings by reordering hidden nodes, add structure by grouping/annotating inputs and optionally bundling edges by output, and fade changes over time to avoid jitter.
- **Hall of Fame**: keep a separate best-performers list for each track (e.g., top 30 per track). Only add new entries if their score differs significantly from existing ones (fitness distance threshold) to maintain diversity. Track how each genome performs across all tracks and combine scores into a global ranking (scores below 1.0 are penalized, above 1.0 are summed). When selecting genomes, use rank-based probability (better performers are more likely, but all have a chance). Track genomes by ID to avoid duplicates and update their multi-track performance efficiently. Only include cars that completed the track.
- **Multi-track evolution**: To create generalists able to perform well on different tracks, it is crucial to run the same population on different tracks and calculate aggregated score across all tracks. Hall of Fame is not enough.
- **Config modes**: Adjust evolution config based on the stagnation detection. If the population is stagnated without strong leader, switch to exploration mode to move it out of the local optimum. If the population is stagnated with strong leader, switch to finetuning mode move it towards the leader.